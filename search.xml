<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++| 基础学习之并发编程</title>
    <url>/2023/03/07/C++%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-并发编程"><a href="#C-并发编程" class="headerlink" title="C++并发编程"></a>C++并发编程</h1><h2 id="进程-x2F-线程-x2F-协程"><a href="#进程-x2F-线程-x2F-协程" class="headerlink" title="进程&#x2F;线程&#x2F;协程"></a>进程&#x2F;线程&#x2F;协程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p>
<p>进程一般由程序、数据集合和进程控制块三部分组成。</p>
<ul>
<li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li>
<li>数据集合是程序在执行时所需要的数据和工作区；</li>
<li>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li>
</ul>
<p>进程具有的特征：</p>
<ul>
<li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li>
<li>并发性：任何进程都可以同其他进程一起并发执行；</li>
<li>独立性：进程是系统进行资源分配和调度的一个独立单位；</li>
<li>结构性：进程由程序、数据和进程控制块三部分组成。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p>
<p>同一进程间的线程究竟共享哪些资源呢，而又各自独享哪些资源呢？共享的资源有</p>
<ul>
<li>堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）</li>
<li>全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的</li>
<li>静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的</li>
<li>文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。</li>
</ul>
<p>独享的资源有</p>
<ul>
<li>栈。栈是独享的</li>
<li>寄存器。这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC</li>
</ul>
<p>线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。进程拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括：</p>
<ul>
<li>线程ID。每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。</li>
<li>寄存器组的值。由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。</li>
<li>线程的堆栈。堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。</li>
<li>错误返回码。由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。</li>
<li>线程的信号屏蔽码。由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。</li>
<li>线程的优先级。由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的 优先级。</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p>协程的特点</p>
<ul>
<li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</li>
<li>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</li>
<li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li>
<li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li>
</ul>
<p>协程的原理</p>
<p>当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由<code>coroutine</code>负责调度的线程称为<code>Fiber</code>。比如Golang里的 go关键字其实就是负责开启一个<code>Fiber</code>，让<code>func</code>逻辑跑在上面。</p>
<p>由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。<br>因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。</p>
<p>协程和线程的比较</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th align="center">线程</th>
<th align="center">协程</th>
</tr>
</thead>
<tbody><tr>
<td>占用资源</td>
<td align="center">初始单位为1MB,固定不可变</td>
<td align="center">初始一般为 2KB，可随需要而增大</td>
</tr>
<tr>
<td>调度所属</td>
<td align="center">由 OS 的内核完成</td>
<td align="center">由用户完成</td>
</tr>
<tr>
<td>切换开销</td>
<td align="center">涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP…等寄存器的刷新等</td>
<td align="center">只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</td>
</tr>
<tr>
<td>性能问题</td>
<td align="center">资源占用太高，频繁创建销毁会带来严重的性能问题</td>
<td align="center">资源占用小,不会带来严重的性能问题</td>
</tr>
<tr>
<td>数据同步</td>
<td align="center">需要用锁等机制确保数据的一直性和可见性</td>
<td align="center">不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</td>
</tr>
</tbody></table>
<h2 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;child: x = &quot;</span> &lt;&lt; ++x &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;parent: x = &quot;</span> &lt;&lt; --x &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><table>
<thead>
<tr>
<th align="center">线程调用</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pthead_create</td>
<td align="center">创建一个线程</td>
</tr>
<tr>
<td align="center">pthead_exit</td>
<td align="center">结束调用的线程</td>
</tr>
<tr>
<td align="center">pthead_join</td>
<td align="center">等待一个特定线程退出</td>
</tr>
<tr>
<td align="center">pthead_yield</td>
<td align="center">释放CPU来运行另外一个线程</td>
</tr>
<tr>
<td align="center">pthead_attr_init</td>
<td align="center">创建并初始化一个线程的属性结构</td>
</tr>
<tr>
<td align="center">pthead_attr_destroy</td>
<td align="center">删除一个线程的属性结构</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_OF_THREAD 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">print_hello_world</span><span class="params">(<span class="type">void</span> *tid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello world. Greetings from thread &quot;</span> &lt;&lt; (<span class="type">long</span>)tid &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">pthread_t</span> threads[NUMBER_OF_THREAD];</span><br><span class="line">	<span class="type">long</span> status, i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; NUMBER_OF_THREAD;i++)&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Main here.Creating thread &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">		status = <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">NULL</span>, print_hello_world, (<span class="type">void</span> *)i);</span><br><span class="line">		<span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot; Oops. pthread_create returned error code &quot;</span> &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程间通信(IPC, Inter-Process Communication)指的是两个或多进程之间说话。<br>进程之间的说话不像我们人与人之间面对面说话只要通过空气介质把声音传过去就可以听见, 它更像我们上课的时候传纸条一样需要把想说的信息按照某种方式(字节流或者消息体)放到一个约定好的地方(内核缓冲区或者内存)然后通过某个中间人(内核)或者对方直接自己去拿。</p>
<p>IPC技术主要有四种:</p>
<ol>
<li>消息传递: 管道、FIFO、消息队列</li>
<li>同步: 互斥锁、条件变量、读写锁、文件锁、记录锁、信号量</li>
<li>共享内存: 匿名共享内存、有名共享内存</li>
<li>过程调用: 门、RPC</li>
</ol>
<h3 id="IPC对象"><a href="#IPC对象" class="headerlink" title="IPC对象"></a>IPC对象</h3><p>IPC对象有两种 Posix IPC 和 System V IPC, 他们的区别主要涉及到消息队列、共享内存和信号量</p>
<h4 id="Posix-IPC"><a href="#Posix-IPC" class="headerlink" title="Posix IPC"></a>Posix IPC</h4><p>Posix IPC指的是: Posix消息队列、Posix信号量和Posix共享内存的合称, 这三种类型的Posix IPC都使用Posix IPC名称进行标识, 比如它们调用对应的open函数去打开IPC创建和打开IPC对象的时候会传入这个名字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">sem_t</span> <span class="title">sem_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里不具体讨论这些函数, 只说一下这里的oflag几种常见情况:</p>
<ul>
<li>无特殊标志: 如果对象不存在返回ENOENT错误, 如果对象存在则引用存在的IPC对象</li>
<li>O_CREATE: 如果对象不存在则创建新的IPC对象, 如果对象存在则引用存在的IPC对象</li>
<li>O_CREATE | O_EXCL: 如果对象不存在则创建新的IPC对象, 如果对象存在则返回错误EEXIST</li>
</ul>
<p>它们的关系如下图</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/PosixIPC.svg"
                      width="400"
                >

<h4 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h4><p>System V IPC指的是: System V消息队列、System V信号量和System V共享内存的合称, 与Posix IPC对象不同的是System V IPC使用key_t值作为IPC对象的名字。<br>头文件sys&#x2F;types.h中将key_t定义为一个整数, 它通常是一个至少32位的整数, 这些整数值通常是由ftok函数赋予</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> id)</span></span>;</span><br><span class="line"><span class="comment">//  把 pathname 导出的信息与 id 的低序 8 位组合成一个 IPC key</span></span><br></pre></td></tr></table></figure>

<p>ftok的典型实现是调用stat函数然后组合stat.std_dev、stat.std_ino和id的低8位:</p>
<ol>
<li>stat.std_dev: pathname所在的文件系统的信息</li>
<li>stat.std_ino: 该文件在本文件系统内的索引结点</li>
<li>id的低序8位</li>
</ol>
<p>在System V IPC中创建或打开IPC对象的方式和函数和Posix IPC不一样, 在通过getxxx函数创建或者打开IPC对象的时候可以指定key位IPC_PRIVATE来保证创建一个新的、唯一的IPC对象, 创建成功会返回一个identifier整数描述符来标识这个IPC对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> oflag)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> oflag)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> oflag)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>消息传递通常需要总共四次复制, 而且这四次复制都是在内核和某个进程之间进行的开销很大。<br>消息传递的方式有管道、FIFO、消息队列<br><img  
                     lazyload
                     alt="image"
                     data-src="./img/SystemV.svg"
                      width="400"
                ></p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是一种平时经常会用到的IPC方式, 它的原理就是父进程在内核缓冲区创建一个伪文件并给这个文件指定一个读描述符和一个写描述符,当调用fork创建了子进程的时候,子进程会拷贝这两个描述符,然后父进程关闭读描述符,子进程关闭写描述符就可以实现父进程往管道里写东西,子进程往管道里取东西,他是一种先进先出的队列结构。<br><img  
                     lazyload
                     alt="image"
                     data-src="./img/pipe.svg"
                      width="400"
                ><br>管道的创建可以通过unistd.h头文件里的pipe函数实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - fd[2]: 两个文件描述符 fd[0]--读, fd[1]--写</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 成功返回 0</span></span><br><span class="line"><span class="comment">        - 出错返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在平时的工作中我们经常会用到管道, 比如下面的命令执行过程就是:shell创建一个子进程执行ps命令, ps所在进程创建一个管道然后fork一个子进程执行grep命令, ps所在进程就是通过管道将输出结果作为输入通过管道传给grep命令所在进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep 80</span><br></pre></td></tr></table></figure>

<p>总结一下管道的特点:</p>
<ol>
<li>半双工通信, 只能单向通信, 不过可以通过创建两个管道实现双向通信</li>
<li>管道位于内核缓冲区, 没有路径名, 只能在具有亲缘关系的进程之间使用</li>
<li>管道数据采用后进后出的队列进行传输, 传输的是字节流没有消息边界</li>
<li>管道是进程持续的, 当一个管道最后一次关闭, 仍在管道上的数据将被丢失</li>
</ol>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>为了解决管道只能在亲缘进程之间传递的问题, FIFO(有名管道)使用了一个关联管道的路径名来实现非亲缘进程之间的通信, 它的原理就是进程A把数据写到一个FIFO文件里然后进程B到这个文件里去拿数据</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="./img/fifo.svg"
                      width="400"
                >FIFO的创建通过mkfifo函数实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        pathname: 路径名</span></span><br><span class="line"><span class="comment">        mode: 隐含指定了 O_CREATE | O_EXCL, 也就是要么创建一个新的FIFO, 要么返回 EEXIST 错误</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 成功返回 0</span></span><br><span class="line"><span class="comment">        - 失败返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我么可以做一个小实验来直观的感受一下FIFO, 打开终端输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfifo fifo.test                # 创建一个名为 fifo.test 的有名管道</span><br><span class="line">echo &quot;Hello FIFO&quot; &gt;&gt; fifo.test  # 往管道里写 Hello FIFO</span><br></pre></td></tr></table></figure>

<p>另外再打开一个终端输入如下命令会显示我们刚才输入的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat fifo.test</span><br></pre></td></tr></table></figure>

<p>总结一下有名管道FIFO的特点:</p>
<ol>
<li>和管道一样是半双工通信, 也可以通过两个管道去实现双向通信</li>
<li>管道位于内核缓冲区, 有关联的路径名可以实现非亲缘进程之间的通信</li>
<li>和管道一样, 数据采用后进后出的队列进行传输, 传输的是字节流没有消息边界</li>
<li>FIFO是进程持续的, 当一个FIFO最后一次关闭, 仍在FIFO上的数据将被丢失</li>
</ol>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>管道是一种简单方便的通信方式, 但是它们存在一个问题: 没有消息边界, 没有消息类型。<br>消息队列是一个驻留在内核的消息链表, 有足够写权限的线&#x2F;进程可以往队列中放置消息, 有足够读权限的线&#x2F;进程可以从队列中取走消息。<br>在某个进程往一个队列写入消息之前并不需要另外某个进程在该队列上等待消息的到达, 而对管道来说除非读出者已存在, 否则先有写入者是没有意义的。<br><img  
                     lazyload
                     alt="image"
                     data-src="./img/mq.svg"
                      width="400"
                ></p>
<p>消息队列的相关函数如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Posix IPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode, strct mq_attr *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_close</span><span class="params">(<span class="type">mqd_t</span> mqdes)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *attr, <span class="keyword">struct</span> mq_attr *oattr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_send</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> prio)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_receive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> *priop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mq_notify</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="keyword">struct</span> sigevent *notification)</span></span>;</span><br><span class="line"><span class="comment">//  System V IPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key,  <span class="type">int</span> oflag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid,  <span class="type">const</span> <span class="type">void</span> *ptr,  <span class="type">size_t</span> length,  <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid,  <span class="type">void</span>* ptr,  <span class="type">size_t</span> length,  <span class="type">long</span> type,  <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid,  in cmd,  <span class="keyword">struct</span> msqid_ds* buff)</span></span>;</span><br></pre></td></tr></table></figure>

<p>总结一下消息队列的特点:</p>
<ol>
<li>消息队列采用的是链表的数据结构, 传输的是带有类型的消息体</li>
<li>消息队列是内核持续的</li>
</ol>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存, 顾名思义就是允许两个不相关的进程访问同一个逻辑内存, 由于数据存放在内存不用穿过内核所以共享内存是速度最快的IPC方式。<br>不同进程之间共享的内存通常为同一段物理内存, 进程可以将同一段物理内存映射到他们自己的地址空间中,所有的进程都可以访问共享内存中的地址, 如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/sharemem.svg"
                      width="400"
                >

<p>相比较消息传递的四次复制, 共享内存只有两次复制: 一次从输入文件到共享内存区, 另一次从共享内存区复制到输出文件。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/共享内存.svg"
                      width="400"
                >

<p>我们可以通过命令<code>ipcs -m</code>查看系统的共享存储区, 也可以使用<code>ipcrm -m [shmid]</code>删除对应的共享存储区</p>
<p>共享内存的相关函数如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Posix IPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function">coid *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(coid *addr, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br><span class="line"><span class="comment">//  System V IPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> oflag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buff)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取，所以我们通常需要用其他的机制来同步对共享内存的访问，例如信号量</p>
</blockquote>
<h3 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h3><h4 id="门"><a href="#门" class="headerlink" title="门"></a>门</h4><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>进程状态：</p>
<ul>
<li>就绪态</li>
<li>运行态</li>
<li>阻塞态</li>
</ul>
<p><a class="link"   href="https://www.cnblogs.com/Jack-Blog/p/12038716.html" >https://www.cnblogs.com/Jack-Blog/p/12038716.html<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁条件：</p>
<ul>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复<ol>
<li>每种类型一个资源的死锁检测</li>
<li>每种类型多个资源的死锁检测</li>
<li>死锁恢复<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
</li>
</ol>
</li>
<li>死锁预防：在程序运行之前预防发生死锁。<ul>
<li>破坏互斥条件。例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</li>
<li>破坏占有和等待条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</li>
<li>破坏不可抢占条件</li>
<li>破坏环路等待：给资源统一编号，进程只能按编号顺序来请求资源。</li>
</ul>
</li>
<li>死锁避免</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之数据结构与算法</title>
    <url>/2023/03/07/C++%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="五-C-之数据结构"><a href="#五-C-之数据结构" class="headerlink" title="[五]C++之数据结构"></a>[五]C++之数据结构</h1><p>数据结构的本质就是数据组织的形式，它服务于我们的需求，依赖于数据之间的关系：</p>
<ul>
<li>一对一：线性表组织</li>
<li>一对多：树组织</li>
<li>多对多：图组织</li>
</ul>
<p>数据在内存层面的具体实现本质上就两种：</p>
<ul>
<li>顺序存储：数据在一段连续的内存上顺序存储，特点是支持快速的随机访问，查找效率比较高</li>
<li>链式存储：数据分散的存储通过指针关联，特点是插入和删除效率比较高</li>
</ul>
<p>无论数据结构多么复杂，它所暴露出来的操作无非以下三种：</p>
<ul>
<li>初始化</li>
<li>增 ｜ 删 ｜ 改 ｜ 查中的一个或者多个，增删改查的方式不同决定了数据结构的特性，比如<ul>
<li>栈：后进(增)先出(查&#x2F;删)</li>
<li>队列：先进(增)先出(查&#x2F;删)</li>
</ul>
</li>
<li>其他操作，本质上都是为了实现增删改查后能保持数据结构的特性不变，比如<ul>
<li>树的自旋</li>
<li>堆的重新排序</li>
</ul>
</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>按照数据具体实现的方式，线性表主要分两大类：顺序表、链表。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>由于顺序表是在一段内存上顺序的存储数据，所以需要提前申请一定大小的物理空间。为了方便顺序表的使用，顺序表除了需要存储数据往往还需要实时记录：(1)容量(capacity，物理空间的大小)；(2)大小(size，已经使用的内存大小)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Table</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//	初始化</span></span><br><span class="line">  <span class="built_in">Table</span>(<span class="type">int</span> cap = <span class="number">1</span>) : <span class="built_in">c</span>(cap) &#123;</span><br><span class="line">    nums = (T*)<span class="built_in">malloc</span>(c);</span><br><span class="line">    <span class="keyword">if</span>(!nums)</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Init failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//	增/改</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(T num, <span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= c)&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Index out of memory, please set index &lt; &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Please set index &gt;= 0.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nums[index] = num;</span><br><span class="line">      s++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//	删</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deleteNumByIndex</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Sorry, no num can be deleted.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(index &gt;= s)&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Index out of boder, please set index &lt; &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Please set index &gt;= 0.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; (s - <span class="number">1</span>);i++)&#123;</span><br><span class="line">        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      s--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//	查</span></span><br><span class="line">  T <span class="keyword">operator</span>[](<span class="type">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Sorry, no nums &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= s)&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Please set: 0 &lt; index &lt; &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Table</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums)</span><br><span class="line">      <span class="built_in">free</span>(nums);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* nums;</span><br><span class="line">  <span class="type">int</span> c;		<span class="comment">//	容量</span></span><br><span class="line">  <span class="type">int</span> s = <span class="number">0</span>;<span class="comment">//	长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Table&lt;<span class="type">int</span>&gt; table = <span class="built_in">Table</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是顺序表的简单实现，实际按照顺序表能否动态的增加容量也可以分为定长顺序存储和动态顺序存储，动态存储需要考虑扩容策略的问题，一般都是容量不足的时候会扩大两倍的容量来使得摊销成本最低。</p>
<p>####链表</p>
<p>链表与顺序表不同，它是使用链式方式来实现线性表。要想实现链式的存储，一般需要一个节点node来存放数据以及一个指向下一个节点的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  初始化表实现, 可以方便在结点前面添加新结点</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> num, Node* ptr = <span class="number">0</span>) : <span class="built_in">val</span>(num), <span class="built_in">next</span>(ptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//	初始化</span></span><br><span class="line">    <span class="built_in">IntList</span>() &#123;</span><br><span class="line">        head = tail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">IntList</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(Node* ptr; !<span class="built_in">isEmpty</span>(); ) &#123;</span><br><span class="line">            ptr = head -&gt; next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            head = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//	增</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(num, head);</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="number">0</span>)</span><br><span class="line">            tail = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToTail</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail != <span class="number">0</span>) &#123;</span><br><span class="line">            tail -&gt; next = <span class="keyword">new</span> <span class="built_in">Node</span>(num);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> head = tail = <span class="keyword">new</span> <span class="built_in">Node</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//	删</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteFromHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = head-&gt;val;</span><br><span class="line">        Node* tmp = head;</span><br><span class="line">        <span class="keyword">if</span>(head == tail) &#123;</span><br><span class="line">            head = tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteFromTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = tail-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(head == tail) &#123;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            head = tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* tmp;</span><br><span class="line">            <span class="keyword">for</span>(tmp = head; tmp -&gt; next != tail; tmp = tmp -&gt; next);</span><br><span class="line">            <span class="keyword">delete</span> tail;</span><br><span class="line">            tail = tmp;</span><br><span class="line">            tail -&gt; next = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == tail &amp;&amp; head-&gt;val == num) &#123;</span><br><span class="line">                <span class="keyword">delete</span> head;</span><br><span class="line">                head = tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (head-&gt;val == num) &#123;</span><br><span class="line">                Node* tmp = head;</span><br><span class="line">                head = head -&gt; next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node *pre;</span><br><span class="line">                <span class="keyword">for</span>(pre = head; pre -&gt; next != <span class="number">0</span> &amp;&amp; (pre -&gt; next -&gt; val) != num; pre = pre -&gt; next);</span><br><span class="line">                <span class="keyword">if</span> (pre -&gt; next != <span class="number">0</span>) &#123;</span><br><span class="line">                    pre-&gt;next = pre -&gt; next -&gt; next;</span><br><span class="line">                    <span class="keyword">if</span>(pre -&gt; next == tail) &#123;</span><br><span class="line">                        tail = pre;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">delete</span> pre -&gt; next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//	查</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInList</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        Node *tmp;</span><br><span class="line">        <span class="keyword">for</span>(tmp = head; tmp != <span class="number">0</span> &amp;&amp; tmp-&gt;val != num; tmp = tmp-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> tmp != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *head, *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IntList lt = <span class="built_in">IntList</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是链式存储简单的实现线性表，这里的链表是单向的，然而链表也可以是双向的、循环的，但其本质都是通过指针将不同的节点关联起来</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><p>上面我们了解到可以通过顺序存储和链式存储的方式去实现一个线性表，我们只要修改线性表的增删改查方式就可以构造不同特性的数据结构。栈和队列就是线性表的一种，也就是说我们同样可以用顺序存储和链式存储的方式去构建栈和队列，前提是了解他们的特性</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">特点</th>
<th align="center">算法应用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">栈</td>
<td align="center">后进先出</td>
<td align="center">括号匹配、运算、结合回溯算法实现深度遍历搜索、前序遍历等</td>
</tr>
<tr>
<td align="center">队列</td>
<td align="center">先进先出</td>
<td align="center">树的层次遍历、广度优先搜索等</td>
</tr>
</tbody></table>
<p>栈和队列是两个比较典型的数据结构，实际需求中会根据需要对他们做一些变种，比如单调栈、优先队列等。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串可以理解为字符线性表，所以它也可以通过顺序存储和链式存储的方式去实现。字符串常常被应用于模式匹配</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的存储结构特点是描述数据之间一对多的关系，树也可以通过顺序存储和链式存储两种形式来实现，不过大部分都是通过链式存储，顺序存储的话通常是通过位置索引。我们接下来说到的二叉树或者多叉树都是指有序树，也就是说数据都是按照顺序存储的，比如任一结点都大于它的左子树且小于或等于它的右子树所有的值</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><table>
<thead>
<tr>
<th align="center">树</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">二叉树</td>
<td align="center">每个结点最多有两个结点点</td>
</tr>
<tr>
<td align="center">完全二叉树</td>
<td align="center">一个高度为h的树,除最后一层以外都是满的并且剩余结点尽可能保存在最左的位置</td>
</tr>
<tr>
<td align="center">满二叉树</td>
<td align="center">任一结点的子结点数要么是0要么是2</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">树中任一结点值都是其子树的最大&#x2F;小值</td>
</tr>
</tbody></table>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/BinaryTree.png"
                      width="400"
                >

<p>二叉树的实现有两种形式：</p>
<ul>
<li>链式存储：通过给节点设置两个指针去指向子节点</li>
<li>顺序存储：按照层次遍历的方式将数据顺序存储在数组里，对于度小于2的的非叶子节点需要进行填充。任意位置k的子节点位置为2k+1和2k+2</li>
</ul>
<p>对于二叉树的增删改查会涉及到的操作有：</p>
<ul>
<li>增&#x2F;改：对于堆结构来说会涉及到重新构造</li>
<li>删：删除叶子结点，删除有一个子节点的节点，删除两个子节点的节点：左子树的最大值或者右子树的最小值代替删除的节点。对于堆结构来说删除的是根元素，会涉及到重新构造</li>
<li>查：涉及到树的遍历，也就是将树结构转换成线性表的过程，树的遍历有四种，其实现的本质也无外乎两种<ul>
<li>深度优先搜索：可使用栈结构或者递归算法实现<ul>
<li>先序遍历：根-&gt;左-&gt;右</li>
<li>中序遍历：左-&gt;根-&gt;右</li>
<li>后序遍历：左-&gt;右-&gt;根</li>
</ul>
</li>
<li>广度优先搜索：可使用队列结构实现<ul>
<li>层次遍历：逐层遍历</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>多叉树指的是结点的子树可以大于二，其他操作和二叉树本质上一样</p>
</blockquote>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>普通的二叉树最坏情况下会形成线性表的结构，这样就导致普通二叉树的搜索效率降低，平衡树就是为了解决这个问题而提出的一种树存储结构。平衡树指的是任意结点的左子树和右子树的深度最多相差1的树，这样在</p>
<table>
<thead>
<tr>
<th align="center">树</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆</td>
<td align="center">树中任一结点值都是其子树的最大&#x2F;小值</td>
</tr>
<tr>
<td align="center">AVL树</td>
<td align="center">二叉平衡搜索树</td>
</tr>
<tr>
<td align="center">B树</td>
<td align="center">多叉平衡搜索树</td>
</tr>
<tr>
<td align="center">B+树</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">红黑树</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>平衡树为了保持自身的特性，在增删改查的时候相对于普通树会多一些操作</p>
<ul>
<li>平衡操作<ul>
<li>中序遍历后二分法</li>
<li>旋转(dsw)：通过某一方向一直旋转变成主链，然后从根开始遍历每隔两个节点进行反方向旋转<ul>
<li>右旋(子节点代替父节点，子节点原先的右子树变成父节点的左子)</li>
<li>左旋(子节点代替父节点，子节点原先的左子树变成父节点的右子树)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图描述的是数据之间多对多的关系，图存储结构涉及到的概念有</p>
<ul>
<li>边</li>
<li>权</li>
<li>有向&#x2F;无向图</li>
<li>网：带权的图</li>
<li>连通图</li>
</ul>
<p>图的实现按照顺序存储和链式存储可以分为：</p>
<ul>
<li>顺序存储<ul>
<li>数组：需要使用两个数组，一个数组存放图中顶点本身的数据（一维数组），另外一个数组用于存储各顶点之间的关系（二维数组）</li>
</ul>
</li>
<li>链式存储<ul>
<li>邻接表：给图中的各个顶点独自建立一个链表，用节点存储该顶点，用链表中其他节点存储各自的临界点</li>
</ul>
</li>
</ul>
<p>图存储结构涉及到的操作有：</p>
<ul>
<li>增</li>
<li>删</li>
<li>改</li>
<li>查：查的过程就是将树存储结构转换为线性表的过程，本质和树结构一样<ul>
<li>深度优先搜索</li>
<li>广度优先搜索</li>
</ul>
</li>
</ul>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><h4 id="路径搜索"><a href="#路径搜索" class="headerlink" title="路径搜索"></a>路径搜索</h4><p>狄杰斯拉特</p>
<p>floyd</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>原理</p>
<ul>
<li>原问题的结构与子问题的结构相同,只是规模不同</li>
<li>父问题的输入依赖于子问题的输出(存在递推公式)</li>
<li>子问题有基本情况(最小规模的输出存在)</li>
</ul>
<p>设计步骤</p>
<ul>
<li>对于基本情况的测试</li>
<li>递归情况</li>
</ul>
<p>特点</p>
<ul>
<li>简化问题,但是空间复杂度较高</li>
<li>可能存在重复计算导致时间复杂度较高需要优化</li>
</ul>
<h3 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h3><p>原理</p>
<ul>
<li>原问题的结构与子问题的结构相同,只是规模不同</li>
<li>子问题直接相互独立</li>
<li>子问题有基本情况</li>
</ul>
<p>设计步骤</p>
<ul>
<li>分解 — 将原题划分为一些子问题</li>
<li>解决 — 递归的求解子问题<ul>
<li>代入法 — 猜测解的形式,用数学归纳法求出常数并证明其正确性</li>
<li>递归树法 — 用递归树生成好的猜测</li>
<li>主问题法 —</li>
</ul>
</li>
<li>合并 — 将子问题的解组合成原问题的解</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>原理</p>
<ul>
<li>最优子结构 — 问题的最优解由相关子问题的最优解组合而成,这些子问题可以独立求解</li>
<li>子问题重叠 — 不同的子问题有公共的子子问题,对每个子子问题只求解一次并存于表格中</li>
<li>无权最短路径 — 对于有向图的的两个定点u和v,找到从u到v变数最少的路径</li>
</ul>
<p>设计步骤</p>
<ul>
<li>刻画一个最优解的结构特征</li>
<li>递归的定义最优解的值</li>
<li>计算最优解的值<ul>
<li>带备忘录的自顶向下(从原问题-&gt;子问题)</li>
<li>自底向上(从子问题-&gt;原问题)</li>
</ul>
</li>
<li>利用计算出的信息构造一个最优解</li>
</ul>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>原理</p>
<ul>
<li>用递归完成的穷举法</li>
<li>一种通用的解题方法</li>
<li>利用深度优先搜索探索解空间树</li>
</ul>
<p>设计步骤</p>
<ul>
<li>描述解的形式定义一个解空间</li>
<li>根据解空间构造状态空间树</li>
<li>构造约束函数杀死节点(视情况而定)</li>
</ul>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>原理</p>
<ul>
<li>每一步都作出当时看起来最佳的选择(局部最优)</li>
<li>并不一定保证得到最优解,但很多情况能得到最优解</li>
<li>启发式策略</li>
</ul>
<p>设计步骤</p>
<ul>
<li>建立数学模型来描述问题</li>
<li>把求解的问题分解成若干个子问题</li>
<li>对每一个子问题求解,得出子问题的局部最优解</li>
<li>把子问题的局部最优解合并成原问题的一个最优解</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之网络编程</title>
    <url>/2023/03/07/C++%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-网络编程"><a href="#C-网络编程" class="headerlink" title="C++网络编程"></a>C++网络编程</h1><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p>OSI七层模型</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/TCP_IP.png"
                     
                >

<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>方法</p>
<ul>
<li>GET — 获取资源</li>
<li>HEAD — 获取报文首部。和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。</li>
<li>POST — 传输实体主体。POST 主要用来传输数据，而 GET 主要用来获取资源</li>
<li>PUT — 上传文件。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</li>
<li>PATCH — 对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改</li>
<li>DELETE — 删除文件。与 PUT 功能相反，并且同样不带验证机制</li>
<li>OPTIONS — 查询支持的方法<br>查询指定的 URL 能够支持的方法</li>
<li>CONNECT — 要求在与代理服务器通信时建立隧道。使用 SSL(Secure Sockets Layer，安全套接层)和 TLS(Transport Layer Security，传输层安全)协议把通信内容加密后经网络隧道传输</li>
<li>TRACE — 追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪</li>
</ul>
<p>返回码</p>
<ul>
<li>1XX 信息<ul>
<li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
</li>
<li>2XX 成功<ul>
<li>200 OK</li>
<li>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
</li>
<li>3XX 重定向<ul>
<li>301 Moved Permanently ：永久性重定向</li>
<li>302 Found ：临时性重定向</li>
<li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。<br>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
</li>
<li>4XX 客户端错误<ul>
<li>400 Bad Request ：请求报文中存在语法错误。</li>
<li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Forbidden ：请求被拒绝。</li>
<li>404 Not Found</li>
</ul>
</li>
<li>5XX 服务器错误<ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>
</li>
</ul>
<p>###TCP&#x2F;IP</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/TCPheader.png"
                      width="400"
                >

<img  
                     lazyload
                     alt="image"
                     data-src="./img/UDPheader.png"
                      width="400"
                >

<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><img  
                     lazyload
                     alt="image"
                     data-src="./img/TCP.svg"
                      width="600"
                >

<h3 id="服务端编程"><a href="#服务端编程" class="headerlink" title="服务端编程"></a>服务端编程</h3><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>为了执行网络I&#x2F;O, 一个进程必须做的第一件事情就是调用socket函数, 指定一个期望的通信协议类型来创建一个套接字描述符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - family(协议族)</span></span><br><span class="line"><span class="comment">            - AF_INET   : IPv4协议</span></span><br><span class="line"><span class="comment">            - AF_INET6  : IPv6协议</span></span><br><span class="line"><span class="comment">            - AF_LOCAL  : Unix域协议</span></span><br><span class="line"><span class="comment">            - AF_ROUTE  : 路由套接口</span></span><br><span class="line"><span class="comment">            - AF_KEY    : 密钥套接口</span></span><br><span class="line"><span class="comment">        - type(类型)</span></span><br><span class="line"><span class="comment">            - SOCK_STREAM   : 字节流套接口</span></span><br><span class="line"><span class="comment">            - SOCK_DGRAM    : 数据报套接口</span></span><br><span class="line"><span class="comment">            - SOCK_RAW      : 原始套接口</span></span><br><span class="line"><span class="comment">        - protocol: 除原始套接口外一般设置为 0 </span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - sockfd : 非负 int</span></span><br><span class="line"><span class="comment">        - -1 : 创建套接字失败</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里socket函数通过指定协议族、类型创建了一个int类型的套接字描述符相当于你告诉别人准备用哪国的语言和别人聊天。<br>在这一阶段有一种出错的可能就是创建套接字失败，这个时候socket函数会返回-1.</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>当你约定好了用哪种语言和方式进行聊天的时候，但是别人不知道上哪写信给你，所以你还需要告诉别人你在哪个小区(IP)的哪个房间编号(端口)，完成这一步动作需要分两步去做</p>
<ol>
<li>将你的具体地址写在一张纸上并翻译成邮寄员能看懂的形式</li>
<li>将翻译后的地址和你准备聊天的语言和方式绑定在一起交给邮寄员，写信给你的人只要把信寄到邮政局，邮寄员就可以根据你的地址把信交给你</li>
</ol>
<p>先说第一步，我们需要在纸上(sockaddr_in)写下自己的地址，然后通过字节排序函数(htons)把地址翻译一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>	servaddr;</span><br><span class="line">servaddr.sin_family      = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">servaddr.sin_port        = <span class="built_in">htons</span>(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  字节排序函数: 主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span></span>;<span class="comment">//  Host to Network Short</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span></span>;</span><br></pre></td></tr></table></figure>

<p>为什么要对地址进行字节排序呢？因为网络里传输的字节是按照大端模式进行排序的，而主机里通常是按照小端模式排序的，所以需要对地址和端口进行字节排序才不会被邮寄员搞错地址。</p>
<p>在这一步可能会有一个疑问，如果地址不填会怎么样呢？</p>
<ol>
<li>如果不指定IP的话，可以选择INADDR_ANY参数，调用bind函数的时候服务器内核会把客户所发SYN分组里的目的IP作为服务器的IP(真是有够聪明)</li>
<li>同样，如果不想指定某个端口，可以将端口设置为0，调用bind函数的时候内核会选择一个临时端口</li>
</ol>
<p>然后是第二步，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *servaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - sockfd:   需要绑定的套接字描述符</span></span><br><span class="line"><span class="comment">        - servaddr: 指向特定协议地址结构的指针</span></span><br><span class="line"><span class="comment">        - addrlen:  该地址结构的长度</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 0 : 成功</span></span><br><span class="line"><span class="comment">        - -1: 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在这一步有几种出错的可能:</p>
<ul>
<li>EADDRINUSE: Address already in use</li>
<li>SO_REUSEADDR</li>
<li>SO_REUSEPORT</li>
</ul>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>等把地址和协议都绑定好了，就在家里等着别人给你写信了，这一步需要调用listen函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - sockfd:   需要监听的套接字</span></span><br><span class="line"><span class="comment">        - backlog:  已连接和同步接收套接字个数的最大值, 不要定义为0, 一般设为 LISTENQ</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 0 : 成功</span></span><br><span class="line"><span class="comment">        - -1: 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这一步的成功标志着: 服务端进入了<strong>LISTEN</strong>状态, </p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><p>经过上一步的listen函数成功调用后，我们就在家里等着收信，服务端需要调用accept函数时刻观察着有没有请求到来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *cliaddr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - sockfd: 之前创建的监听套接字</span></span><br><span class="line"><span class="comment">        - cliaddr: 指向客户端套结构地址的指针</span></span><br><span class="line"><span class="comment">        - addrlen: 指向客户端套结构地址长度的指针</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 非负描述字: 一个已连接的套接字描述符 connfd</span></span><br><span class="line"><span class="comment">        - -1 : 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这个时候会出现以下几种情况:</p>
<ol>
<li>没有请求。accept调用阻塞等待客户端的请求，服务端还是处于<strong>LISTEN</strong>状态</li>
<li>收到客户端SYN请求分组。服务端返回给客户端ACK分组同时带上自己的SYN数据等待客户端返回的ACK分组，然后进入<strong>SYN_RCVD</strong>状态</li>
<li>服务端收到客户端返回的ACK分组。accept返回一个连接套接字，服务端进入<strong>ESTABLISHED</strong>.这个时候服务端处理请求(比如read)的函数会阻塞等待客户端的数据</li>
<li>服务端一直没有收到返回的ACK分组?</li>
<li>服务端收到了客户端其他的回复,比如RST，服务端会返回ECONNABORTED错误然后忽略它再次调用accept</li>
</ol>
<p>####close</p>
<p>服务端的关闭虽然只有一个close函数，但是过程还是比较复杂的。<br>首先客户端发送FIN分组给服务端请求关闭，服务端收到FIN分组，处理函数(比如read)返回，服务端被动关闭返回ACK分组给客户端进入<strong>CLOSE_WAIT</strong>状态；<br>然后服务端调用close函数向客户端发送FIN分组给客户端等待客户端的回复，服务端进入<strong>LAST_ACK</strong>状态；<br>最后服务端收到客户端的ACK分组后进入<strong>CLOSED</strong>状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params: sockfd -- 需要关闭的套接字描述符</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 0 -- 完成</span></span><br><span class="line"><span class="comment">        - -1 -- 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在服务端的关闭过程中可能会出现的情况有:</p>
<ol>
<li>服务端没有收到客户端的FIN分组</li>
<li>客户端一直没有收到服务端返回的ACK(服务端关机、崩溃等)</li>
<li>客户端一直没有收到服务端的FIN分组(服务端关机、崩溃等)</li>
<li>服务端一直没有收到客户端返回的ACK分组</li>
</ol>
<h3 id="客户端编程"><a href="#客户端编程" class="headerlink" title="客户端编程"></a>客户端编程</h3><h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h4><p>和服务端一样, 为了执行网络I&#x2F;O一个进程必须做的第一件事情就是调用socket函数, 指定一个期望的通信协议类型来创建一个套接字描述符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - family(协议族)</span></span><br><span class="line"><span class="comment">            - AF_INET   : IPv4协议</span></span><br><span class="line"><span class="comment">            - AF_INET6  : IPv6协议</span></span><br><span class="line"><span class="comment">            - AF_LOCAL  : Unix域协议</span></span><br><span class="line"><span class="comment">            - AF_ROUTE  : 路由套接口</span></span><br><span class="line"><span class="comment">            - AF_KEY    : 密钥套接口</span></span><br><span class="line"><span class="comment">        - type(类型)</span></span><br><span class="line"><span class="comment">            - SOCK_STREAM   : 字节流套接口</span></span><br><span class="line"><span class="comment">            - SOCK_DGRAM    : 数据报套接口</span></span><br><span class="line"><span class="comment">            - SOCK_RAW      : 原始套接口</span></span><br><span class="line"><span class="comment">        - protocol: 除原始套接口外一般设置为 0 </span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - sockfd : 非负 int</span></span><br><span class="line"><span class="comment">        - -1 : 创建套接字失败</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>和服务端不同的是，客户端不需要明确的去bind和listen，而是直接通过connect函数向指定的服务端发送连接请求。这里的sockaddr结构体类型和之前TCP服务端博客里bind函数使用的sockaddr一样，调用的时候都需要使用(SA *)进行转型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *servaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - sockfd: 之前socket函数调用创建的套接字描述符</span></span><br><span class="line"><span class="comment">        - servaddr: 指向特定协议地址结构的指针</span></span><br><span class="line"><span class="comment">        - addrlen: 该地址结构的长度</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">    		- 成功：0</span></span><br><span class="line"><span class="comment">    		- 错误： -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>当客户端调用connect函数后会发送SYN分组给目标服务端然后进入<strong>SYN_SENT</strong>状态等待服务端的ACK确认分组。这个时候会出现几种情况:</p>
<ol>
<li>客户端一直没有收到ACK回复。客户端会6s、24s后重复再发一次，总共等75s后还是没有响应就会返回错误码ETIMEDOUT</li>
<li>客户端收到服务端的ACK分组回复后进入<strong>EXTABLISHED</strong>状态</li>
</ol>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>客户端的close函数和服务端一样，但是通常都是客户端先调用close函数主动关闭然后发送FIN分组非服务端，同时进入<strong>FIN_WAIT_1</strong>状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params: sockfd -- 需要关闭的套接字描述符</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 0 -- 完成</span></span><br><span class="line"><span class="comment">        - -1 -- 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在客户端的关闭过程中可能会出现的情况有:</p>
<ol>
<li>客户端调用close函数进入<strong>FIN_WAIT_1</strong>状态，客户端一直没有收到服务端的ACK分组响应。</li>
<li>客户端收到ACK响应后进入<strong>FIN_WAIT_2</strong>状态，但是迟迟没有收到服务端发来的FIN分组。</li>
<li>客户端收到服务端的FIN分组。返回ACK进行响应然后进入<strong>TIME_WAIT</strong>状态</li>
</ol>
<p>客户端之所以要有以一个<strong>TIME_WAIT</strong>状态有两个原因:</p>
<ol>
<li>让之前迷路的分组在网络中消失。假如某个套接字对断开连接后因为新的请求再次连接，服务端在这个时候如果收到了上一个连接中在网络中迷失就不知道怎么处理了，设置<strong>TIME_WAIT</strong>状态就是让这些可能因为路由故障而迷路的分组在网络中消失</li>
<li>实现TCP全双工连接的可靠终止。客户端收到服务端的FIN分组并响应ACK分组，如果这个时候因为某种原因服务端没有收到这个ACK分组则会再次发送FIN分组，客户端就可以在<strong>TIME_WAIT</strong>状态下处理这个FIN分组</li>
</ol>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>相对于TCP套接字，UDP套接字要简单一些。UDP是一种不可靠的传输协议，不像TCP需要靠ACK机制来确认对方有没有收到自己传来的数据</p>
<h4 id="socket和bind"><a href="#socket和bind" class="headerlink" title="socket和bind"></a>socket和bind</h4><p>对于UDP客户端来说，它只要调用socket函数创建一个套接字就可以向服务端发送数据。<br>而对于服务端来说也只是在socket调用的基础上再调用bind函数绑定地址和端口，这两个函数和TCP套接字没有差别</p>
<h4 id="sendto和recvfrom"><a href="#sendto和recvfrom" class="headerlink" title="sendto和recvfrom"></a>sendto和recvfrom</h4><p>当客户端创建好套接字后就可以通过sendto调用去发送请求，同时调用recvfrom去处理服务端的响应。<br>同样，UDP的服务端通过recvfeom去接收客户端的请求然后通过sendto函数去响应客户端，一气呵成</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>recvfrom和sendto类似于标准的write和read函数，只不过它有三个附加参数</p>
<ol>
<li>flags: 一般设为0</li>
<li>to&#x2F;from: 含有数据将发生的协议地址的套接口地址</li>
<li>最后一个参数: recvfrom传的是指针，sendto传的是数值</li>
</ol>
<h4 id="close-1"><a href="#close-1" class="headerlink" title="close"></a>close</h4><p>通常客户端完成任务之后会主动调用close函数直接关闭，不需要像TCP那样使用四次挥手和TIME_WAIT机制</p>
<h2 id="TCP和UDP比较"><a href="#TCP和UDP比较" class="headerlink" title="TCP和UDP比较"></a>TCP和UDP比较</h2><h3 id="TCP到底可靠在哪"><a href="#TCP到底可靠在哪" class="headerlink" title="TCP到底可靠在哪"></a>TCP到底可靠在哪</h3><h4 id="ACK机制"><a href="#ACK机制" class="headerlink" title="ACK机制"></a>ACK机制</h4><p>由于通信过程的不可靠性，传输的数据不可避免的会出现丢失、延迟、错误、重复等各种状况，TCP协议为解决这些问题设计了一系列机制。<br>这个机制的核心，就是发送方向接收方发送数据后，接收方要向发送方发送ACK（回执）。<br>如果发送方没接收到正确的ACK，就会重新发送数据直到接收到ACK为止。比如：发送方发送的数据序号是seq，那么接收方会发送seq + 1作为ACK，这样发送方就知道接下来要发送序号为seq + 1的数据给接收方了。</p>
<p>这个机制在面对几种出错的情况会有对应的处理:</p>
<ol>
<li>数据丢失或延迟。发送方发送数据seq时会起一个定时器，如果在指定时间内没有接收到ACK seq + 1，就把数据seq再发一次。</li>
<li>数据乱序。接收方上一个收到的正确数据是seq + 4，它返回seq + 5作为ACK。这时候它收到了seq + 7，因为顺序错了，所以接收方会再次返回seq + 5给发送方。</li>
<li>数据错误。每一个TCP数据都会带着数据的校验和。接收方收到数据seq + 3以后会先对校验和进行验证。如果结果不对，则发送ACK seq + 3，让发送方重新发送数据。</li>
<li>数据重复。接收方直接丢弃重复的数据即可。</li>
</ol>
<p>按照ACK机制，只要整个数据传输顺利结束，接收方就能收到完整有序的数据了。<br>但是，如果我们针对每一个数据包都发送ACK，就会有大量的网络资源消耗在ACK的发送上，这不太划算的。于是，TCP设计了延迟ACK的机制<br>这个机制其实很简单。客户端一次给服务器发送多个数据包，当服务器收到客户端的数据包时，不马上发送ACK，而是稍微等一小段时间。在这个过程中服务器可能能收到后续几个数据包，服务器就可以直接按照最后一个正确的数据发送ACK，减少发送ACK的总数。<br>当发送错误的时候，会发生：</p>
<ol>
<li>超时重传机制<br>发送方发送的报文中含有序列号，每当发送一个报文后，就启动一个计时器（RTO），该计时器的时间一般是有当前网络来决定的，一个RTT指的是当一个报文从发送到接收到对应的ACK标志的时间，RTO的决定一般是发送方尝试发送几个报文，然后取平均RTT时间来决定计时器的值。 当发送一个报文以后，发送方在计时范围以内，如果没有接收到相应的ACK确认报文，那么发送方就会重传该报文。</li>
<li>快速重传机制<br>该机制指的是，发送方一直发送报文，不会每发一次报文就都要等待到这个报文的ACK标志才发送下个报文。 当接收方发现接受的序列号不对的时候，发送连续的3个ACK标志，告诉发送方，这个报文在传输过程中出现了丢包。发送方如果接收到某个相同序列号的三个ACK报文，那么此时立马重发该报文，不用等待计时器的时间结束。</li>
</ol>
<h4 id="流量控制-滑动窗口"><a href="#流量控制-滑动窗口" class="headerlink" title="流量控制(滑动窗口)"></a>流量控制(滑动窗口)</h4><p>流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。<br>发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。此时发送方的报文分为四类， 第一类是已经发送并且得到接收方确认的报文，第二类是已经发送但是没有接收到确认的报文，第三类是发送方还没发送，但是滑动窗口还足够巨大，允许被发送的报文， 第四类是还没发送并且窗口已经被占满，不允许发送的报文。 一般来说，滑动窗口的最左端都是介于第一类跟第二类报文的分界线，最右端是第三类跟第四类报文的分界线。</p>
<p>滑动窗口的流量控制可以包括那么几个协议：</p>
<ol>
<li>停等协议。 滑动窗口的大小为1， 每个发送报文都要等到被确认以后，发送方才继续发送下一个报文。</li>
<li>后退n步协议。 该协议下，滑动窗口大于1，发送方可以一直发送报文，但是当接收到接收方发送的三个连续的同一序列号的ACK报文时，说明该序列号的报文是已经丢失的，那么此时重发该丢失报文以及该报文以后的报文（包括那些已经发送的）。</li>
<li>选择重传。在后退n步协议当中，如果某个报文丢失，那么将要重新发送这个丢失报文及以后的所有报文（包括已经发送的），选择重传协议不用做此要求，只要重新发送丢失的报文即可。</li>
</ol>
<p>滑动窗口协议有:</p>
<ol>
<li>停等协议，发送窗口&#x3D;1，接受窗口&#x3D;1；</li>
<li>退后N帧协议，发送&gt;1,接收&#x3D;1;</li>
<li>选择重传协议，发送&gt;1,接收&gt;1;</li>
</ol>
<p>设主机A向主机B发送数据。双方确定的窗口值是400.再设每一个报文段为100字节长，序号的初始值为seq&#x3D;1,图中的箭头上面大写ACK，表示首部中的却认为为ACK，小写ack表示确认字段的值。<br>接收方的主机B进行了三次流量控制。第一次把窗口设置为rwind&#x3D;300，第二次减小到rwnd&#x3D;100最后减到rwind&#x3D;0，即不允许发送方再发送过数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。<br>假如，B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd&#x3D;400的报文段，然而这个报文段在传送中丢失 了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。这样就死锁了。为了解决这种死锁状态，TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若计时器的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>首先要明白拥塞控制与流量控制有什么不同，流量控制考虑的是单纯的发送方与接收方，这两个在全部网络过程中的两个端点。而拥塞控制考虑的是整个网络，防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。可以想象一下，在流量控制当中，接收方跟发送方考虑的只是自己的报文有没有发送并且被接收的问题，假设现在网络阻塞，在超时重传机制当中，发送方没有发送后在计时器时间内没有接收到确认报文，就立马重新发送报文，这时候对已经拥塞的网络来说，无异于雪上加霜。同样实在拥塞的网络情况下，考虑下快速重传机制，同样是这个道理。所以，针对以上问题，TCP应该要有一个拥塞控制机制，不然，后果不堪设想。<br>在拥塞控制机制中，发送方维持一个叫做拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就增大一些，以便把更多的分组发送出去。但是只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络的分组数。</p>
<p>下面说明下几个符号说明：</p>
<ul>
<li>cwnd：拥塞窗口大小</li>
<li>ssthreshold: 拥塞阈值 （该阈值是对网络状况的一个预估，决定在拥塞窗口多大的时候采取怎样的策略，它的初始化一般是一个估计，一般都会给出）<br>现在可以看下这个拥塞控制机制包括哪几个策略</li>
</ul>
<ol>
<li>慢启动:此时一般是（记住是一般情况）cwnd&lt;ssthreshold，此时cwnd呈指数形式增长，1、2、4、8、16、32…这种增长趋势</li>
<li>拥塞避免:此时一般cwnd&gt;ssthreshold，此时cwnd呈线性增长，32、33、34、35…这种增长趋势</li>
<li>拥塞解决:此时一般是遇到了网络拥塞的状况，解决方法是拥塞阈值乘性减即ssthreshold&#x3D;cwnd&#x2F;2，cwnd&#x3D;1，或者ssthreshold&#x3D;cwnd&#x2F;2，cwnd&#x3D;ssthreshold，这两种情况在后面说明</li>
<li>快速恢复:一般是启用拥塞解决策略之后，根据不同的情况，进入慢启动或者拥塞避免阶段。</li>
</ol>
<p>假设ssthreshold&#x3D;8，首先肯定是慢启动阶段，cwnd增长，1、2、4、8，到8的时候，cwnd达到了ssthreshold的值，于是进入拥塞避免阶段，cwnd继续增长8、9、10，假设到10的时候，发生了网络拥塞，这时候拥塞分为两种情况：</p>
<ol>
<li>发送方接收到同一序列号的报文的连续三个ACK确认报文，说明出现了丢包，但是接收到接收方发送的丢包信号，说明网络情况还是相对较好的，于是此时发送方做出反应，将ssthreshold&#x3D;cwnd&#x2F;2&#x3D;5，cwnd&#x3D;ssthreshold&#x3D;5，然后进入拥塞避免阶段，cwnd继续以5、6、7…这种情况增长。</li>
<li>发送方接收到同一序列号的报文连续两个ACK确认报文，这时候，就说明网络拥塞情况就比较严重了，连接收方发送的丢包信号都不完整了，这个时候得采取更加严厉的措施了，于是ssthreshold&#x3D;cwnd&#x2F;2，cwnd&#x3D;1，然后重新进入慢启动过程。</li>
</ol>
<p>###TCP和UDP的区别</p>
<ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP提供可靠的服务，也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
</ol>
<h3 id="如何实现可靠UDP"><a href="#如何实现可靠UDP" class="headerlink" title="如何实现可靠UDP"></a>如何实现可靠UDP</h3><p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。<br>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。<br>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ol>
<li>添加seq&#x2F;ack机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要用于用户超时重传。</li>
<li>添加超时重传机制。</li>
</ol>
<p>详细说明：送端发送数据时，生成一个随机seq&#x3D;x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack&#x3D;x+1的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。如果超过一定时间还没收到ack，那么重传数据。<br>目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。</p>
<h2 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><h3 id="同步和异步-阻塞和非阻塞"><a href="#同步和异步-阻塞和非阻塞" class="headerlink" title="同步和异步?阻塞和非阻塞?"></a>同步和异步?阻塞和非阻塞?</h3><p>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：<br>    1）等待数据准备 (Waiting for the data to be ready)<br>    2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</p>
<p>同步和异步是相对于被调用方来说的。<br>阻塞和非阻塞是相对于调用方来说的。</p>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO指的是阻塞式IO, 以UDP套接字为例, 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。<br>对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。<br>而在用户进程这边，整个进程会被阻塞。<br>当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>所以，阻塞式IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。<br><img  
                     lazyload
                     alt="image"
                     data-src="./img/BIO.svg"
                      width="400"
                ></p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO指的是非阻塞式IO, 进程把一个套接字设置成非阻塞是在通知内核: 当所请求的IO操作非得把本进程置于休眠状态才能完成时, 不要把本进程置于休眠状态而是返回一个错误.<br>通俗的说就是进程系统调用获取数据时, 内核无论有没有数据都马上返回个东西给 进程<br>这种模式通过调用read、write的时候指定 O_NONBLOCK 参数。和“同步阻塞”模式的区别在于系统调用的时候它是以非阻塞的方式执行，无论是否有数据都会立即返回。<br>以read为例，如果成功读取到数据它返回读取到的字节数；如果此时没有数据则返回-1，同时设置errno为EAGAIN（或者EWOULDBLOCK，二者相同）。所以这种模式下我们一般会用一个“循环”不停的尝试读取数据，处理数据。<br>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。使用如下的函数可以将某句柄fd设为非阻塞状态<br><img  
                     lazyload
                     alt="image"
                     data-src="./img/NIO.svg"
                      width="400"
                ><br>上图这种循环调用recvfrom的方式称为轮询(polling)</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>I&#x2F;O复用可以阻塞在这两个系统调用中的某一个, 而不是阻塞在真正的IO系统调用上</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>我们阻塞于select调用等待数据报套接字变为可读。<br>当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到应用进程缓冲区。<br>由于使用select需要两个而不是单个系统调用使得IO复用稍有劣势</p>
<img class="..&#x2F;imgs&#x2F;svg&#x2F;IOMultiplexing.svg IO复用 IO复用模型 50">
<p>select每次要轮询，数据的到来阻塞和从内核到进程阻塞，每次都要将描述符集合在进程和内核空间之间切换，1024限制</p>
<p>select函数允许进程指示内核等待多个事件中的任何一个发生, 并在只有一个或多个事件发生或经历一段时间后才唤醒它</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 若有就绪描述符则为其数目</span></span><br><span class="line"><span class="comment">        - 超时返回 0</span></span><br><span class="line"><span class="comment">        - 出错返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>			maxfdp1, stdineof;</span><br><span class="line">	fd_set		rset;</span><br><span class="line">	<span class="type">char</span>		buf[MAXLINE];</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line"></span><br><span class="line">	stdineof = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">FD_ZERO</span>(&amp;rset);</span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		<span class="keyword">if</span> (stdineof == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">FD_SET</span>(<span class="built_in">fileno</span>(fp), &amp;rset);</span><br><span class="line">		<span class="built_in">FD_SET</span>(sockfd, &amp;rset);</span><br><span class="line">		maxfdp1 = <span class="built_in">max</span>(<span class="built_in">fileno</span>(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">Select</span>(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;rset)) &#123;	<span class="comment">/* socket is readable */</span></span><br><span class="line">			<span class="keyword">if</span> ( (n = <span class="built_in">Read</span>(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (stdineof == <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">return</span>;		<span class="comment">/* normal termination */</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">err_quit</span>(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">Write</span>(<span class="built_in">fileno</span>(stdout), buf, n);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(<span class="built_in">fileno</span>(fp), &amp;rset)) &#123;  <span class="comment">/* input is readable */</span></span><br><span class="line">			<span class="keyword">if</span> ( (n = <span class="built_in">Read</span>(<span class="built_in">fileno</span>(fp), buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">				stdineof = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">Shutdown</span>(sockfd, SHUT_WR);	<span class="comment">/* send FIN */</span></span><br><span class="line">				<span class="built_in">FD_CLR</span>(<span class="built_in">fileno</span>(fp), &amp;rset);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">Writen</span>(sockfd, buf, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include fig01 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>					i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">	<span class="type">int</span>					nready, client[FD_SETSIZE];</span><br><span class="line">	<span class="type">ssize_t</span>				n;</span><br><span class="line">	fd_set				rset, allset;</span><br><span class="line">	<span class="type">char</span>				buf[MAXLINE];</span><br><span class="line">	<span class="type">socklen_t</span>			clilen;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>	cliaddr, servaddr;</span><br><span class="line"></span><br><span class="line">	listenfd = <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family      = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port        = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Bind</span>(listenfd, (SA *) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Listen</span>(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">	maxfd = listenfd;			<span class="comment">/* initialize */</span></span><br><span class="line">	maxi = <span class="number">-1</span>;					<span class="comment">/* index into client[] array */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">		client[i] = <span class="number">-1</span>;			<span class="comment">/* -1 indicates available entry */</span></span><br><span class="line">	<span class="built_in">FD_ZERO</span>(&amp;allset);</span><br><span class="line">	<span class="built_in">FD_SET</span>(listenfd, &amp;allset);</span><br><span class="line"><span class="comment">/* end fig01 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* include fig02 */</span></span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		rset = allset;		<span class="comment">/* structure assignment */</span></span><br><span class="line">		nready = <span class="built_in">Select</span>(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(listenfd, &amp;rset)) &#123;	<span class="comment">/* new client connection */</span></span><br><span class="line">			clilen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">			connfd = <span class="built_in">Accept</span>(listenfd, (SA *) &amp;cliaddr, &amp;clilen);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NOTDEF</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;new client: %s, port %d\n&quot;</span>,</span><br><span class="line">					<span class="built_in">Inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr, <span class="number">4</span>, <span class="literal">NULL</span>),</span><br><span class="line">					<span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">				<span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					client[i] = connfd;	<span class="comment">/* save descriptor */</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">				<span class="built_in">err_quit</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">FD_SET</span>(connfd, &amp;allset);	<span class="comment">/* add new descriptor to set */</span></span><br><span class="line">			<span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">				maxfd = connfd;			<span class="comment">/* for select */</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">				maxi = i;				<span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;	<span class="comment">/* check all clients for data */</span></span><br><span class="line">			<span class="keyword">if</span> ( (sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;rset)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( (n = <span class="built_in">Read</span>(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">/*4connection closed by client */</span></span><br><span class="line">					<span class="built_in">Close</span>(sockfd);</span><br><span class="line">					<span class="built_in">FD_CLR</span>(sockfd, &amp;allset);</span><br><span class="line">					client[i] = <span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					<span class="built_in">Writen</span>(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end fig02 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll提供的功能和select一致，它没有select的最大描述符限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fdarray, <span class="type">unsigned</span> <span class="type">long</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include fig01 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;limits.h&gt;</span>		<span class="comment">/* for OPEN_MAX */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>					i, maxi, listenfd, connfd, sockfd;</span><br><span class="line">	<span class="type">int</span>					nready;</span><br><span class="line">	<span class="type">ssize_t</span>				n;</span><br><span class="line">	<span class="type">char</span>				buf[MAXLINE];</span><br><span class="line">	<span class="type">socklen_t</span>			clilen;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">pollfd</span>		client[OPEN_MAX];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>	cliaddr, servaddr;</span><br><span class="line"></span><br><span class="line">	listenfd = <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family      = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port        = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Bind</span>(listenfd, (SA *) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Listen</span>(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">	client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">	client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">		client[i].fd = <span class="number">-1</span>;		<span class="comment">/* -1 indicates available entry */</span></span><br><span class="line">	maxi = <span class="number">0</span>;					<span class="comment">/* max index into client[] array */</span></span><br><span class="line"><span class="comment">/* end fig01 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* include fig02 */</span></span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		nready = <span class="built_in">Poll</span>(client, maxi+<span class="number">1</span>, INFTIM);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;	<span class="comment">/* new client connection */</span></span><br><span class="line">			clilen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">			connfd = <span class="built_in">Accept</span>(listenfd, (SA *) &amp;cliaddr, &amp;clilen);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NOTDEF</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;new client: %s\n&quot;</span>, <span class="built_in">Sock_ntop</span>((SA *) &amp;cliaddr, clilen));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">				<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					client[i].fd = connfd;	<span class="comment">/* save descriptor */</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">				<span class="built_in">err_quit</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">			client[i].events = POLLRDNORM;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">				maxi = i;				<span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) &#123;	<span class="comment">/* check all clients for data */</span></span><br><span class="line">			<span class="keyword">if</span> ( (sockfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( (n = <span class="built_in">read</span>(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">							<span class="comment">/*4connection reset by client */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NOTDEF</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;client[%d] aborted connection\n&quot;</span>, i);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">						<span class="built_in">Close</span>(sockfd);</span><br><span class="line">						client[i].fd = <span class="number">-1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span></span><br><span class="line">						<span class="built_in">err_sys</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">/*4connection closed by client */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NOTDEF</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>, i);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">					<span class="built_in">Close</span>(sockfd);</span><br><span class="line">					client[i].fd = <span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					<span class="built_in">Writen</span>(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end fig02 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p><a class="link"   href="https://blog.csdn.net/longgeqiaojie304/article/details/100941837" >https://blog.csdn.net/longgeqiaojie304/article/details/100941837<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">eventpoll结构体如下所示：</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">eventpoll</span>&#123;</span><br><span class="line"> </span><br><span class="line">	……</span><br><span class="line">	<span class="comment">/* 红黑树根节点，这棵树中存储着所有添加到epoll中需要监控的事件 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line">	……</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在epoll中，每个事件都会建立一个epitem结构体，如下所示：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span>&#123;</span><br><span class="line">	<span class="comment">// 红黑树节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 双向链表节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 事件句柄信息</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 指向其所属的eventpoll对象</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 期待发生的事件类型</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>三个描述符集合：读、写、异常。数据的到来阻塞和从内核到进程阻塞</p>
<ul>
<li>水平触发(LT)：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>边缘触发(ET)：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个epoll的句柄，size用来告诉内核需要监听的数目一共有多大。当创建好epoll句柄后，</span></span><br><span class="line"><span class="comment">它就是会占用一个fd值，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*epoll的事件注册函数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待事件的到来，如果检测到事件，就将所有就绪的事件从内核事件表中复制到它的第二个参数events指向的数组*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">POLL_CTL_ADD    <span class="comment">//注册新的fd到epfd中；</span></span><br><span class="line">EPOLL_CTL_MOD    <span class="comment">//修改已经注册的fd的监听事件；</span></span><br><span class="line">EPOLL_CTL_DEL    <span class="comment">//从epfd中删除一个fd；</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">__uint32_t</span>   u32;</span><br><span class="line">    <span class="type">__uint64_t</span>   u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EPOLLIN     <span class="comment">//表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span></span><br><span class="line">EPOLLOUT    <span class="comment">//表示对应的文件描述符可以写；</span></span><br><span class="line">EPOLLPRI    <span class="comment">//表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span></span><br><span class="line">EPOLLERR    <span class="comment">//表示对应的文件描述符发生错误；</span></span><br><span class="line">EPOLLHUP    <span class="comment">//表示对应的文件描述符被挂断；</span></span><br><span class="line">EPOLLET     <span class="comment">//将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span></span><br><span class="line">EPOLLONESHOT<span class="comment">//只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTENQ 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFTIM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> opts;</span><br><span class="line">    opts=<span class="built_in">fcntl</span>(sock,F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(opts&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(sock,GETFL)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = opts|O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fcntl</span>(sock,F_SETFL,opts)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(sock,SETFL,opts)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, maxi, listenfd, connfd, sockfd,epfd,nfds, portnumber;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="type">char</span> line[MAXLINE];</span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">2</span> == argc )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (portnumber = <span class="built_in">atoi</span>(argv[<span class="number">1</span>])) &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Usage:%s portnumber/a/n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Usage:%s portnumber/a/n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev,events[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//生成用于处理accept的epoll专用的文件描述符</span></span><br><span class="line"></span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//把socket设置为非阻塞方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//setnonblocking(listenfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置与要处理的事件相关的文件描述符</span></span><br><span class="line"></span><br><span class="line">    ev.data.fd=listenfd;</span><br><span class="line">    <span class="comment">//设置要处理的事件类型</span></span><br><span class="line"></span><br><span class="line">    ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">    <span class="comment">//ev.events=EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册epoll事件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="type">char</span> *local_addr=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="built_in">inet_aton</span>(local_addr,&amp;(serveraddr.sin_addr));<span class="comment">//htons(portnumber);</span></span><br><span class="line"></span><br><span class="line">    serveraddr.sin_port=<span class="built_in">htons</span>(portnumber);</span><br><span class="line">    <span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="built_in">listen</span>(listenfd, LISTENQ);</span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">//等待epoll事件的发生</span></span><br><span class="line"></span><br><span class="line">        nfds=<span class="built_in">epoll_wait</span>(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//处理所发生的所有事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd)<span class="comment">//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                connfd = <span class="built_in">accept</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;clilen);</span><br><span class="line">                <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;connfd&lt;0&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//setnonblocking(connfd);</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> *str = <span class="built_in">inet_ntoa</span>(clientaddr.sin_addr);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accapt a connection from\n &quot;</span>);</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=connfd;</span><br><span class="line">                <span class="comment">//设置用于注测的读操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//ev.events=EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//注册ev</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLIN)<span class="comment">//如果是已经连接的用户，并且收到数据，那么进行读入。</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;EPOLLIN\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> ( (sockfd = events[i].data.fd) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (n = <span class="built_in">read</span>(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        <span class="built_in">close</span>(sockfd);</span><br><span class="line">                        events[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;readline error\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">close</span>(sockfd);</span><br><span class="line">                    events[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(n&lt;MAXLINE<span class="number">-2</span>)</span><br><span class="line">                    line[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置用于写操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                <span class="comment">//设置用于注测的写操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">                <span class="comment">//修改sockfd上要处理的事件为EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">// 如果有数据发送</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                sockfd = events[i].data.fd;</span><br><span class="line">                <span class="built_in">write</span>(sockfd, line, n);</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                <span class="comment">//设置用于注测的读操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//修改sockfd上要处理的事件为EPOLIN</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	Server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024  <span class="comment">//event的最大数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10      <span class="comment">//缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_ET  1       <span class="comment">//是否启用ET模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将文件描述符设置为非拥塞的  */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SetNonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	<span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将文件描述符fd上的EPOLLIN注册到epoll_fd指示的epoll内核事件表中，参数enable_et指定是否对fd启用et模式 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> epoll_fd, <span class="type">int</span> fd, <span class="type">bool</span> enable_et)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN; <span class="comment">//注册该fd是可读的</span></span><br><span class="line">	<span class="keyword">if</span>(enable_et)</span><br><span class="line">	&#123;</span><br><span class="line">	    event.events |= EPOLLET;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);  <span class="comment">//向epoll内核事件表注册该fd</span></span><br><span class="line">	<span class="built_in">SetNonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  LT工作模式特点：稳健但效率低 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lt_process</span><span class="params">(<span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epoll_fd, <span class="type">int</span> listen_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; number; i++) <span class="comment">//number: 就绪的事件数目</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">		<span class="keyword">if</span>(sockfd == listen_fd)  <span class="comment">//如果是listen的文件描述符，表明有新的客户连接到来</span></span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">			<span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">			<span class="type">int</span> connfd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">			<span class="built_in">AddFd</span>(epoll_fd, connfd, <span class="literal">false</span>);  <span class="comment">//将新的客户连接fd注册到epoll事件表,使用lt模式</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)	<span class="comment">//有客户端数据可读</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 只要缓冲区的数据还没读完，这段代码就会被触发。这就是LT模式的特点：反复通知，直至处理完成</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;lt mode: event trigger once!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)  <span class="comment">//读完数据了，记得关闭fd</span></span><br><span class="line">			&#123;</span><br><span class="line">			    <span class="built_in">close</span>(sockfd);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;something unexpected happened!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ET工作模式特点：高效但潜在危险 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">et_process</span><span class="params">(<span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epoll_fd, <span class="type">int</span> listen_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">	    <span class="keyword">if</span>(sockfd == listen_fd)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">			<span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">			<span class="type">int</span> connfd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">			<span class="built_in">AddFd</span>(epoll_fd, connfd, <span class="literal">true</span>);  <span class="comment">//使用et模式</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 这段代码不会被重复触发，所以我么循环读取数据，以确保把socket读缓存的所有数据读出。这就是我们消除ET模式潜在危险的手段 */</span></span><br><span class="line">			</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;et mode: event trigger once!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">				<span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/* 对于非拥塞的IO，下面的条件成立表示数据已经全部读取完毕，此后epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作 */</span></span><br><span class="line">					</span><br><span class="line">				    <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">					&#123;</span><br><span class="line">					    <span class="built_in">printf</span>(<span class="string">&quot;read later!\n&quot;</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="built_in">close</span>(sockfd);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">				    <span class="built_in">close</span>(sockfd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="comment">//没读完，继续循环读取</span></span><br><span class="line">				&#123;</span><br><span class="line">				    <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;something unexpected happened!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:  ip_address + port_number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">	<span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> listen_fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(listen_fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail to create socket!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	ret = <span class="built_in">bind</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail to bind socket!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret = <span class="built_in">listen</span>(listen_fd, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail to listen socket!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENT_NUMBER];</span><br><span class="line">	<span class="type">int</span> epoll_fd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);  <span class="comment">//事件表大小为5</span></span><br><span class="line">	<span class="keyword">if</span>(epoll_fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail to create epoll!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">AddFd</span>(epoll_fd, listen_fd, <span class="literal">true</span>); <span class="comment">//使用ET模式epoll,将listen文件描述符加入事件表</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(ENABLE_ET)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">et_process</span>(events, ret, epoll_fd, listen_fd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">lt_process</span>(events, ret, epoll_fd, listen_fd);  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">close</span>(listen_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> client_sockfd; </span><br><span class="line">    <span class="type">int</span> len; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;<span class="comment">//服务器端网络地址结构体 </span></span><br><span class="line">     <span class="type">int</span> result; </span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;ABCDE&quot;</span>; </span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;ABCDEFGHIJK&quot;</span>; </span><br><span class="line">    client_sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立客户端socket </span></span><br><span class="line">    address.sin_family = AF_INET; </span><br><span class="line">    address.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>); </span><br><span class="line">    len = <span class="built_in">sizeof</span>(address); </span><br><span class="line">    result = <span class="built_in">connect</span>(client_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, len); </span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>) </span><br><span class="line">    &#123; </span><br><span class="line">         <span class="built_in">perror</span>(<span class="string">&quot;oops: client2&quot;</span>); </span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//第一次读写</span></span><br><span class="line">    <span class="built_in">write</span>(client_sockfd, str1, <span class="built_in">sizeof</span>(str1)); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二次读写</span></span><br><span class="line">    <span class="built_in">write</span>(client_sockfd, str2, <span class="built_in">sizeof</span>(str2)); </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(client_sockfd); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h3><p>信号驱动式IO是让内核在描述符就绪时发送SIGIO信号通知我们</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/SIGIO.svg"
                      width="400"
                >

<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>异步IO的工作机制是: 告知内核启动某个操作, 让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。<br>异步IO与信号驱动IO的区别是: 后者是有内核通知我们何时可以启动一个I&#x2F;O操作, 而前者是由内核通知我们I&#x2F;O操作何时完成。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/asyncIO.svg"
                      width="400"
                >

<h3 id="I-x2F-O模型对比"><a href="#I-x2F-O模型对比" class="headerlink" title="I&#x2F;O模型对比"></a>I&#x2F;O模型对比</h3><ul>
<li>同步IO: 导致请求进程阻塞, 直到IO操作完成</li>
<li>异步IO: 不导致请求进程阻塞</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/IO模型对比.svg"
                      width="400"
                >
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之读和写</title>
    <url>/2023/03/07/C++%E4%B9%8B%E8%AF%BB%E5%92%8C%E5%86%99/</url>
    <content><![CDATA[<h1 id="C-里的读和写"><a href="#C-里的读和写" class="headerlink" title="C++里的读和写"></a>C++里的读和写</h1><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>linux里万物皆文件，在windows通常称为句柄</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//	某些非 POSIX 规范的 UNIX 系统</span></span><br><span class="line"><span class="comment">//	#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">//	#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflags)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> oflags, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	params: </span></span><br><span class="line"><span class="comment">		path   - 文件或设备的名字</span></span><br><span class="line"><span class="comment">		oflags - 打开文件所采取的动作, 比如 O_RDONLY/O_WRONLY/O_RDWR/O_APPEND 等</span></span><br><span class="line"><span class="comment">		mode   - 当 oflags 为 O_CREATE 时用来设置权限</span></span><br><span class="line"><span class="comment">	return:</span></span><br><span class="line"><span class="comment">		fd - 文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//	类似于底层的 open 调用，主要用于文件和终端的输入输出</span></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="type">const</span> *filename, <span class="type">const</span> <span class="type">char</span>* mode)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//	从文件描述符 fd 相关联的文件里读入 nbytes 个字节的数据并放到 buf 缓冲区, 返回实际读入的字节数，返回 -1 表示出错</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nitems, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="fget、getc、getchar"><a href="#fget、getc、getchar" class="headerlink" title="fget、getc、getchar"></a>fget、getc、getchar</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//	从文件流里取出下一个字节</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getc</span><span class="params">(FILE* stream)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getc</span><span class="params">(FILE* stream)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getchar</span><span class="params">()</span></span>;	<span class="comment">//	相当于 getc(stdin)</span></span><br></pre></td></tr></table></figure>

<h3 id="gets、fgets"><a href="#gets、fgets" class="headerlink" title="gets、fgets"></a>gets、fgets</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//	把读到的字符写到 s 指向的字符串里</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> n, FILE* stream)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">gets</span><span class="params">(<span class="type">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="scanf、fscanf、scanf"><a href="#scanf、fscanf、scanf" class="headerlink" title="scanf、fscanf、scanf"></a>scanf、fscanf、scanf</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//	写到 stdout</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">//	写到 s</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sscanf</span><span class="params">(<span class="type">char</span>* s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">//	写到 stream</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fscanf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//	把 buf 缓冲区里的前 nbytes 个字节的数据写入文件描述符 fd 相关联的文件里, 返回实际写入的字节数，返回 -1 表示出错</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nitems, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="fput、putc、putchar"><a href="#fput、putc、putchar" class="headerlink" title="fput、putc、putchar"></a>fput、putc、putchar</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//	从一个字符写到一个输出流里</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putc</span><span class="params">(FILE* stream)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putc</span><span class="params">(FILE* stream)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putchar</span><span class="params">()</span></span>;	<span class="comment">//	相当于 putc(stdout)</span></span><br></pre></td></tr></table></figure>

<h3 id="printf、fprintf、sprintf"><a href="#printf、fprintf、sprintf" class="headerlink" title="printf、fprintf、sprintf"></a>printf、fprintf、sprintf</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//	写到 stdout</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">//	写到 s</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span>* s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">//	写到 stream</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="ferror"><a href="#ferror" class="headerlink" title="ferror"></a>ferror</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ferror</span><span class="params">(FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="strerror"><a href="#strerror" class="headerlink" title="strerror"></a>strerror</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strerror</span><span class="params">(<span class="type">int</span> errnum)</span></span>;</span><br><span class="line"><span class="comment">//	把 errono 中报告的当前错误映射到一个字符串, 并输出到 stdout</span></span><br></pre></td></tr></table></figure>

<h3 id="perror"><a href="#perror" class="headerlink" title="perror"></a>perror</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="comment">//	把 errono 中报告的当前错误映射到一个字符串, 并输出到 stdout</span></span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//	对打开的文件描述符进行各种操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">//	创建一个指向一段内存区域的指针，该内存区域可以与通过一个打开的文件描述符访问的内容相关联</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> off)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之程序执行及内存分配</title>
    <url>/2023/03/07/C++%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h1 id="二-C-程序执行过程及内存分配"><a href="#二-C-程序执行过程及内存分配" class="headerlink" title="[二]C++程序执行过程及内存分配"></a>[二]C++程序执行过程及内存分配</h1><h2 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h2><p>上一篇博客我们已经知道了最终生成的可执行目标文件的格式，当我们在shell终端输入命令<code>./hello</code>启动这个程序的时候：</p>
<ol>
<li>shell进程会fork一个子进程，子进程是父进程的一个复制</li>
<li>子进程通过<code>exevce</code>系统调用启动加载器，加载器删除子进程现有的虚拟内存段，然后创建一个新的虚拟内存并把栈和堆初始化为零</li>
<li>加载器通过将虚拟地址空间中的页映射到可执行文件<code>./hello</code>的页大小的片，新的虚拟内存中的代码和数据则被初始化为可执行文件的内容</li>
<li>最后加载器跳转到程序入口点(ctrl.o中定义)<code>_start</code>函数地址，<code>_start</code>函数调用系统启动函数<code>__libc_start_main</code>(libc.o中定义)初始化执行环境，然后调用用户层的main函数</li>
</ol>
<p>实际上，加载的过程中是没有任何从磁盘到内存的数据复制，它只是建立一种映射，数据的复制会在程序执行的过程中直到CPU引用一个被映射的虚拟页时才会进行复制，这也就是写时复制。之所以这样是因为linux是使用一种虚拟内存的形式进行内存管理的，如下图每个进程都有自己独立的虚拟地址空间，当CPU执行程序的时候需要引用数据，内存管理单元会将数据对应的虚拟地址通过页表转换为物理地址，然后通过物理地址去实际的内存中寻找数据，如果命中了数据则取数据，否则会去磁盘中把对应的数据替换到内存中，这里不具体讨论替换的策略只是简单介绍虚拟内存的原理，这种虚拟内存的抽象方式相当于把内存作为了磁盘的高速缓存使用</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/虚拟内存.svg"
                      width="600"
                >

<h2 id="程序的内存分配"><a href="#程序的内存分配" class="headerlink" title="程序的内存分配"></a>程序的内存分配</h2><img  
                     lazyload
                     alt="image"
                     data-src="./img/Mem.svg"
                      
                >

<p>上图是进程虚拟内存的分配空间，我们一般将C++的内存分成几个区：</p>
<ol>
<li>堆：由程序员通过new分配和delete释放的存储区</li>
<li>栈：由系统自动分配和释放的存储区，通常存放局部变量、函数参数</li>
<li>全局&#x2F;静态区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区</li>
<li>文字常量区：存放文字常量</li>
<li>程序代码区（只读）：存放代码的存储区</li>
</ol>
<p>下面看一个简单的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++内存分配:</span></span><br><span class="line"><span class="comment">        1.分区</span></span><br><span class="line"><span class="comment">            - 静态区(静态内存): static 变量和函数、全局变量</span></span><br><span class="line"><span class="comment">            - 栈区: 函数、非 static 局部变量, 由程序自动创建、自动释放</span></span><br><span class="line"><span class="comment">            - 堆(动态内存、内存池): new 和 delete</span></span><br><span class="line"><span class="comment">            - 文字常量区: 常量字符串就是放在这里的, 程序结束后由系统释放</span></span><br><span class="line"><span class="comment">            - 程序代码区: 可执行代码</span></span><br><span class="line"><span class="comment">        2.缓冲区</span></span><br><span class="line"><span class="comment">            - 全缓冲区: 当填满标准I/O缓存后才进行实际I/O操作</span></span><br><span class="line"><span class="comment">            - 行缓冲区: 当在输入和输出中遇到换行符时，执行真正的I/O操作</span></span><br><span class="line"><span class="comment">            - 不带缓冲: 不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来</span></span><br><span class="line"><span class="comment">            - 缓冲区刷新: 在内存空间中预留了一定的存储空间用来缓冲输入或输出的数据, 可以减少磁盘的读写次数</span></span><br><span class="line"><span class="comment">                - 缓冲区满时</span></span><br><span class="line"><span class="comment">                - 执行flush语句</span></span><br><span class="line"><span class="comment">                - 执行endl语句</span></span><br><span class="line"><span class="comment">                - 关闭文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> pi;           <span class="comment">//  全局变量，全局区/静态区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>;    <span class="comment">//  程序代码区</span></span><br><span class="line"><span class="comment">//	class 和 struct 类似于模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;       <span class="comment">//  成员函数位于代码区</span></span><br><span class="line">  <span class="comment">// virtual void g(); //  虚函数表指针属于类位于静态区 ｜ 函数位于代码区</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="type">int</span> a;                 <span class="comment">//  栈区</span></span><br><span class="line">       <span class="type">static</span> <span class="type">int</span> b;          <span class="comment">//  静态变量，全局区/静态区</span></span><br><span class="line">       <span class="type">char</span> *c = <span class="string">&quot;hello&quot;</span>;     <span class="comment">//  指针本身位于栈 | 指向字符串&quot;hello&quot;位于文字常量区 | 编译时期就确定</span></span><br><span class="line">       <span class="type">char</span> s1[] = <span class="string">&quot;hello&quot;</span>;   <span class="comment">//  指针 s1 和指向的数组都在栈区 ｜ 运行的时候赋值</span></span><br><span class="line">       <span class="type">char</span> *e = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];<span class="comment">//  指针 e 本身位于栈 | 指针指向的内容位于堆区</span></span><br><span class="line">       A a1;      						<span class="comment">//	a1 位于栈区</span></span><br><span class="line">       A* a2 = <span class="keyword">new</span> <span class="built_in">A</span>();				<span class="comment">//	a2 位于栈区 ｜ 指向的对象位于堆区</span></span><br><span class="line">       B bb;									<span class="comment">//	bb 位于栈区</span></span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static字面意思是就是静态，它的本质就是限定访问权限，static的使用有三种情况：</p>
<ul>
<li><p>修饰全局变量或者函数：该函数或变量的作用域限定于本文件内部，外部不能访问，比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰局部变量：变量只初始化一次，数据存放在静态区，比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰成员变量或者成员函数：变量或者函数只有一份实例，可不通过对象调用直接访问，比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h2><p>我们已经知道程序的内存分配方式，那就进一步了解C++程序中不同数据类型的内存大小。下表展示了在32位和64位系统下基本数据类型的长度(单位：字节)</p>
<table>
<thead>
<tr>
<th align="center">系统</th>
<th align="center">bool&#x2F;char</th>
<th align="center">short</th>
<th align="center">int</th>
<th align="center">long</th>
<th align="center">指针</th>
<th align="center">long long</th>
<th align="center">float</th>
<th align="center">double</th>
</tr>
</thead>
<tbody><tr>
<td align="center">32位</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">64位</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
</tbody></table>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针本质上也是一个变量，而一个变量本身有两个属性：位置(地址)和内容(数据)，而指针的特殊在于它存放的内容是一个地址，通常我们说的指针指向的对象指的就是指针内容里存放的地址所存的数据。比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;address of a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;, data of a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;address of p: &quot;</span> &lt;&lt; &amp;p &lt;&lt; <span class="string">&quot;, data of p: &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//	output:</span></span><br><span class="line"><span class="comment">//	address of a: 0x7ffee49305ec, data of a: 1</span></span><br><span class="line"><span class="comment">//	address of p: 0x7ffee49305e0, data of p: 0x7ffee49305ec</span></span><br></pre></td></tr></table></figure>

<p>既然指针是一个变量，那么指针自然有以下几种情况</p>
<ul>
<li><p>空指针：指针内容为空地址(NULL)，指针不指向任何对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *nptr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>野指针：指针指向的对象因为被释放而使得指针指向的内容变的不可知，也就是指针引用了非法内存</p>
</li>
<li><p>常量指针：指针指向的对象是一个常量，该对象不能通过指针去修改，但是可以通过别的方式去修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针常量：指针本身的内容，也就是存放的地址是一个常量，不能修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="type">const</span> p; </span><br></pre></td></tr></table></figure>
</li>
<li><p>常量常指针：同时具备常量指针和指针常量的特点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>智能指针：动态内存管理经常会出现两种问题(1)一种是忘记释放内存，会造成内存泄漏(2)尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。智能指针就是为了解决这两个问题，原理是通过封装一个类来实现一个自动释放内存的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">shared_ptr&lt;string&gt; sp;			<span class="comment">//	shared_ptr 允许多个指针指向同一个对象</span></span><br><span class="line">unique_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; up;		<span class="comment">//	unique_ptr 独占所指向的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	make_shared 函数</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="comment">//重载</span></span><br><span class="line">  	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> *px;&#125;</span><br><span class="line">  	T&amp; <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> px;&#125;</span><br><span class="line">  	<span class="comment">//构造函数</span></span><br><span class="line">  	<span class="built_in">shared_ptr</span>(T* p): <span class="built_in">px</span>(p) &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	T* px;</span><br><span class="line">  	<span class="type">long</span>* pn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line">  <span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line">  sp -&gt; <span class="built_in">method</span>(); <span class="comment">//px -&gt; method();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>在C++中除了基本数据类型以外还有struct、class，struct的内存分配比较特别，因为它存在<strong>字节对齐</strong>，字节对齐的原则如下</p>
<ol>
<li>起始位置为成员数据类型所占内存的整数倍，若不足则不足部分用数据将内存填充为该数据类型的整数倍。</li>
<li>结构体所占总内存为其成员变量中所占空间最大数据 类型的整数倍</li>
</ol>
<p>比如如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	内存大小: 8</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">s1</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//	内存大小: 12</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">s2</span>&#123;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    cout&lt;&lt; <span class="string">&quot; s1: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s1)&lt;&lt;<span class="string">&quot;, s2: &quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(s2)&lt;&lt;endl;    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>结构体s1和s2在内存中的大小之所以不一样可以用下图理解</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/字节对齐.svg"
                      
                >

<blockquote>
<p>为什么要字节对齐？</p>
<ul>
<li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li>
<li>硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。</li>
</ul>
</blockquote>
<p>当然，我们也可以通过<code>__attribute__ ((__packed__))</code>强制不使用字节对齐，比如redis源码里就使用了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__attribute__</span> ((__packed__)) hisdshdr5 &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>而class在内存中的布局也是遵循字节对齐的原子，相对于结构体要复杂是类会涉及到继承的问题。如下代码简单的描述了这几种情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">long</span> s;</span><br><span class="line">	<span class="type">long</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VBase</span> &#123;</span><br><span class="line">	<span class="type">long</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base &#123;	<span class="comment">//	24 Byte</span></span><br><span class="line">	<span class="type">long</span> c;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> VBase &#123;<span class="comment">//	32 Byte</span></span><br><span class="line">	<span class="type">long</span> c;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> VBase &#123;<span class="comment">//	32 Byte</span></span><br><span class="line">	<span class="type">long</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VBase &#123;<span class="comment">//	40 Byte</span></span><br><span class="line">	<span class="type">long</span> c;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> VBase &#123;<span class="comment">//	40 Byte</span></span><br><span class="line">	<span class="type">long</span> c;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;普通基类Base大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; <span class="string">&quot;Byte,&quot;</span> &lt;&lt; <span class="string">&quot;虚基类VBase大小：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(VBase) &lt;&lt; <span class="string">&quot;Byte.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;[普通继承，父类没有虚函数] &quot;</span> &lt;&lt; <span class="string">&quot;父类:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; <span class="string">&quot;Byte, &quot;</span> &lt;&lt; <span class="string">&quot;子类A:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; <span class="string">&quot;Byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;[普通继承，父类含有虚函数，子类没有重写虚函数] &quot;</span> &lt;&lt; <span class="string">&quot;父类:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(VBase) &lt;&lt; <span class="string">&quot;Byte, &quot;</span> &lt;&lt; <span class="string">&quot;子类B:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; <span class="string">&quot;Byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;[普通继承，父类含有虚函数，子类重写虚函数] &quot;</span> &lt;&lt; <span class="string">&quot;父类:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(VBase) &lt;&lt; <span class="string">&quot;Byte, &quot;</span> &lt;&lt; <span class="string">&quot;子类C:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; <span class="string">&quot;Byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;[虚继承，子类没有重写虚函数] &quot;</span> &lt;&lt; <span class="string">&quot;父类:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(VBase) &lt;&lt; <span class="string">&quot;Byte, &quot;</span> &lt;&lt; <span class="string">&quot;子类D:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; <span class="string">&quot;Byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;[虚继承，子类重写虚函数] &quot;</span> &lt;&lt; <span class="string">&quot;父类:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(VBase) &lt;&lt; <span class="string">&quot;Byte, &quot;</span> &lt;&lt; <span class="string">&quot;子类E:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(E) &lt;&lt; <span class="string">&quot;Byte&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以简单总结一下：</p>
<ul>
<li>普通继承情况，子类会继承父类的数据</li>
<li>父类含虚函数的普通继承情况下，无论子类是否重写虚函数，子类继承父类的数据(包含虚函数表指针)</li>
<li>父类含虚函数的虚继承情况下，无论子类是否重写虚函数，子类继承父类的数据(包含虚函数表指针和虚基类指针)<img  
                     lazyload
                     alt="image"
                     data-src="./img/classmem.svg"
                     
                ></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之程序编译过程</title>
    <url>/2023/03/07/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一-C-程序的编译过程"><a href="#一-C-程序的编译过程" class="headerlink" title="[一]C++程序的编译过程"></a>[一]C++程序的编译过程</h2><p>任何一种计算机语言都要从某种人们容易理解的形式（源代码）翻译成计算机能执行的形式（机器代码），通常翻译器分类：解释器（interpreter）和编译器（compiler）</p>
<ul>
<li>解释器：将源代码转化成一些动作（它可由多组机器指令组成）并立即执行这些动作。比如python解释器先把程序转化成某种中间语言，然后由执行速度更快的解释器来执行。使用解释器的好处是从写代码到执行代码的转换几乎能立即完成，并且源代码总是现存的，所以一旦出现错误，解释器能够很容易地指出；而使用解释器的局限性是解释器必须驻留内存以执行程序，这样一来即使最快的解释器其速度也会变得让人难以接受</li>
<li>编译器：直接把源代码转化成汇编语言或机器指令，最终结果是一个或多个机器代码的文件</li>
</ul>
<p>C++使用的是编译器，而C++程序的编译过程主要包括：预处理-&gt;编译-&gt;汇编-&gt;链接</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/Compile.png"
                     
                >

<h2 id="一、预处理"><a href="#一、预处理" class="headerlink" title="一、预处理"></a>一、预处理</h2><p>预处理主要工作是：条件编译、头文件包含、宏替换的处理和删除注释等，最终会生成编译单元.i文件，预处理语句一般以<code>#</code>开头。可以通过如下命令查看预处理后的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -E hello.cpp -o hello.i</span><br></pre></td></tr></table></figure>

<h3 id="头文件包含"><a href="#头文件包含" class="headerlink" title="头文件包含"></a>头文件包含</h3><p>头文件包含的预处理语句是<code>#include</code>，用一句话解释就是：替换，把预处理语句指向的内容替换到语句指定的地方。通过一个实验会更直观一点，我们创建一个hello.cpp文件，然后通过一个预处理语句导入一个Hello.h的自定义头文件，而这个自定义头文件的内容只有一个<code>&#125;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	hello.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hello.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	Hello.h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们用命令对这个cpp文件进行预处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -E hello.cpp -o hello.i</span><br></pre></td></tr></table></figure>

<p>打开hello.i查看会发现<code>#include &quot;Hello.h&quot;</code>命令只是单纯的把<code>&#125;</code>替换到hello.cpp文件里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	hello.i</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;./Hello.h&quot;</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"># <span class="number">5</span> <span class="string">&quot;hello.cpp&quot;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="宏替换"><a href="#宏替换" class="headerlink" title="宏替换"></a>宏替换</h3><p>宏替换语句也是一个常用的语句，它的命令是<code>#define</code>，它的本质也还是替换：将指定的变量替换为一个值，通常用来定义一个常量，比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME <span class="string">&quot;Ribin&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> a = PI;</span><br><span class="line">  <span class="type">char</span>[] s = NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理后的文件如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">char</span>[] s = <span class="string">&quot;Ribin&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏定义和const的区别：</p>
<ul>
<li>define 定义的只是个常数不带类型，const 定义的常数是变量并且带类型</li>
<li>define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用</li>
<li>define只是简单的替换没有类型检查，而const有对应的数据类型需要进行判断</li>
<li>define占用代码段空间，const占用数据段空间</li>
<li>define是不能进行调试的，因为在预编译阶段就已经替换掉了，const常量可以进行调试的</li>
<li>define可以通过#undef取消某个符号的定义，再重新定义，const不能重定义</li>
<li>define可以用来防止头文件重复引用，而const不能</li>
</ul>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>条件编译的预处理命令有：<code>#ifdef</code>、<code>#ifndef</code>、<code>#endif</code>、<code>#else</code>等。它的用法类似于基本的条件语句，主要是进行条件判断来简化代码，常用来做版本控制和防止头文件重复引用问题，比如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INT_LINKED_LIST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_LINKED_LIST</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>预处理语句还有很多，比如<code>#progma</code>，这里只讨论预处理阶段的工作，不具体到每个预处理语句的介绍</p>
</blockquote>
<h2 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h2><p>编译阶段的主要工作是：将预处理后的文件转换成汇编语言，生成.s文件，编译的命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -S hello.i -o hello.s	#	.i -&gt; .s</span><br></pre></td></tr></table></figure>

<p>编译一般分两个阶段的工作：</p>
<ol>
<li>第一遍编译：<ul>
<li>语法分析</li>
<li>静态类型检查（检查函数是否正确使用，在编译阶段进行，运行时的类型检查称为动态类型检查）。程序可由多个文件构成，一个文件中的函数很可能要访问另一些文件中的函数和数据，编译器为了确保函数和数据被正确地使用从而需要告知编译器外部函数和数据的名称以及它们的模样，这一过程称为声明</li>
</ul>
</li>
<li>全局优化器</li>
<li>第二遍编译：由代码生成器遍历语法分析树把树的每个节点转化成汇编语言或者机器代码</li>
</ol>
<h2 id="三、汇编"><a href="#三、汇编" class="headerlink" title="三、汇编"></a>三、汇编</h2><p>汇编阶段的主要工作是：生成目标代码(机器代码).o或者.obj的目标模块(可重定位目标文件)，可重定位目标文件由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列，地址从0开始。汇编的命令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c hello.cpp	#	.cpp -&gt; .s</span><br></pre></td></tr></table></figure>

<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>目标文件有三种：</p>
<ol>
<li>可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来创建一个可执行目标文件</li>
<li>可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行</li>
<li>共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接</li>
</ol>
<p>各个系统的目标文件格式都不相同：</p>
<ul>
<li>Unix系统使用的是a.out格式</li>
<li>Windows使用可移植可执行（PE）格式</li>
<li>Mac使用Mach-O格式</li>
<li>现代x86-64 Linux和Unix系统使用可执行可链接格式(Executable and Linkable Format, ELF)</li>
</ul>
<p>汇编阶段会生成可重定位目标文件，一个典型的ELF可重定位目标文件的格式如下图</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/ELF.svg"
                     
                >

<ul>
<li>ELF头以一个16字节的序列开始。描述了生成该文件的系统的字的大小和字节顺序，剩下的部分包含帮助链接器语法分析和解释目标文件的信息，比如ELF头的大小、目标文件的类型、机器类型、节头部表的文件偏移以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。</li>
<li>.text：已编译程序的机器代码</li>
<li>.rodata：只读数据，比如printf语句中的格式串和switch语句的跳转表</li>
<li>.data：已初始化的全局和静态变量，局部变量运行时保存在栈中不在.data和.bss中</li>
<li>.bss：未初始化的全局和静态变量以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占实际的空间仅仅是一个占位符，未初始化的变量不需要占据任何实际磁盘空间,运行时在内存中分配这些变量</li>
<li>.symtab：符号表，存放程序中定义和引用的函数和全局变量的信息，和编译器中的符号表不同的是不包含局部变量的条目（可使用STRIP去掉）</li>
<li>.rel.tex：.text节中位置的列表，当链接器把这个目标文件和其他文件组合时需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改，调用本地函数的指令则不需要修改</li>
<li>.rel.data：被模块引用或定义的所有全局变量的重定位信息，一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要修改</li>
<li>.debug：调试符号表，其条目是程序中定义的局部变量和类型定义、程序中定义和引用的全局变量以及源文件，只有以-g选项调用编译器驱动程序时才会得到这张表</li>
<li>.line：原始程序中的行号和.text节中机器指令之间的映射，只有以-g选项调用编译器驱动程序时才会得到这张表</li>
<li>.strtab：字符串表，包括.symtab和.debug中的符号表以及节头部中的节名字，字符串表就是以null结尾的字符串的序列</li>
</ul>
<blockquote>
<p>可以通过<code>readelf</code>命令来查看ELF文件信息，mac系统需要安装<code>binutils</code>然后使用<code>greadelf</code></p>
</blockquote>
<h2 id="四、链接"><a href="#四、链接" class="headerlink" title="四、链接"></a>四、链接</h2><p>链接的实现时机：</p>
<ul>
<li>编译时：源代码被编译成机器代码时，链接由静态链接器负责</li>
<li>加载时：程序被加载到内存时，链接由加载器负责</li>
<li>运行时：由动态链接器负责</li>
</ul>
<p>链接阶段任务是由静态链接器完成的，主要工作是：把一组目标模块（可重定位目标文件）连接成为一个操作系统可以装载和运行的可执行程序。链接器能搜索称为库的特殊文件来处理它的所有引用，库将一组目标模块包含在一个文件中，库由库管理器的程序来创建和维护，链接的命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -o hello hello.cpp	# .cpp -&gt; .exe</span><br><span class="line">as -o hello hello.s			# .s -&gt; .exe</span><br></pre></td></tr></table></figure>

<p>为了构造可执行文件，链接器必须完成两个主要任务：</p>
<ol>
<li>符号解析：将每个符号（函数、全局变量或静态变量）引用刚好和一个符号定义联系起来</li>
<li>重定位：编译器和汇编器生成了从地址0开始的代码和数据节，链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。</li>
</ol>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>符号：每个重定位模块m.o都有一个符号表.symtab，符号表由汇编器构造，它包含m定义和引用的符号的信息。在链接器的上下文中有三种不同的符号：</p>
<ul>
<li>由模块m定义并能被其他模块引用 的全局符号(本模块的全局变量和普通函数)</li>
<li>由其他模块定义并被模块m引用的全局符号，也称为外部符号，对应于在其他模块中定义的非静态函数和全局变量(其他模块的全局变量和普通函数并在本模块extern修饰的符号)</li>
<li>只被m模块定义和引用的局部符号，对应于静态函数和全局变量(本模块的静态变量和静态函数)</li>
</ul>
<p>符号解析：符号解析的方法就是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对于局部符号的解析是比较简单的，编译器只允许每个模块中每个局部符号只有一个定义，当然编译器不是简单的使用函数或者变量名作为符号，而是使用一种<strong>函数签名</strong>(将函数名、参数类型、命名空间等组合的一种编码方式)的方式对名字进行了重整，这也是实现函数重载的基础。而对于全局符号的解析稍微复杂，如果多个模块定义同名的全局符号，编译器会把函数和已初始化的全局变量指定为强符号，而未初始化的全局变量指定为弱符号，对全局符号的解析遵循下面三个原则：</p>
<ul>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号</li>
<li>如果有多个弱符号同名，那么从这些弱符号中任意选择一个</li>
</ul>
<p>当目标模块需要和静态库(一组目标模块的集合)进行链接时，链接器会维护三个集合：</p>
<ul>
<li>集合E：可重定位目标文件集合</li>
<li>集合U：未解析的符号集合(即引用了但是尚未定义)</li>
<li>集合D：已解析的符号集合</li>
</ul>
<p>链接器会从左到右扫描输入文件，如果文件f是目标文件则把f添加到集合E同时修改集合U和D；如果f是静态库文件，那么链接器就尝试匹配U中未解析的符号是否在静态库文件中的某个模块m中定义了，如果m存在就把m加入到集合E中同时更新U和D，依次扫描直到U和D不再更新。最终如果集合U非空，则说明存在未解析的符号，就会抛出错误<code>Unresolved symbol</code>，否则，就会生成最终的可执行目标文件，具体命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar rcs libvector.a addvec.o multvec.o	#	打包静态库</span><br><span class="line">g++ -static ./libvector.a main.cpp		#	链接静态库</span><br></pre></td></tr></table></figure>

<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>一旦链接器成功完成了符号解析，此时链接器就知道它的输入目标模块中的代码节和数据节的确切大小，然后就开始重定位操作，重定位操作分两步：</p>
<ol>
<li>重定位节和符号定义：将所有相同类型的节合并为同一类型的新的聚合节</li>
<li>重定位节中的符号引用：修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址，这一步依赖于重定位目标中的重定位条目</li>
</ol>
<blockquote>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终存放在内存中的什么位置，所以无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目来告诉链接器在讲目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中</p>
</blockquote>
<p>###动态链接</p>
<p>动态链接：当程序加载时动态的完成链接过程，共享库(动态库)实现共享的方式：</p>
<ul>
<li>对于一个库只有一个.so文件，所有引用该库的可执行目标文件共享这个，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中</li>
<li>在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -shared -fpic -o libvector.so addvec.cpp multvec.cpp	#	打包共享库</span><br><span class="line">g++ -o prog main.cpp ./libvector.so												#	链接共享库</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">文件类型&#x2F;扩展名</th>
<th align="center">Windows</th>
<th align="center">Linux</th>
</tr>
</thead>
<tbody><tr>
<td align="center">动态库文件</td>
<td align="center">.dll</td>
<td align="center">.so</td>
</tr>
<tr>
<td align="center">可重定向目标文件</td>
<td align="center">.obj</td>
<td align="center">.o</td>
</tr>
<tr>
<td align="center">静态库文件</td>
<td align="center">.lib</td>
<td align="center">.a</td>
</tr>
</tbody></table>
<p>动态加载器通过执行下面的重定位目标完成链接任务：</p>
<ul>
<li>重定位a.so的文本和数据到某个内存段</li>
<li>重定位b.so的文本和数据到另一个内存段</li>
<li>重定位prog中所有对由a.so和b.so定义的符号的引用</li>
<li>将控制传递给应用程序，共享库的位置就固定了，并且在程序执行的过程中都不会改变</li>
</ul>
<h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><p>可执行目标文件的格式类似于可重定位目标文件的格式，其中.init节定义了一个小函数_init，程序的初始化代码会调用它。可执行文件的连续的片被映射到连续的内存段，程序头部表描述了这种映射关系。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/EXE.svg"
                     
                >

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序的编译要经历：预处理生成编译单元 -&gt; 编译(编译+汇编)生成可重定位的目标文件 -&gt; 链接生成可执行目标文件，最终生成的可执行目标文件大致可以分为三部分：代码区、数据区、调试信息。本篇博客只是简单的记录一下程序的编译过程，其中动态链接部分涉及到位置无关代码等内容没有讨论，将来有时间再进行补充。下一篇博客简单说说程序的加载执行过程…</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之面向对象特性</title>
    <url>/2023/03/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="三-C-面向对象特性"><a href="#三-C-面向对象特性" class="headerlink" title="[三]C++面向对象特性"></a>[三]C++面向对象特性</h1><p>面向对象有几大特性：抽象、封装、继承和多态</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>C++可以通过类class将数据和函数封装起来实现面向对象，类和对象是两个不同概念，类相当于一个模具，对象则是实例化的类，二者在访问权限上会有一些区别。</p>
<p>当类被实例化的过程中会调用构造函数去初始化这个对象，而当对象被销毁后会自动调用析构函数，我们可以在析构函数上做一些处理去释放内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//  使用初始化列表形式</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(string s = <span class="string">&quot;ribincao&quot;</span>, <span class="type">int</span> n = <span class="number">26</span>) : <span class="built_in">name</span>(s), <span class="built_in">age</span>(n) &#123; &#125;</span><br><span class="line">        <span class="comment">//  使用有普通函数的形式</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(string s) &#123;</span><br><span class="line">            name = s;</span><br><span class="line">            age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  拷贝构造函数</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(<span class="type">const</span> BaseClass &amp;v) &#123;</span><br><span class="line">            name = v.name;</span><br><span class="line">            age = v.age;</span><br><span class="line">        &#125;</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    构造函数总结:</span></span><br><span class="line"><span class="comment">      1.概念: 类对象被创建时，编译系统为对象分配内存空间，并自动调用该构造函数-&gt;由构造函数完成成员的初始化工作</span></span><br><span class="line"><span class="comment">      2.作用: 初始化对象的数据成员</span></span><br><span class="line"><span class="comment">      3.类型</span></span><br><span class="line"><span class="comment">        - 默认构造函数: 分为有用的和无用的，无用的默认构造函数就是一个空函数什么操作也不做, 有用的默认构造函数是可以初始化成员的函数</span></span><br><span class="line"><span class="comment">        - 拷贝构造函数: 参数是本类型的一个引用变量(指针), 可实现类型转换</span></span><br><span class="line"><span class="comment">      4.注意: 默认构造函数不要出现歧义, 不要让编译器出现不知道使用哪一个构造函数的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseClass v1;</span><br><span class="line">    <span class="function">BaseClass <span class="title">v2</span><span class="params">(<span class="string">&quot;jack&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    <span class="function">BaseClass <span class="title">v3</span><span class="params">(v1)</span></span>;</span><br><span class="line">    <span class="comment">// BaseClass v4(&quot;bob&quot;); 出现歧义, 编译器不知道使用哪一个构造函数去初始化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v1] name: &quot;</span> &lt;&lt; v1.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v1.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v2] name: &quot;</span> &lt;&lt; v2.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v2.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v3] name: &quot;</span> &lt;&lt; v3.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v3.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(string* s, <span class="type">int</span> n) : <span class="built_in">name</span>(s), <span class="built_in">age</span>(n) &#123;&#125;</span><br><span class="line">        <span class="comment">//  name 是指向字符串的指针, 成员占用的内存被释放, 但是字符串占用的内存没有被销毁会导致内存泄漏, 可通过析构函数去释放这部分内存</span></span><br><span class="line">        ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(name != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">free</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        string* name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    析构函数:</span></span><br><span class="line"><span class="comment">      1.时机: 当对象被销毁时去执行</span></span><br><span class="line"><span class="comment">      2.作用: 对象被销毁时，对象所占用的内存会被释放, 但不是与它相关联的所有内存都会销毁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;ribincao&quot;</span>;</span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(&amp;name, <span class="number">26</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的内部存在三种成员：public、protected、private</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="comment">//	公共成员</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Test</span>(<span class="type">int</span> a) : <span class="built_in">data</span>(a) &#123;&#125;	<span class="comment">//	初始化列表</span></span><br><span class="line">  	<span class="built_in">Test</span>(<span class="type">const</span> Test&amp; b)&#123;			<span class="comment">//	拷贝构造函数</span></span><br><span class="line">      a.data = b.data;</span><br><span class="line">    &#125;</span><br><span class="line">  	~<span class="built_in">Test</span>()&#123;									<span class="comment">//	析构函数</span></span><br><span class="line">      <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">GetData</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//	保护成员</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="type">char</span> s;</span><br><span class="line">  <span class="comment">//	私有成员</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="type">int</span> data;</span><br><span class="line">  	<span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Test v1 = <span class="built_in">Test</span>(<span class="number">123</span>);</span><br><span class="line">  Test v2 = v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一篇博客在讲到类的内存大小的时候我们发现类的成员函数是不占用数据段内存的，而是在代码区存储的，那不同的对象调用成员函数的时候是通过一个叫做<code>this</code>指针的东西去调用的。？</p>
<h3 id="关于函数参数"><a href="#关于函数参数" class="headerlink" title="关于函数参数"></a>关于函数参数</h3><p>关于成员函数的参数传递，和普通函数一样有三种</p>
<ul>
<li><strong>值传递</strong>：参数的值将复制到相应函数参数的值中，函数不能修改原始参数。复制结构和类会导致显着的性能损失，尤其是在多次调用函数时</li>
<li><strong>地址传递</strong>：函数会更改参数的值，可用来实现一个函数返回多个值，但不能接受常量参数</li>
<li><strong>引用</strong><ul>
<li><p>常量引用：该函数不会改变参数，同时减少复制的开销</p>
</li>
<li><p>指针引用：可以让函数完全改变指针的地址</p>
</li>
<li><p>引用传递的优点：</p>
<ul>
<li>引用允许函数更改参数的值，这有时很有用。否则，const引用可用于保证函数不会更改参数。</li>
<li>因为没有创建参数的副本，所以即使与大型结构或类一起使用，也很快通过引用传递。</li>
<li>引用可用于从函数返回多个值（通过out参数）。</li>
<li>必须初始化引用，因此不必担心空值。</li>
</ul>
<p>引用传递的缺点：</p>
<ul>
<li>由于非const引用无法使用const l值或r值（例如文字或表达式）进行初始化，因此引用参数的参数必须是常规变量。</li>
<li>很难判断非const引用传递的参数是输入，输出还是两者。明智地使用const和out变量的命名后缀可以提供帮助。</li>
<li>从函数调用中判断参数是否可能改变是不可能的。通过值传递并通过引用传递的参数看起来是相同的。我们只能通过查看函数声明来判断参数是通过值还是引用传递的。这可能导致程序员没有意识到函数会改变参数值的情况。</li>
</ul>
<p>何时使用引用传递：</p>
<ul>
<li>传递结构或类时（如果只读，则使用const）</li>
<li>当您需要该函数来修改参数时</li>
<li>当您需要访问固定数组的类型信息时</li>
</ul>
<p>何时不使用引用传递：</p>
<ul>
<li>传递不需要修改的基本类型时（使用按值传递）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>同样，参数的返回也是有三种：</p>
<ul>
<li><p><strong>按值返回</strong>：按值返回是最简单，最安全的返回类型。当按值返回值时，该值的副本将返回给调用者。按值返回的另一个优点是，您可以返回涉及在函数内声明的局部变量的变量（或表达式），而不必担心范围问题。缺点是结构和大类的返回值很慢。</p>
<ul>
<li>何时使用按值返回：<ul>
<li>返回在函数内声明的变量时</li>
<li>返回按值传递的函数参数时</li>
</ul>
</li>
<li>何时不使用按值返回：<ul>
<li>返回内置数组或指针时（使用地址返回）</li>
<li>返回大型结构或类时（使用引用返回）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>按地址返回</strong>：按地址返回只能返回变量的地址，而不是文字或表达式（没有地址）。因为按地址返回只是将函数的地址复制到调用者，所以按地址返回的速度很快。但是，按地址返回还有一个额外的缺点，即如果您尝试将函数的本地地址返回给函数，则程序将显示未定义的行为。</p>
<ul>
<li><p>何时使用地址返回：</p>
<ul>
<li>返回动态分配的内存时</li>
<li>返回由地址传递的函数参数时</li>
</ul>
</li>
<li><p>何时不使用地址返回：</p>
<ul>
<li>返回在函数内声明的变量时（使用return by value）</li>
<li>返回通过引用传递的大型结构或类时（使用按引用返回）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>按引用返回</strong>：通过引用返回通常用于将通过引用传递的参数返回给调用者。就像按地址返回一样，您不应该通过引用返回局部变量。</p>
<p>何时使用以引用方式返回：</p>
<ul>
<li>返回参考参数时</li>
<li>从传递给函数的数组返回元素时</li>
<li>返回在函数末尾不会被销毁的大型结构或类（例如传入的结构或类）</li>
</ul>
<p>何时不通过引用返回：</p>
<ul>
<li>返回在函数内声明的变量时（使用return by value）</li>
<li>返回内置数组或指针值时（使用地址返回）</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>C++是一个多继承语言，在C++里有两种继承方式：普通继承和虚继承，继承的访问权限有两种：<code>public</code>和<code>protected</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BaseClass</span>() &#123; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in BaseClass called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">h</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function g() in BaseClass called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function h() in BaseClass\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1Level1</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> BaseClass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in DerivedLevel1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;Derived1Level1&quot;</span>);</span><br><span class="line">            <span class="built_in">h</span>(<span class="string">&quot;Derived1Level1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Function h() in Derived1Level1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2Level1</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> BaseClass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in Derived2Level1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;Derived2Level1&quot;</span>);</span><br><span class="line">            <span class="comment">// h(); &#x27;h&#x27; is a private member of &#x27;BaseClass&#x27;, 继承是不能访问父类的 private 成员的</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedLevel2</span> : <span class="keyword">public</span> Derived1Level1, <span class="keyword">public</span> Derived2Level1 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in DerivedLevel2 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">            Derived1Level1::<span class="built_in">h</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">            BaseClass::<span class="built_in">f</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    继承总结：</span></span><br><span class="line"><span class="comment">        1. 类和对象是有区别的, 比如类可以访问 protected 成员, 但是该类的对象是不能直接访问 protected 成员</span></span><br><span class="line"><span class="comment">        2. 继承权限</span></span><br><span class="line"><span class="comment">          - public 继承: 父类的 public 和 protected 在子类还是保持</span></span><br><span class="line"><span class="comment">          - protected 继承: 父类的 public 和 protected 在子类变成了 protected</span></span><br><span class="line"><span class="comment">        3. 继承方式</span></span><br><span class="line"><span class="comment">          - 普通继承: 多重继承可能会出现多个基类的副本, 导致二义性问题</span></span><br><span class="line"><span class="comment">          - 虚继承(virtual): 只生成一个基类的副本, 比如下面的继承关系会让 B 和 C 虚继承基类 A, 虚继承情况下，子类会生成一个虚基类指针_vbptr</span></span><br><span class="line"><span class="comment">                    A</span></span><br><span class="line"><span class="comment">                   / \</span></span><br><span class="line"><span class="comment">                  B   C</span></span><br><span class="line"><span class="comment">                   \ /</span></span><br><span class="line"><span class="comment">                    D</span></span><br><span class="line"><span class="comment">        关键词: 信息隐藏原则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseClass bc;</span><br><span class="line">    Derived1Level1 d1l1;</span><br><span class="line">    Derived2Level1 d2l1;</span><br><span class="line">    DerivedLevel2 dl2;</span><br><span class="line"></span><br><span class="line">    bc.<span class="built_in">f</span>(<span class="string">&quot;main(1)&quot;</span>);<span class="comment">//  类的 public 成员是可以被类对象访问的</span></span><br><span class="line">    <span class="comment">// bc.g(); 类的 protected 成员是不能被基类对象访问的</span></span><br><span class="line">    <span class="comment">// bc.h(); 类的 private 成员是不能被类对象访问的</span></span><br><span class="line"></span><br><span class="line">    d1l1.<span class="built_in">f</span>(<span class="string">&quot;main(2)&quot;</span>);<span class="comment">//  派生类在 public 继承下可以访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d1l1.g();  派生类对象不能访问父类的 protected 成员</span></span><br><span class="line">    d1l1.<span class="built_in">h</span>(<span class="string">&quot;main(3)&quot;</span>);<span class="comment">//  private 对象是不能被继承的, 派生类访问的是自己的 public 成员</span></span><br><span class="line"></span><br><span class="line">    d2l1.<span class="built_in">f</span>(<span class="string">&quot;main(4)&quot;</span>);<span class="comment">//  派生类在 public 继承下可以访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d2l1.g();  派生类对象不能访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d2l1.h();  private 对象是不能被继承的</span></span><br><span class="line"></span><br><span class="line">    dl2.<span class="built_in">f</span>(<span class="string">&quot;main(5)&quot;</span>);</span><br><span class="line">    <span class="comment">// dl2.g();  派生类对象不能访问父类的 protected 成员, 派生类可以</span></span><br><span class="line">    dl2.<span class="built_in">h</span>();<span class="comment">//  派生类对象可以访问父类的 public 成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C++中多态的实现有两种：静态多态和动态多态。其中静态多态通过函数重载来实现，函数重载依赖的是函数签名的机制，这也是C++区别于C的地方；动态多态则是通过虚函数来实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// virtual void fun() = 0;</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Father say Hi&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Father say Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Father &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Son say Hi&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Son say Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHi</span><span class="params">(Father &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">Say</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">(Father &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    虚函数:</span></span><br><span class="line"><span class="comment">      1.实现: 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针(_vfptr, 在构造函数里初始化);虚表是和类对应的，虚表指针是和对象对应的</span></span><br><span class="line"><span class="comment">      2.纯虚函数: 虚函数再加上 = 0, 存在纯虚函数的类为抽象类(接口类)，不能实例化, 子类必须重写纯虚函数</span></span><br><span class="line"><span class="comment">    多态:</span></span><br><span class="line"><span class="comment">      1.作用: 一个接口多种实现</span></span><br><span class="line"><span class="comment">      2.实现:</span></span><br><span class="line"><span class="comment">        - 虚函数-&gt;动态绑定-&gt;运行时多态。通过基类的指针或者引用，在运行时动态调用实际绑定对象函数的行为</span></span><br><span class="line"><span class="comment">        - 重载-&gt;编译时多态</span></span><br><span class="line"><span class="comment">      3.类型</span></span><br><span class="line"><span class="comment">        - 类的多态性</span></span><br><span class="line"><span class="comment">        - 函数的多态性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;</span><br><span class="line">    Father father;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SayHello</span>(son);</span><br><span class="line">    <span class="built_in">SayHello</span>(father);</span><br><span class="line">    <span class="comment">//  实现多态</span></span><br><span class="line">    <span class="built_in">SayHi</span>(son);</span><br><span class="line">    <span class="built_in">SayHi</span>(father);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数重载中有一种比较特殊的函数重载：运算法重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Base</span>(<span class="type">int</span> n = <span class="number">18</span>) : <span class="built_in">age</span>(n) &#123;&#125;</span><br><span class="line">        <span class="comment">//  运算符重载</span></span><br><span class="line">        Base <span class="keyword">operator</span>- () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Base</span>(-age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  按照C语言风格编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">float</span> <span class="title">sum</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    重载：</span></span><br><span class="line"><span class="comment">      1.类型</span></span><br><span class="line"><span class="comment">        - 函数重载: 函数名相同但是函数签名不同(形参个数、类型和顺序), 函数签名的实现方式不同是C语言不能实现重载的原因, 编译器编译.c文件只是对函数进行简单的重命名</span></span><br><span class="line"><span class="comment">        - 运算符重载: 本质上是函数重载</span></span><br><span class="line"><span class="comment">      2.作用: 实现静态多态</span></span><br><span class="line"><span class="comment">      3.重载和重写</span></span><br><span class="line"><span class="comment">        - 重载: 是相同的函数名字针对不同的输入进行不同的操作, 函数的签名是不同的</span></span><br><span class="line"><span class="comment">        - 重写: 子类对父类的成员函数进行重新编写来实现不同的表现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  系统会根据实参的类型来实现准确调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1.1</span>, <span class="number">2.2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重载运算符 -</span></span><br><span class="line">    <span class="function">Base <span class="title">v</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (-v).<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>C++类型转换主要分为两种：隐式类型转换、显式类型转换（强制类型转换）。隐式类型转换主要是通过operator（类型转换函数）来实现的；强制类型转换主要用到四个关键字，下面博客内容就按隐式→显式四个关键字 来展开。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><h4 id="基本数据类型间"><a href="#基本数据类型间" class="headerlink" title="基本数据类型间"></a>基本数据类型间</h4><p>基本数据类型之间进行隐式转换的几种情况：</p>
<p>1、算术转换(Arithmetic conversion) : 在混合类型的 算术表达式 中, 位数最宽的数据类型成为目标转换类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> j = <span class="number">3.1</span>;</span><br><span class="line">i+j;<span class="comment">//i会被转换成double类型，然后才做加法运算。</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>2、一种类型表达式赋值给另一种类型的对象：目标类型是被赋值对象的类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> inum = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uinum = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> dnum = <span class="number">2.3</span>;</span><br><span class="line">uinum = inum; <span class="comment">//4294967295</span></span><br><span class="line">inum = dnum;  <span class="comment">//2</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>这种情况的转换，窄类型转换为宽类型一般没有问题，宽类型转换为窄类型一般会截断转换，有符号类型转换为无符号类型会出现我们不想出现的情况。</p>
<p>3、将一个表达式作为实参传递给函数调用，此时形参和实参类型不一致：目标转换类型为形参的类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">sqrt</span><span class="params">( <span class="type">double</span> )</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; The square root of 2 is  &quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 2被提升为double类型：2.0</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>4、从一个函数返回一个表达式，表达式类型与返回类型不一致：目标转换类型为函数的返回类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">difference</span><span class="params">(<span class="type">int</span> ival1, <span class="type">int</span> ival2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ival1 - ival2;</span><br><span class="line">	<span class="comment">// 返回值被提升为double类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h4 id="用户自定义数据类型间"><a href="#用户自定义数据类型间" class="headerlink" title="用户自定义数据类型间"></a>用户自定义数据类型间</h4><p>使用子类对象代替父类对象是可以的，也是因为隐式类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;<span class="comment">//B是子类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(A&amp; a)</span></span>;</span><br><span class="line">B b;</span><br><span class="line"><span class="built_in">Fun</span>(b);<span class="comment">//使用子类对象代替父类对象是可以的，也是因为隐式类型转换。</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>如果想将当前类类型转换为其他类型的时候，该怎么做呢？C++ 提供了类型转换函数（Type conversion function）来解决这个问题，它只能以成员函数的形式出现，也就是只能出现在类中。类型转换函数的语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><code>operator</code> 是 C++ 关键字，<code>type</code> 是要转换的目标类型，<code>data</code> 是要返回的 type 类型的数据。</p>
<p>因为要转换的目标类型是 type，所以返回值 data 也必须是 type 类型。既然已经知道了要返回 type 类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</p>
<p>类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给 this 指针，这样在函数体内就可以操作当前对象了。</p>
<p>类型转换函数可以看成式转换构造函数的逆，因为转换构造函数能够将其它类型转换为当前类类型，而类型转换函数可以将当前类类型转换为其他类类型。下面看个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(): <span class="built_in">m_real</span>(<span class="number">0.0</span>), <span class="built_in">m_imag</span>(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag): <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="type">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>里面<code>operator</code>那一行，就是类型转换函数，它可以将复数类型转换为double类型，有了它，下面的代码就可以成功运行了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> f = c1;  <span class="comment">//相当于 double f = Complex::operator double(&amp;c1);</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>笔者认为C++是对C补充和更新，首先看C的强制转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(type-id)expression<span class="comment">//转换格式1</span></span><br><span class="line">type-<span class="built_in">id</span>(expression)<span class="comment">//转换格式2</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>c语言强制类型转换主要用于 基础的数据类型间的转换，c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：<code>static_cast、dynamic_cast、const_cast、reinterpret_cast</code>，主要运用于继承关系类间的强制转化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;new_type&gt;      (expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;     (expression) </span><br><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;       (expression) </span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt; (expression)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><code>new_type</code>为目标数据类型，<code>expression</code>为原始数据类型变量或者表达式。对其简单如下表所示：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static_cast</td>
<td>用于良性转换，一般不会导致意外发生，风险很低。</td>
</tr>
<tr>
<td>const_cast</td>
<td>用于 const 与非 const、volatile 与非 volatile 之间的转换。</td>
</tr>
<tr>
<td>reinterpret_cast</td>
<td>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>借助 RTTI，用于类型安全的向下转型（Downcasting）。</td>
</tr>
</tbody></table>
<p>有的书中，将c语言强制类型转换称为旧式转型，c++强制类型转换称为新式转型。</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</p>
<p>static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：</p>
<ul>
<li>原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；</li>
<li>void 指针和具体类型指针之间的转换，例如<code>void *</code>转<code>int *</code>、<code>char *</code>转<code>void *</code>等；</li>
<li>有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。</li>
</ul>
<p>需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：</p>
<ul>
<li>两个具体类型指针之间的转换，例如<code>int *</code>转<code>double *</code>、<code>Student *</code>转<code>int *</code>等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。</li>
<li>int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。</li>
<li>static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 <code>const/volatile</code> 类型转换为非 <code>const/volatile</code> 类型。</li>
</ul>
<p>下面是一些用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是正确的用法</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">100</span>;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">12.5</span>, <span class="number">23.8</span>)</span></span>;</span><br><span class="line"><span class="type">long</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(m);  <span class="comment">//宽转换，没有信息丢失</span></span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(m);  <span class="comment">//窄转换，可能会丢失信息</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;( <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>)) );  <span class="comment">//将void指针转换为具体类型指针</span></span><br><span class="line"><span class="type">void</span> *p2 = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(p1);  <span class="comment">//将具体类型指针，转换为void指针</span></span><br><span class="line"><span class="type">double</span> real= <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(c);  <span class="comment">//调用类型转换函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的用法是错误的</span></span><br><span class="line"><span class="type">float</span> *p3 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(p1);  <span class="comment">//不能在两个具体类型的指针之间进行转换</span></span><br><span class="line">p3 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(<span class="number">0X2DF9</span>);  <span class="comment">//不能将整数转换为指针类型</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const&#x2F;volatile 类型转换为非 const&#x2F;volatile 类型。看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;n);</span><br><span class="line">*p = <span class="number">234</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;n = &quot;</span>&lt;&lt;n&lt;&lt;endl;   <span class="comment">//  n = 100</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;*p = &quot;</span>&lt;&lt;*p&lt;&lt;endl; <span class="comment">//  *p = 234</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><code>&amp;n</code>用来获取 n 的地址，它的类型为<code>const int *</code>，必须使用 const_cast 转换为<code>int *</code>类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。也就是说：p 和<code>&amp;n</code>指向的是相同的地址。</p>
<p>有读者可能会问，为什么通过 n 和 <code>*p</code> 输出的值不一样呢？这是因为 C++ 对常量的处理更像是编译时期的<code>#define</code>，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。换句话说，<code>cout&lt;&lt;&quot;n = &quot;&lt;&lt;n&lt;&lt;endl;</code>这行代码被修改成了<code>cout&lt;&lt;&quot;n = &quot;&lt;&lt;100&lt;&lt;endl;</code></p>
<p>这样以来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了。使用 const_cast 进行强制类型转换可以突破 C&#x2F;C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。</p>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。</p>
<p><code>reinterpret_cast</code> 可以认为是 <code>static_cast</code> 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。</p>
<p>下面的代码代码演示了 reinterpret_cast 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>): <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将 char* 转换为 float*</span></span><br><span class="line">    <span class="type">char</span> str[]=<span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="type">float</span> *p1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>*&gt;(str);</span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;endl;  <span class="comment">//3.0262e+29</span></span><br><span class="line">    <span class="comment">//将 int 转换为 int*</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//将 A* 转换为 int*</span></span><br><span class="line">    p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">25</span>, <span class="number">96</span>));</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl; <span class="comment">//25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将<code>A*</code>转换为<code>int*</code>，使用指针直接访问 <code>private</code> 成员刺穿了一个类的封装性，更好的办法是让类提供 <code>get/set</code> 函数，间接地访问成员变量。</p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p><code>dynamic_cast</code> 与 <code>static_cast</code> 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</p>
<p>dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI （Run Time Type Identification,通过运行时类型识别）进行检测，所有只有一部分能成功。<br>dynamic_cast 的语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span> &lt;newType&gt; (expression)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>newType 和 expression 必须同时是指针类型或者引用类型。换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。</p>
<p>对于指针，如果转换失败将返回 <code>NULL</code>；对于引用，如果转换失败将抛出<code>std::bad_cast</code>异常。</p>
<h4 id="向上转型（Upcasting）"><a href="#向上转型（Upcasting）" class="headerlink" title="向上转型（Upcasting）"></a>向上转型（Upcasting）</h4><p>向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功。因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a = <span class="number">0</span>): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_a</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> m_a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>): <span class="built_in">Base</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_b</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    Derived *pd1 = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">35</span>, <span class="number">78</span>);</span><br><span class="line">    Base *pb1 = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(pd1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd1 = &quot;</span>&lt;&lt;pd1&lt;&lt;<span class="string">&quot;, pb1 = &quot;</span>&lt;&lt;pb1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb1-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;</span><br><span class="line">    pb1-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    Derived *pd2 = <span class="built_in">reinterpret_cast</span>&lt;Derived*&gt;(&amp;n);</span><br><span class="line">    Base *pb2 = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(pd2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd2 = &quot;</span>&lt;&lt;pd2&lt;&lt;<span class="string">&quot;, pb2 = &quot;</span>&lt;&lt;pb2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb2-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;  <span class="comment">//输出一个垃圾值</span></span><br><span class="line">    pb2-&gt;<span class="built_in">func</span>();  <span class="comment">//内存错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure>

<p>情况①是正确的，没有任何问题。对于情况②，pd 指向的是整型变量 n，并没有指向一个 Derived 类的对象，在使用 <code>dynamic_cast</code> 进行类型转换时也没有检查这一点，而是将 pd 的值直接赋给了 pb（这里并不需要调整偏移量），最终导致 pb 也指向了 n。因为 pb 指向的不是一个对象，所以get_a()得不到 m_a 的值（实际上得到的是一个垃圾值），pb2-&gt;func()也得不到 func() 函数的正确地址。</p>
<blockquote>
<p>pb2-&gt;func()得不到 func() 的正确地址的原因在于，pb2 指向的是一个假的“对象”，它没有虚函数表，也没有虚函数表指针，而 func() 是虚函数，必须到虚函数表中才能找到它的地址。</p>
</blockquote>
<h4 id="向下转型（Downcasting）"><a href="#向下转型（Downcasting）" class="headerlink" title="向下转型（Downcasting）"></a>向下转型（Downcasting）</h4><p>向下转型是有风险的，<code>dynamic_cast</code> 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败。那么，哪些向下转型是安全地呢，哪些又是不安全的呢？下面我们通过一个例子来演示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class A&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class B&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class C&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class D&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    B *pb;</span><br><span class="line">    C *pc;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="built_in">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    pa = <span class="keyword">new</span> <span class="built_in">D</span>();  <span class="comment">//向上转型都是允许的</span></span><br><span class="line">    pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="built_in">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273</span></span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Downcasting failed: A* to B*</span><br><span class="line">Downcasting failed: A* to C*</span><br><span class="line">-------------------------</span><br><span class="line">Downcasting successfully: A* to B*</span><br><span class="line">Class D</span><br><span class="line">Downcasting successfully: A* to C*</span><br><span class="line">Class D</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>这段代码中类的继承顺序为：A –&gt; B –&gt; C –&gt; D。pa 是<code>A*</code>类型的指针，当 pa 指向 A 类型的对象时，向下转型失败，pa 不能转换为<code>B*</code>或<code>C*</code>类型。当 pa 指向 D 类型的对象时，向下转型成功，pa 可以转换为<code>B*</code>或<code>C*</code>类型。同样都是向下转型，为什么 pa 指向的对象不同，转换的结果就大相径庭呢？</p>
<p>这是因为：每个类都会在内存中保存一份类型信息，编译器会将存在继承关系的类的类型信息使用指针“连接”起来，从而形成一个继承链（Inheritance Chain），也就是如下图所示的样子：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20210120195837787.png"
                      alt="在这里插入图片描述"
                ><br>当使用 <code>dynamic_cast</code> 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类）的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。</p>
<p>对于本例中的情况①，pa 指向 A 类对象，根据该对象找到的就是 A 的类型信息，当程序从这个节点开始向上遍历时，发现 A 的上方没有要转换的 B 类型或 C 类型（实际上 A 的上方没有任何类型了），所以就转换败了。对于情况②，pa 指向 D 类对象，根据该对象找到的就是 D 的类型信息，程序从这个节点向上遍历的过程中，发现了 C 类型和 B 类型，所以就转换成功了。</p>
<p>总的来说，dynamic_cast 会在程序运行过程中遍历继承链，如果途中遇到了要转换的目标类型，那么就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，那么就转换失败。对于同一个指针（例如 pa），它指向的对象不同，会导致遍历继承链的起点不一样，途中能够匹配到的类型也不一样，所以相同的类型转换产生了不同的结果。</p>
<p>从表面上看起来 dynamic_cast 确实能够向下转型，本例也很好地证明了这一点：B 和 C 都是 A 的派生类，我们成功地将 pa 从 A 类型指针转换成了 B 和 C 类型指针。但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它，这样做始终是安全的。本例中的情况②，pa 指向的对象是 D 类型的，pa、pb、pc 都是 D 的基类的指针，所以它们都可以指向 D 类型的对象，dynamic_cast 只是让不同的基类指针指向同一个派生类对象罢了。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之内存模式</title>
    <url>/2023/03/07/C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++内存分配:</span></span><br><span class="line"><span class="comment">        1.分区</span></span><br><span class="line"><span class="comment">            - 静态区(静态内存): static 变量和函数、全局变量</span></span><br><span class="line"><span class="comment">            - 栈区: 函数、非 static 局部变量, 由程序自动创建、自动释放</span></span><br><span class="line"><span class="comment">            - 堆(动态内存、内存池): new 和 delete</span></span><br><span class="line"><span class="comment">            - 文字常量区: 常量字符串就是放在这里的, 程序结束后由系统释放</span></span><br><span class="line"><span class="comment">            - 程序代码区: 可执行代码</span></span><br><span class="line"><span class="comment">        2.缓冲区</span></span><br><span class="line"><span class="comment">            - 全缓冲区: 当填满标准I/O缓存后才进行实际I/O操作</span></span><br><span class="line"><span class="comment">            - 行缓冲区: 当在输入和输出中遇到换行符时，执行真正的I/O操作</span></span><br><span class="line"><span class="comment">            - 不带缓冲: 不进行缓冲，标准出错情况stderr是典型代表，这使得出错信息可以直接尽快地显示出来</span></span><br><span class="line"><span class="comment">            - 缓冲区刷新: 在内存空间中预留了一定的存储空间用来缓冲输入或输出的数据, 可以减少磁盘的读写次数</span></span><br><span class="line"><span class="comment">                - 缓冲区满时</span></span><br><span class="line"><span class="comment">                - 执行flush语句</span></span><br><span class="line"><span class="comment">                - 执行endl语句</span></span><br><span class="line"><span class="comment">                - 关闭文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    程序执行过程:</span></span><br><span class="line"><span class="comment">        1.预处理: 条件编译，头文件包含，宏替换的处理，生成.i文件</span></span><br><span class="line"><span class="comment">            - cpp Memory.c Memory.i</span></span><br><span class="line"><span class="comment">        2.编译:将预处理后的文件转换成汇编语言，生成.s文件</span></span><br><span class="line"><span class="comment">            - gcc -Og -S Memory.c</span></span><br><span class="line"><span class="comment">        3.汇编: 目标代码(机器代码)生成.o的文件</span></span><br><span class="line"><span class="comment">            - gcc -Og -c Memory.c</span></span><br><span class="line"><span class="comment">        4.链接:连接目标代码,生成可执行程序</span></span><br><span class="line"><span class="comment">            - gcc -Og -o Memory.c</span></span><br><span class="line"><span class="comment">        - 注: 反编译 objdump -d hello.o</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> pi;       <span class="comment">//     全局变量，全局区/静态区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>; <span class="comment">//    程序代码区</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> a;<span class="comment">//      栈区</span></span><br><span class="line">       <span class="type">static</span> <span class="type">int</span> b;<span class="comment">//      静态变量，全局区/静态区</span></span><br><span class="line">       <span class="type">char</span> *c, *d = <span class="string">&quot;hello&quot;</span>;<span class="comment">//    指针本身位于栈 | 指向字符串&quot;hello&quot;位于文字常量区</span></span><br><span class="line">       <span class="type">int</span> *e = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];<span class="comment">//    指针指向的内容位于堆区</span></span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之函数指针</title>
    <url>/2023/03/07/C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  把函数指针作为参数传递给 sum 函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> (*fp)(<span class="type">double</span>), <span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        res += <span class="built_in">fp</span>(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数指针:</span></span><br><span class="line"><span class="comment">      1.函数指针作为参数传递时, 需要在参数中声明它自身的参数和返回值的类型</span></span><br><span class="line"><span class="comment">      2.函数名字本身就是一个指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  传入函数名字</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(f, <span class="number">1</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之多态</title>
    <url>/2023/03/07/C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// virtual void fun() = 0;</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Father say Hi&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Father say Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Father &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Son say Hi&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Son say Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHi</span><span class="params">(Father &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">Say</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">(Father &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    虚函数:</span></span><br><span class="line"><span class="comment">      1.实现: 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针(_vptr, 在构造函数里初始化);虚表是和类对应的，虚表指针是和对象对应的</span></span><br><span class="line"><span class="comment">      2.纯虚函数: 虚函数再加上 = 0, 存在纯虚函数的类为抽象类(接口类)，不能实例化, 子类必须重写纯虚函数</span></span><br><span class="line"><span class="comment">    多态:</span></span><br><span class="line"><span class="comment">      1.作用: 一个接口多种实现</span></span><br><span class="line"><span class="comment">      2.实现:</span></span><br><span class="line"><span class="comment">        - 虚函数-&gt;动态绑定-&gt;运行时多态。通过基类的指针或者引用，在运行时动态调用实际绑定对象函数的行为</span></span><br><span class="line"><span class="comment">        - 重载-&gt;编译时多态</span></span><br><span class="line"><span class="comment">      3.类型</span></span><br><span class="line"><span class="comment">        - 类的多态性</span></span><br><span class="line"><span class="comment">        - 函数的多态性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;</span><br><span class="line">    Father father;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SayHello</span>(son);</span><br><span class="line">    <span class="built_in">SayHello</span>(father);</span><br><span class="line">    <span class="comment">//  实现多态</span></span><br><span class="line">    <span class="built_in">SayHi</span>(son);</span><br><span class="line">    <span class="built_in">SayHi</span>(father);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之构造函数</title>
    <url>/2023/03/07/C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//  使用初始化列表形式</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(string s = <span class="string">&quot;ribincao&quot;</span>, <span class="type">int</span> n = <span class="number">26</span>) : <span class="built_in">name</span>(s), <span class="built_in">age</span>(n) &#123; &#125;</span><br><span class="line">        <span class="comment">//  使用有普通函数的形式</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(string s) &#123;</span><br><span class="line">            name = s;</span><br><span class="line">            age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  拷贝构造函数</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(<span class="type">const</span> BaseClass &amp;v) &#123;</span><br><span class="line">            name = v.name;</span><br><span class="line">            age = v.age;</span><br><span class="line">        &#125;</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    构造函数总结:</span></span><br><span class="line"><span class="comment">      1.概念: 类对象被创建时，编译系统为对象分配内存空间，并自动调用该构造函数-&gt;由构造函数完成成员的初始化工作</span></span><br><span class="line"><span class="comment">      2.作用: 初始化对象的数据成员</span></span><br><span class="line"><span class="comment">      3.类型</span></span><br><span class="line"><span class="comment">        - 默认构造函数: 分为有用的和无用的，无用的默认构造函数就是一个空函数什么操作也不做, 有用的默认构造函数是可以初始化成员的函数</span></span><br><span class="line"><span class="comment">        - 拷贝构造函数: 参数是本类型的一个引用变量(指针), 可实现类型转换</span></span><br><span class="line"><span class="comment">      4.注意: 默认构造函数不要出现歧义, 不要让编译器出现不知道使用哪一个构造函数的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseClass v1;</span><br><span class="line">    <span class="function">BaseClass <span class="title">v2</span><span class="params">(<span class="string">&quot;jack&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    <span class="function">BaseClass <span class="title">v3</span><span class="params">(v1)</span></span>;</span><br><span class="line">    <span class="comment">// BaseClass v4(&quot;bob&quot;); 出现歧义, 编译器不知道使用哪一个构造函数去初始化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v1] name: &quot;</span> &lt;&lt; v1.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v1.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v2] name: &quot;</span> &lt;&lt; v2.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v2.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v3] name: &quot;</span> &lt;&lt; v3.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v3.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之析构函数</title>
    <url>/2023/03/07/C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(string* s, <span class="type">int</span> n) : <span class="built_in">name</span>(s), <span class="built_in">age</span>(n) &#123;&#125;</span><br><span class="line">        <span class="comment">//  name 是指向字符串的指针, 成员占用的内存被释放, 但是字符串占用的内存没有被销毁会导致内存泄漏, 可通过析构函数去释放这部分内存</span></span><br><span class="line">        ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(name != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">free</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        string* name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    析构函数:</span></span><br><span class="line"><span class="comment">      1.时机: 当对象被销毁时去执行</span></span><br><span class="line"><span class="comment">      2.作用: 对象被销毁时，对象所占用的内存会被释放, 但不是与它相关联的所有内存都会销毁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;ribincao&quot;</span>;</span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(&amp;name, <span class="number">26</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之继承</title>
    <url>/2023/03/07/C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BaseClass</span>() &#123; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in BaseClass called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">h</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function g() in BaseClass called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function h() in BaseClass\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1Level1</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> BaseClass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in DerivedLevel1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;Derived1Level1&quot;</span>);</span><br><span class="line">            <span class="built_in">h</span>(<span class="string">&quot;Derived1Level1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Function h() in Derived1Level1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2Level1</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> BaseClass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in Derived2Level1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;Derived2Level1&quot;</span>);</span><br><span class="line">            <span class="comment">// h(); &#x27;h&#x27; is a private member of &#x27;BaseClass&#x27;, 继承是不能访问父类的 private 成员的</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedLevel2</span> : <span class="keyword">public</span> Derived1Level1, <span class="keyword">public</span> Derived2Level1 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in DerivedLevel2 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">            Derived1Level1::<span class="built_in">h</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">            BaseClass::<span class="built_in">f</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    继承总结：</span></span><br><span class="line"><span class="comment">        1. 类和对象是有区别的, 比如类可以访问 protected 成员, 但是该类的对象是不能直接访问 protected 成员</span></span><br><span class="line"><span class="comment">        2. 继承权限</span></span><br><span class="line"><span class="comment">          - public 继承: 父类的 public 和 protected 在子类还是保持</span></span><br><span class="line"><span class="comment">          - protected 继承: 父类的 public 和 protected 在子类变成了 protected</span></span><br><span class="line"><span class="comment">        3. 继承方式</span></span><br><span class="line"><span class="comment">          - 普通继承: 多重继承可能会出现多个基类的副本, 导致二义性问题</span></span><br><span class="line"><span class="comment">          - 虚继承(virtual): 只生成一个基类的副本, 比如下面的继承关系会让 B 和 C 虚继承基类 A</span></span><br><span class="line"><span class="comment">                    A</span></span><br><span class="line"><span class="comment">                   / \</span></span><br><span class="line"><span class="comment">                  B   C</span></span><br><span class="line"><span class="comment">                   \ /</span></span><br><span class="line"><span class="comment">                    D</span></span><br><span class="line"><span class="comment">        关键词: 信息隐藏原则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseClass bc;</span><br><span class="line">    Derived1Level1 d1l1;</span><br><span class="line">    Derived2Level1 d2l1;</span><br><span class="line">    DerivedLevel2 dl2;</span><br><span class="line"></span><br><span class="line">    bc.<span class="built_in">f</span>(<span class="string">&quot;main(1)&quot;</span>);<span class="comment">//  类的 public 成员是可以被类对象访问的</span></span><br><span class="line">    <span class="comment">// bc.g(); 类的 protected 成员是不能被基类对象访问的</span></span><br><span class="line">    <span class="comment">// bc.h(); 类的 private 成员是不能被类对象访问的</span></span><br><span class="line"></span><br><span class="line">    d1l1.<span class="built_in">f</span>(<span class="string">&quot;main(2)&quot;</span>);<span class="comment">//  派生类在 public 继承下可以访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d1l1.g();  派生类对象不能访问父类的 protected 成员</span></span><br><span class="line">    d1l1.<span class="built_in">h</span>(<span class="string">&quot;main(3)&quot;</span>);<span class="comment">//  private 对象是不能被继承的, 派生类访问的是自己的 public 成员</span></span><br><span class="line"></span><br><span class="line">    d2l1.<span class="built_in">f</span>(<span class="string">&quot;main(4)&quot;</span>);<span class="comment">//  派生类在 public 继承下可以访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d2l1.g();  派生类对象不能访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d2l1.h();  private 对象是不能被继承的</span></span><br><span class="line"></span><br><span class="line">    dl2.<span class="built_in">f</span>(<span class="string">&quot;main(5)&quot;</span>);</span><br><span class="line">    <span class="comment">// dl2.g();  派生类对象不能访问父类的 protected 成员, 派生类可以</span></span><br><span class="line">    dl2.<span class="built_in">h</span>();<span class="comment">//  派生类对象可以访问父类的 public 成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之重载</title>
    <url>/2023/03/07/C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Base</span>(<span class="type">int</span> n = <span class="number">18</span>) : <span class="built_in">age</span>(n) &#123;&#125;</span><br><span class="line">        <span class="comment">//  运算符重载</span></span><br><span class="line">        Base <span class="keyword">operator</span>- () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Base</span>(-age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  按照C语言风格编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">float</span> <span class="title">sum</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    重载：</span></span><br><span class="line"><span class="comment">      1.类型</span></span><br><span class="line"><span class="comment">        - 函数重载: 函数名相同但是函数签名不同(形参个数、类型和顺序), 函数签名的实现方式不同是C语言不能实现重载的原因, 编译器编译.c文件只是对函数进行简单的重命名</span></span><br><span class="line"><span class="comment">        - 运算符重载: 本质上是函数重载</span></span><br><span class="line"><span class="comment">      2.作用: 实现静态多态</span></span><br><span class="line"><span class="comment">      3.重载和重写</span></span><br><span class="line"><span class="comment">        - 重载: 是相同的函数名字针对不同的输入进行不同的操作, 函数的签名是不同的</span></span><br><span class="line"><span class="comment">        - 重写: 子类对父类的成员函数进行重新编写来实现不同的表现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  系统会根据实参的类型来实现准确调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1.1</span>, <span class="number">2.2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重载运算符 -</span></span><br><span class="line">    <span class="function">Base <span class="title">v</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (-v).<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之标准库总结</title>
    <url>/2023/03/07/C%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="lt-assert-h-gt"><a href="#lt-assert-h-gt" class="headerlink" title="&lt;assert.h&gt;"></a>&lt;assert.h&gt;</h2><p>assert() 宏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assert</span><span class="params">(<span class="type">int</span> expression)</span></span>;</span><br><span class="line"><span class="comment">//	expression -- 可以是一个变量或任何 C 表达式。如果 expression 为 TRUE，assert() 不执行任何动作。如果 expression 为 FALSE，assert() 会在标准错误 stderr 上显示错误消息，并中止程序执行。</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-ctype-h-gt"><a href="#lt-ctype-h-gt" class="headerlink" title="&lt;ctype.h&gt;"></a>&lt;ctype.h&gt;</h2><p>C 标准库的 <strong>ctype.h</strong> 头文件提供了一些函数，可用于测试和映射字符。</p>
<p>这些函数接受 <strong>int</strong> 作为参数，它的值必须是 EOF 或表示为一个无符号字符。</p>
<p>如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isalnum</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是字母和数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isalpha</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是字母</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">iscntrl</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是控制字符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isdigit</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是十进制数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isgraph</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否有图形表示法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">islower</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是小写字母</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isprint</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是可打印的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ispunct</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是标点符号字符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isspace</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是空白字符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isupper</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	检查所传的字符是否是大写字母</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isxdigit</span><span class="params">(<span class="type">int</span> c)</span></span>;	<span class="comment">//	检查所传的字符是否是十六进制数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tolower</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	把大写字母转换为小写字母</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toupper</span><span class="params">(<span class="type">int</span> c)</span></span>;		<span class="comment">//	把小写字母转换为大写字母</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-errno-h-gt"><a href="#lt-errno-h-gt" class="headerlink" title="&lt;errno.h&gt;"></a>&lt;errno.h&gt;</h2><p>C 标准库的 <strong>errno.h</strong> 头文件定义了整数变量 <strong>errno</strong>，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为 int 的可更改的左值，因此它可以被一个程序读取和修改。</p>
<p>在程序启动时，<strong>errno</strong> 设置为零，C 标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。</p>
<p><strong>errno.h</strong> 头文件定义了一系列表示不同错误代码的宏，这些宏应扩展为类型为 <strong>int</strong> 的整数常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno;					<span class="comment">//	通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOM some_value;	<span class="comment">//	表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERANGE some_value	<span class="comment">//	表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE</span></span></span><br></pre></td></tr></table></figure>

<h2 id="lt-float-h-gt"><a href="#lt-float-h-gt" class="headerlink" title="&lt;float.h&gt;"></a>&lt;float.h&gt;</h2><h2 id="lt-limits-h-gt"><a href="#lt-limits-h-gt" class="headerlink" title="&lt;limits.h&gt;"></a>&lt;limits.h&gt;</h2><p><strong>limits.h</strong> 头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值</p>
<h2 id="lt-locale-h-gt"><a href="#lt-locale-h-gt" class="headerlink" title="&lt;locale.h&gt;"></a>&lt;locale.h&gt;</h2><p><strong>locale.h</strong> 头文件定义了特定地域的设置，比如日期格式和货币符号。接下来我们将介绍一些宏，以及一个重要的结构 <strong>struct lconv</strong> 和两个重要的函数</p>
<h2 id="lt-math-h-gt"><a href="#lt-math-h-gt" class="headerlink" title="&lt;math.h&gt;"></a>&lt;math.h&gt;</h2><p><strong>math.h</strong> 头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 <strong>double</strong> 类型的参数，且都返回 <strong>double</strong> 类型的结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">acos</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回以弧度表示的 x 的反余弦</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">asin</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回以弧度表示的 x 的反正弦</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">atan</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回以弧度表示的 x 的反正切</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">atan2</span><span class="params">(<span class="type">double</span> y, <span class="type">double</span> x)</span></span>;		<span class="comment">//	返回以弧度表示的 y/x 的反正切, y 和 x 的值的符号决定了正确的象限</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cos</span><span class="params">(<span class="type">double</span> x)</span></span>;			<span class="comment">//	返回弧度角 x 的余弦</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cosh</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回 x 的双曲余弦</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sin</span><span class="params">(<span class="type">double</span> x)</span></span>;			<span class="comment">//	返回弧度角 x 的正弦</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sinh</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回 x 的双曲正弦</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">tanh</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回 x 的双曲正切</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">exp</span><span class="params">(<span class="type">double</span> x)</span></span>;			<span class="comment">//	返回 e 的 x 次幂的值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">frexp</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> *exponent)</span></span>;	<span class="comment">//	把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x = mantissa * 2 ^ exponent</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ldexp</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> exponent)</span></span>;		<span class="comment">//	返回 x 乘以 2 的 exponent 次幂</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">log</span><span class="params">(<span class="type">double</span> x)</span></span>;			<span class="comment">//	返回 x 的自然对数（基数为 e 的对数）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">log10</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回 x 的常用对数（基数为 10 的对数）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">modf</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> *integer)</span></span>;	<span class="comment">//	返回值为小数部分（小数点后的部分），并设置 integer 为整数部分</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pow</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>;	<span class="comment">//	返回 x 的 y 次幂</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回 x 的平方根</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ceil</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回大于或等于 x 的最小的整数值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回 x 的绝对值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">floor</span><span class="params">(<span class="type">double</span> x)</span></span>;		<span class="comment">//	返回小于或等于 x 的最大的整数值</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fmod</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>;	<span class="comment">//	返回 x 除以 y 的余数</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-setjmp-h-gt"><a href="#lt-setjmp-h-gt" class="headerlink" title="&lt;setjmp.h&gt;"></a>&lt;setjmp.h&gt;</h2><p><strong>setjmp.h</strong> 头文件定义了宏 **setjmp()**、函数 <strong>longjmp()</strong> 和变量类型 <strong>jmp_buf</strong>，该变量类型会绕过正常的函数调用和返回规则</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> jmp_buf buf;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf environment)</span></span>;	<span class="comment">//	把当前环境保存在变量 environment 中，以便函数 longjmp() 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 longjmp() 函数调用中返回，则它会返回一个非零值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf environment, <span class="type">int</span> value)</span></span>;	<span class="comment">//	恢复最近一次调用 setjmp() 宏时保存的环境，jmp_buf 参数的设置是由之前调用 setjmp() 生成的</span></span><br></pre></td></tr></table></figure>



<h2 id="lt-signal-h-gt"><a href="#lt-signal-h-gt" class="headerlink" title="&lt;signal.h&gt;"></a>&lt;signal.h&gt;</h2><p><strong>signal.h</strong> 头文件定义了一个变量类型 <strong>sig_atomic_t</strong>、两个函数调用和一些宏来处理程序执行期间报告的不同信号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> (*<span class="built_in">signal</span>(<span class="type">int</span> sig, <span class="built_in">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);		<span class="comment">//	设置一个函数来处理信号，即信号处理程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> sig)</span></span>;	<span class="comment">//	促使生成信号 sig。sig 参数与 SIG 宏兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	信号功能</span></span><br><span class="line">SIG_DFL  默认的信号处理程序。</span><br><span class="line">SIG_ERR  表示一个信号错误。</span><br><span class="line">SIG_IGN  忽视信号</span><br><span class="line"></span><br><span class="line"><span class="comment">//	信号码</span></span><br><span class="line">SIGABRT  程序异常终止。</span><br><span class="line">SIGFPE  算术运算出错，如除数为 <span class="number">0</span> 或溢出。</span><br><span class="line">SIGILL  非法函数映象，如非法指令。</span><br><span class="line">SIGINT  中断信号，如 ctrl-C。</span><br><span class="line">SIGSEGV  非法访问存储器，如访问不存在的内存单元。</span><br><span class="line">SIGTERM  发送给本程序的终止请求信号。</span><br></pre></td></tr></table></figure>

<h2 id="lt-stdarg-h-gt"><a href="#lt-stdarg-h-gt" class="headerlink" title="&lt;stdarg.h&gt;"></a>&lt;stdarg.h&gt;</h2><p><strong>stdarg.h</strong> 头文件定义了一个变量类型 <strong>va_list</strong> 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。</p>
<p>可变参数的函数通在参数列表的末尾是使用省略号(,…)定义的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">va_start</span><span class="params">(va_list ap, last_arg)</span></span>;		<span class="comment">//	初始化 ap 变量，它与 va_arg 和 va_end 宏是一起使用的。last_arg 是最后一个传递给函数的已知的固定参数，即省略号之前的参数</span></span><br><span class="line"><span class="function">type <span class="title">va_arg</span><span class="params">(va_list ap, type)</span></span>;					<span class="comment">//	检索函数参数列表中类型为 type 的下一个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">va_end</span><span class="params">(va_list ap)</span></span>;								<span class="comment">//	允许使用了 va_start 宏的带有可变参数的函数返回。如果在从函数返回之前没有调用 va_end，则结果为未定义</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-stddef-h-gt"><a href="#lt-stddef-h-gt" class="headerlink" title="&lt;stddef.h&gt;"></a>&lt;stddef.h&gt;</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	变量类型</span></span><br><span class="line"><span class="type">ptrdiff_t</span>  这是有符号整数类型，它是两个指针相减的结果。</span><br><span class="line"><span class="type">size_t</span>  	 这是无符号整数类型，它是 <span class="keyword">sizeof</span> 关键字的结果。</span><br><span class="line"><span class="type">wchar_t</span>    这是一个宽字符常量大小的整数类型</span><br><span class="line">  </span><br><span class="line"><span class="literal">NULL</span>	空指针常量的值</span><br><span class="line"><span class="built_in">offsetof</span>(type, member-designator);	<span class="comment">//	生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-stdio-h-gt"><a href="#lt-stdio-h-gt" class="headerlink" title="&lt;stdio.h&gt;"></a>&lt;stdio.h&gt;</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	关闭流 stream。刷新所有的缓冲区。</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	清除给定流 stream 的文件结束和错误标识符。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	测试给定流 stream 的文件结束标识符。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	测试给定流 stream 的错误标识符。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	刷新流 stream 的输出缓冲区。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *pos)</span></span>;</span><br><span class="line">	获取流 stream 的当前文件位置，并把它写入到 pos。</span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span>;</span><br><span class="line">	使用给定的模式 mode 打开 filename 所指向的文件。</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line">	从给定流 stream 读取数据到 ptr 所指向的数组中。</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span></span>;</span><br><span class="line">	把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span></span>;</span><br><span class="line">	设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span></span>;</span><br><span class="line">	设置给定流 stream 的文件位置为给定的位置。参数 pos 是由函数 fgetpos 给定的位置。</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	返回给定流 stream 的当前文件位置。</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span>;</span><br><span class="line">	把 ptr 所指向的数组中的数据写入到给定流 stream 中。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span></span>;</span><br><span class="line">	删除给定的文件名 filename，以便它不再被访问。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *old_filename, <span class="type">const</span> <span class="type">char</span> *new_filename)</span></span>;</span><br><span class="line">	把 old_filename 所指向的文件名改为 new_filename。</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	设置文件位置为给定流 stream 的文件的开头。</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buffer)</span></span>;</span><br><span class="line">	定义流 stream 应如何缓冲。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buffer, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line">	另一个定义流 stream 应如何缓冲的函数。</span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	以二进制更新模式(wb+)创建临时文件。</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line">	生成并返回一个有效的临时文件名，该文件名之前是不存在的。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">	发送格式化输出到流 stream 中。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">	发送格式化输出到标准输出 stdout。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">	发送格式化输出到字符串。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span>;</span><br><span class="line">	使用参数列表发送格式化输出到流 stream 中。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span>;</span><br><span class="line">	使用参数列表发送格式化输出到标准输出 stdout。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span>;</span><br><span class="line">	使用参数列表发送格式化输出到字符串。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">	从流 stream 读取格式化输入。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">	从标准输入 stdin 读取格式化输入。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">	从字符串读取格式化输入。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span></span>;</span><br><span class="line">	从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n<span class="number">-1</span>) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span></span>;</span><br><span class="line">	把参数 <span class="type">char</span> 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span></span>;</span><br><span class="line">	把字符串写入到指定的流 stream 中，但不包括空字符。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">	从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getchar</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">	从标准输入 stdin 获取一个字符（一个无符号字符）。</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">gets</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line">	从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span></span>;</span><br><span class="line">	把参数 <span class="type">char</span> 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">putchar</span><span class="params">(<span class="type">int</span> <span class="type">char</span>)</span></span>;</span><br><span class="line">	把参数 <span class="type">char</span> 指定的字符（一个无符号字符）写入到标准输出 stdout 中。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line">	把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ungetc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span></span>;</span><br><span class="line">	把字符 <span class="type">char</span>（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符。</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line">	把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line">格式字符串到 str 中。</span><br></pre></td></tr></table></figure>

<h2 id="lt-stdlib-h-gt"><a href="#lt-stdlib-h-gt" class="headerlink" title="&lt;stdlib.h&gt;"></a>&lt;stdlib.h&gt;</h2><p><strong>stdlib .h</strong> 头文件定义了四个变量类型、一些宏和各种通用工具函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span>	<span class="comment">//	这是无符号整数类型，它是 sizeof 关键字的结果。</span></span><br><span class="line"><span class="type">wchar_t</span>	<span class="comment">//	这是一个宽字符常量大小的整数类型。</span></span><br><span class="line"><span class="type">div_t</span>		<span class="comment">//	这是 div 函数返回的结构。</span></span><br><span class="line"><span class="type">ldiv_t</span>	<span class="comment">//	这是 ldiv 函数返回的结构。</span></span><br><span class="line">  </span><br><span class="line"><span class="literal">NULL</span>	<span class="comment">//这个宏是一个空指针常量的值。</span></span><br><span class="line">EXIT_FAILURE	<span class="comment">//	这是 exit 函数失败时要返回的值。</span></span><br><span class="line">EXIT_SUCCESS	<span class="comment">//	这是 exit 函数成功时要返回的值。</span></span><br><span class="line">RAND_MAX			<span class="comment">//	这个宏是 rand 函数返回的最大值。</span></span><br><span class="line">MB_CUR_MAX		<span class="comment">//	这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function">把参数 str 所指向的字符串转换为一个浮点数（类型为 <span class="type">double</span> 型）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function">把参数 str 所指向的字符串转换为一个整数（类型为 <span class="type">int</span> 型）。</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function">把参数 str 所指向的字符串转换为一个长整数（类型为 <span class="type">long</span> <span class="type">int</span> 型）。</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">strtod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr)</span></span></span><br><span class="line"><span class="function">把参数 str 所指向的字符串转换为一个浮点数（类型为 <span class="type">double</span> 型）。</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span></span></span><br><span class="line"><span class="function">把参数 str 所指向的字符串转换为一个长整数（类型为 <span class="type">long</span> <span class="type">int</span> 型）。</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">strtoul</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span></span></span><br><span class="line"><span class="function">把参数 str 所指向的字符串转换为一个无符号长整数（类型为 <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> 型）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">calloc</span><span class="params">(<span class="type">size_t</span> nitems, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">分配所需的内存空间，并返回一个指向它的指针。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function">释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">分配所需的内存空间，并返回一个指向它的指针。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">使一个异常程序终止。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span></span><br><span class="line"><span class="function">当程序正常终止时，调用指定的函数 func。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function">使程序正常终止。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function">搜索 name 所指向的环境字符串，并返回相关的值给字符串。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *string)</span></span></span><br><span class="line"><span class="function">由 string 指定的命令传给要被命令处理器执行的主机环境。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">bsearch</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *base, <span class="type">size_t</span> nitems, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span></span></span><br><span class="line"><span class="function">执行二分查找。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nitems, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span>*))</span></span></span><br><span class="line"><span class="function">数组排序。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">返回 x 的绝对值。</span></span><br><span class="line"><span class="function"><span class="type">div_t</span> <span class="title">div</span><span class="params">(<span class="type">int</span> numer, <span class="type">int</span> denom)</span></span></span><br><span class="line"><span class="function">分子除以分母。</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">labs</span><span class="params">(<span class="type">long</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">返回 x 的绝对值。</span></span><br><span class="line"><span class="function"><span class="type">ldiv_t</span> <span class="title">ldiv</span><span class="params">(<span class="type">long</span> <span class="type">int</span> numer, <span class="type">long</span> <span class="type">int</span> denom)</span></span></span><br><span class="line"><span class="function">分子除以分母。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">返回一个范围在 0 到 RAND_MAX 之间的伪随机数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span></span><br><span class="line"><span class="function">该函数播种由函数 rand 使用的随机数发生器。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mblen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">返回参数 str 所指向的多字节字符的长度。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">mbstowcs</span><span class="params">(<span class="type">schar_t</span> *pwcs, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mbtowc</span><span class="params">(<span class="type">whcar_t</span> *pwc, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">检查参数 str 所指向的多字节字符。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">wcstombs</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">wchar_t</span> *pwcs, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">把数组 pwcs 中存储的编码转换为多字节字符，并把它们存储在字符串 str 中。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wctomb</span><span class="params">(<span class="type">char</span> *str, <span class="type">wchar_t</span> wchar)</span></span></span><br><span class="line"><span class="function">检查对应于参数 wchar 所给出的多字节字符的编码</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-string-h-gt"><a href="#lt-string-h-gt" class="headerlink" title="&lt;string.h&gt;"></a>&lt;string.h&gt;</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">把 str1 和 str2 的前 n 个字节进行比较。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">从 src 复制 n 个字符到 dest。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">另一个用于从 src 复制 n 个字符到 dest 的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span></span><br><span class="line"><span class="function">把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span></span><br><span class="line"><span class="function">把 str1 所指向的字符串和 str2 所指向的字符串进行比较。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">把 str1 和 str2 进行比较，最多比较前 n 个字节。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span></span><br><span class="line"><span class="function">把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span></span><br><span class="line"><span class="function">把 src 所指向的字符串复制到 dest。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">把 src 所指向的字符串复制到 dest，最多复制 n 个字符。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strcspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span></span><br><span class="line"><span class="function">检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strerror</span><span class="params">(<span class="type">int</span> errnum)</span></span></span><br><span class="line"><span class="function">从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function">计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span></span><br><span class="line"><span class="function">检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span></span><br><span class="line"><span class="function">检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span></span></span><br><span class="line"><span class="function">在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span></span></span><br><span class="line"><span class="function">分解字符串 str 为一组字符串，delim 为分隔符。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strxfrm</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-time-h-gt"><a href="#lt-time-h-gt" class="headerlink" title="&lt;time.h&gt;"></a>&lt;time.h&gt;</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> 是无符号整数类型，它是 <span class="keyword">sizeof</span> 关键字的结果。</span><br><span class="line"><span class="type">clock_t</span> 这是一个适合存储处理器时间的类型。</span><br><span class="line"><span class="type">time_t</span> is 这是一个适合存储日历时间类型。</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">   <span class="type">int</span> tm_sec;         <span class="comment">/* 秒，范围从 0 到 59        */</span></span><br><span class="line">   <span class="type">int</span> tm_min;         <span class="comment">/* 分，范围从 0 到 59        */</span></span><br><span class="line">   <span class="type">int</span> tm_hour;        <span class="comment">/* 小时，范围从 0 到 23        */</span></span><br><span class="line">   <span class="type">int</span> tm_mday;        <span class="comment">/* 一月中的第几天，范围从 1 到 31    */</span></span><br><span class="line">   <span class="type">int</span> tm_mon;         <span class="comment">/* 月，范围从 0 到 11        */</span></span><br><span class="line">   <span class="type">int</span> tm_year;        <span class="comment">/* 自 1900 年起的年数        */</span></span><br><span class="line">   <span class="type">int</span> tm_wday;        <span class="comment">/* 一周中的第几天，范围从 0 到 6    */</span></span><br><span class="line">   <span class="type">int</span> tm_yday;        <span class="comment">/* 一年中的第几天，范围从 0 到 365    */</span></span><br><span class="line">   <span class="type">int</span> tm_isdst;       <span class="comment">/* 夏令时                */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="literal">NULL</span>	这个宏是一个空指针常量的值。</span><br><span class="line">CLOCKS_PER_SEC	这个宏表示每秒的处理器时钟个数。</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span></span><br><span class="line"><span class="function">返回一个指向字符串的指针，它代表了结构 timeptr 的日期和时间。</span></span><br><span class="line"><span class="function"><span class="type">clock_t</span> <span class="title">clock</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timer)</span></span></span><br><span class="line"><span class="function">返回一个表示当地时间的字符串，当地时间是基于参数 timer。</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time2)</span></span></span><br><span class="line"><span class="function">返回 time1 和 time2 之间相差的秒数 <span class="params">(time1-time2)</span>。</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timer)</span></span></span><br><span class="line"><span class="function">timer 的值被分解为 tm 结构，并用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timer)</span></span></span><br><span class="line"><span class="function">timer 的值被分解为 tm 结构，并用本地时区表示。</span></span><br><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">mktime</span><span class="params">(<span class="keyword">struct</span> tm *timeptr)</span></span></span><br><span class="line"><span class="function">把 timeptr 所指向的结构转换为一个依据本地时区的 <span class="type">time_t</span> 值。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strftime</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span></span><br><span class="line"><span class="function">根据 format 中定义的格式化规则，格式化结构 timeptr 表示的时间，并把它存储在 str 中。</span></span><br><span class="line"><span class="function"><span class="type">time_t</span> <span class="title">time</span><span class="params">(<span class="type">time_t</span> *timer)</span></span></span><br><span class="line"><span class="function">计算当前日历时间，并把它编码成 <span class="type">time_t</span> 格式</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++| 基础学习之IO多路复用</title>
    <url>/2023/03/07/I-O%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><img  
                     lazyload
                     alt="image"
                     data-src="http://km.oa.com/files/photos/pictures/819/379987bf90e3f681400318ab3923d_w951_h265.png"
                      alt="img"
                ></p>
<p>  当我们创建一个套接字的时候，内核都会为每一个套接字创建一个接收缓冲区和发送缓冲区。通过read系统调用，我们可以通过一个buf把接收缓冲区里的数据写入用户空间，同样通过write系统调用我们也可以将数据写入发送缓冲区里。这样就会出现四种情况：</p>
<ul>
<li>发起read系统调用，但是接收缓冲区为空，就会造成读阻塞事件</li>
<li>发起read系统调用，接收缓冲区变成非空了，就会触发可读事件</li>
<li>当发起write系统调用，但是发送缓冲区满(对端没有返回数据确认，发送缓冲区不会丢弃数据)，救护触发写阻塞事件</li>
<li>发起write系统调用，发送缓冲区有空未知，就会触发可写事件</li>
</ul>
<p>在这里首先得理清楚同步异步和阻塞非阻塞的区别：</p>
<ul>
<li>同步&#x2F;异步描述的是一种消息通信机制，比如A去找B拿快递，同步就是无论快递到没到A都需要等待B的答复才能离开，而异步就是A可以先忙自己的，等B有答复了再通知A</li>
<li>阻塞&#x2F;非阻塞描述的是一种状态</li>
</ul>
<p>如果出现阻塞会造成什么影响呢？</p>
<hr>
<p> ## I&#x2F;O复用</p>
<p>  我们将上图进行抽象，假设我们有多个需要监听的文件描述符，用户就会因为阻塞在其中某一个文件描述符的系统调用上而感知不到其他socket事件。比如在网络编程教材里的echo例子里，如果服务进程被杀死返回FIN给客户端，但是客户进程正阻塞于stdin，它将看不到这个EOF，直到从套接字读时为止。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="http://km.oa.com/files/photos/pictures/dc4/4d4eeccc19609680dd5ff96c0cfb8_w930_h416.png"
                      alt="img"
                ></p>
<p>  在这种情况下，进程就需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I&#x2F;O条件就绪它就通知进程，这种能力就叫做I&#x2F;O复用。</p>
<p>### select&#x2F;poll</p>
<p>  最开始，我们都是使用select&#x2F;poll去实现I&#x2F;O复用，它的原理就是寻找一个代理去帮助用户对多个套接字进行监控。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="http://km.oa.com/files/photos/pictures/2e6/5878b60e398c5f61d619c1cffabe4_w600_h360.png"
                      alt="img"
                ></p>
<p>通过select或者poll去代替自己检测多个套接字的事件，一旦检测到里事件发生就通知进程。select&#x2F;poll有一个不好的地方就是当其中有一个套接字触发里事件，每次都要将所有监听的描述符集合从内核拷贝给用户且不明确告诉进程具体是哪些描述符有事件发生，这样进程还得重新遍历一遍描述符集合。apache用的就是select。</p>
<p>### epoll</p>
<p>  epoll相对于select就显的聪明多了，epoll虽然也是中间代理去监听描述符事件，但是它每次都是返回有事件的文件描述符，比如在redis里就是使用红黑树结构去组织需要关注的描述符事件，一旦有事件触发就会把该事件放入一个双向链表，并将链表里的事件返回给进程</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="http://km.oa.com/files/photos/pictures/9ba/d1d214d83f52d9eb757944cddb382_w698_h401.png"
                      alt="img"
                ></p>
<p>## 对比</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>aws| ubuntu安装基本环境</title>
    <url>/2023/03/11/aws-ubuntu%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>今天在aws上租了一台ubuntu v22的服务器,在服务器上装自己需要的软件时踩了一些坑,不过最终都安装好了自己的一些基本开发环境,一些基本的安装命令大概如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install python</span></span><br><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt update·</span><br><span class="line">sudo apt install python3.11</span><br><span class="line">python3 --version</span><br><span class="line">sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.11 2</span><br><span class="line">sudo update-alternatives --config python3</span><br><span class="line">python3 --version</span><br><span class="line">sudo apt install python3-pip</span><br><span class="line">pip3 --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install protobuf</span></span><br><span class="line">pip3 install google-cloud</span><br><span class="line">pip3 install google-cloud-vision</span><br><span class="line">sudo apt install protobuf-compiler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install golang</span></span><br><span class="line">sudo add-apt-repository ppa:longsleep/golang-backports</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install golang-1.17·</span><br><span class="line">sudo snap install go  --classic</span><br><span class="line">go version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install docker</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line">sudo apt install apt-transport-https curl</span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add</span><br><span class="line">echo &quot;deb https://apt.kubernetes.io/ kubernetes-xenial main&quot; &gt;&gt; ~/kubernetes.list</span><br><span class="line">sudo mv ~/kubernetes.list /etc/apt/sources.list.d</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install kubelet</span><br><span class="line">sudo apt install kubeadm</span><br><span class="line">sudo apt install kubectl</span><br><span class="line">sudo apt-get install -y kubernetes-cni</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">install nodejs &amp; npm</span></span><br><span class="line">curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">sudo npm install -g hexo</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外git改成了用ssh登陆，方式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;njucaolibin@163.com&quot; # 生成我的公钥和私钥,在~/.ssh目录里,把公钥复制到github上就行了</span><br><span class="line">git clone xxx  # 采用ssh的方式去clone仓库</span><br></pre></td></tr></table></figure>
<p>现有的通过https拉取的仓库改成ssh只要把.git&#x2F;config文件里的url替换成ssh链接就行,子模块则是修改.gitmodule里对应的url.</p>
]]></content>
      <tags>
        <tag>aws</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>bug| UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte 0xa4 in position 48: illegal multibyte sequence</title>
    <url>/2023/03/02/bug-UnicodeDecodeError-%E2%80%98gbk%E2%80%98-codec-can%E2%80%98t-decode-byte-0xa4-in-position-48-illegal-multibyte-sequence/</url>
    <content><![CDATA[<p>原因：<br>在用python读取文件，尤其是中文文件的时候会出现这种错误，错误里提示gbk国标的编码不能进行解码，所以可以判断这里是读取器文件是的编码方式无法识别。<br>解决：<br>将源码读取文件的地方添加参数&#96;encoding&#x3D;”utf-8”就行了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ret = f.readlines()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>go| MIT-6.824 MapReduce实验</title>
    <url>/2023/03/02/go-MapReduce%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>阅读论文《MapReduce: Simplified Data Processing on Large Cluster 》。<br>最好准备一个unix环境，本人是在自己的腾讯云服务器上进行的实验，使用的是ubuntu系统，安装好golang，将实验代码拉到本地并命名为6.824(可以自己起别的名字)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://g.csail.mit.edu/6.824-golabs-2018 6.824</span><br></pre></td></tr></table></figure>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>本实验是第一个实验lab-1，也就是<code>map_reduce</code>实验，所以这里主要用到的是<code>mapreduce</code>文件夹下的代码。<br>先从<code>test_test.go</code>文件看起，这个文件除了已经编写好的<code>MapFun</code>和<code>ReduceFun</code>函数外，主要是用来最后进行测试的，其中有<code>TestSequentialSingle</code>、<code>TestSequentialMany</code>、<code>TestParallelBasic</code>、<code>TestParallelCheck</code>、<code>TestOneFailure</code>和<code>TestManyFailures</code>六个测试函数，当编写完自己的代码后可以在<code>mapreduce</code>目录下通过如下命令进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test -run TestSequentialSingle</span><br></pre></td></tr></table></figure>
<p>或者使用如下命令对代码中以Test开头的函数全部进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure>
<p>再来看<code>common_map.go</code>和<code>common_reduce.go</code>文件，这两个文件是这次实验的核心，也是本次实验需要编写的文件，如果顺利的话编写完这两个文件就可以测试<code>TestSequentialSingle</code>、<code>TestSequentialMany</code>检查是否成功<br>最后再来看一下<code>schedule.go</code>文件，这个是用来实现并发调度的核心的代码，也是本次实验需要编写的代码。</p>
<h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><ol>
<li><code>common_map.go</code>里的<code>doMap</code>函数增加代码如下<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Your code here (Part I).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	1. 读取文件</span></span><br><span class="line">file, errOpenFile := os.OpenFile(inFile, os.O_RDONLY, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> errOpenFile != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;open file failure &quot;</span>, errOpenFile)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">FileContent, errReadFile := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> errReadFile != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Read file failure &quot;</span>, errReadFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	2. 进行 map 处理</span></span><br><span class="line">ReduceKeyValue := mapF(inFile, <span class="type">string</span>(FileContent))</span><br><span class="line"></span><br><span class="line"><span class="comment">//	3. 根据&lt;job_name, map_id, reduce_id&gt;生成中间文件</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; nReduce;i++ &#123;</span><br><span class="line">	ReduceName := reduceName(jobName, mapTask, i)</span><br><span class="line">	mapOutFile, errOutFile := os.OpenFile(ReduceName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> errOutFile != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(ReduceName, <span class="string">&quot;output file open failure &quot;</span>, errOutFile)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	encoder := json.NewEncoder(mapOutFile)</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> ReduceKeyValue &#123;</span><br><span class="line">		<span class="keyword">if</span> ihash(value.Key) % nReduce == i &#123;</span><br><span class="line">			err := encoder.Encode(&amp;value)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;File write failure&quot;</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mapOutFile.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>common_reduce.go</code>里的<code>doReduce</code>函数增加代码如下<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Your code here (Part I).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	1. 根据&lt;job_name, map_id, reduce_id&gt;依次读取中间文件塞到reduceData里</span></span><br><span class="line"><span class="keyword">var</span> reduceData []KeyValue</span><br><span class="line"><span class="keyword">var</span> ReduceInputFileName <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; nMap;i++ &#123;</span><br><span class="line">	ReduceInputFileName = reduceName(jobName, i, reduceTask)</span><br><span class="line">	file, errOpenFile := os.Open(ReduceInputFileName)</span><br><span class="line">	<span class="keyword">if</span> errOpenFile != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Open reduce file failure &quot;</span>, errOpenFile)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	decoder := json.NewDecoder(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> v KeyValue</span><br><span class="line">		errDecode := decoder.Decode(&amp;v)</span><br><span class="line">		<span class="keyword">if</span> errDecode != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		reduceData = <span class="built_in">append</span>(reduceData, v)</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	2. 对 reduceData 进行排序</span></span><br><span class="line"><span class="keyword">var</span> sortReduceData keyValues = reduceData[:]</span><br><span class="line">sort.Sort(sortReduceData)</span><br><span class="line"></span><br><span class="line"><span class="comment">//	3. 把相同的 Key 对应的 value 放一起然后进行 reduce</span></span><br><span class="line">ReduceOutFile, errOutput := os.OpenFile(outFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> errOutput != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;output file open failure &quot;</span>, errOutput)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ReduceOutFile.Close()</span><br><span class="line">encoder := json.NewEncoder(ReduceOutFile)</span><br><span class="line"><span class="keyword">var</span> dataForPerKey []<span class="type">string</span></span><br><span class="line">key := sortReduceData[<span class="number">0</span>].Key</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> sortReduceData &#123;</span><br><span class="line">	<span class="keyword">if</span> value.Key == key &#123;</span><br><span class="line">		dataForPerKey = <span class="built_in">append</span>(dataForPerKey, value.Value)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		out := reduceF(key, dataForPerKey)</span><br><span class="line">		encoder.Encode(KeyValue&#123;key, out&#125;)</span><br><span class="line"></span><br><span class="line">		key = value.Key</span><br><span class="line">		dataForPerKey = dataForPerKey[:<span class="number">0</span>]</span><br><span class="line">		dataForPerKey = <span class="built_in">append</span>(dataForPerKey, value.Key)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	最后避免漏网之鱼2333</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dataForPerKey) &gt; <span class="number">0</span> &#123;</span><br><span class="line">	out := reduceF(key, dataForPerKey)</span><br><span class="line">	encoder.Encode(KeyValue&#123;key, out&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
完成这两步代码的编写后就可以进行如下两个串行执行的测试了，在终端输入如下命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test -run TestSequentialSingle</span><br><span class="line">go test -run TestSequentialMany</span><br></pre></td></tr></table></figure>
不出意外会出现如下结果<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">master: Starting Map/Reduce task test</span><br><span class="line">Merge: read mrtmp.test-res-0</span><br><span class="line">master: Map/Reduce task completed</span><br><span class="line">PASS</span><br><span class="line">ok      _/home/ribincao/Learn/6.824labs/src/mapreduce   1.653s</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">master: Starting Map/Reduce task test</span><br><span class="line">Merge: read mrtmp.test-res-0</span><br><span class="line">Merge: read mrtmp.test-res-1</span><br><span class="line">Merge: read mrtmp.test-res-2</span><br><span class="line">master: Map/Reduce task completed</span><br><span class="line">PASS</span><br><span class="line">ok      _/home/ribincao/Learn/6.824labs/src/mapreduce   2.260s</span><br></pre></td></tr></table></figure></li>
<li>在<code>main</code>目录下的<code>wc.go</code>文件的函数<code>mapF</code>和<code>reduceF</code>中增加代码<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="type">string</span>, contents <span class="type">string</span>)</span></span> []mapreduce.KeyValue &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span> <span class="params">(c <span class="type">rune</span>)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> temp = strings.FieldsFunc(contents,f)</span><br><span class="line">	<span class="keyword">var</span> ret []mapreduce.KeyValue</span><br><span class="line">	<span class="keyword">for</span> _,value := <span class="keyword">range</span> temp&#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, mapreduce.KeyValue&#123;Key:value,Value:<span class="string">&quot;1&quot;</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="type">string</span>, values []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(values) == <span class="number">0</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;values = 0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line">	<span class="keyword">var</span> ret <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _,v := <span class="keyword">range</span> values&#123;</span><br><span class="line">		Int,err := strconv.Atoi(v)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;v is not a numbet&quot;</span>,v)</span><br><span class="line">		&#125;</span><br><span class="line">		count += Int</span><br><span class="line">	&#125;</span><br><span class="line">	ret = strconv.Itoa(count)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>schedule.go</code>里的<code>schedule</code>函数增加如下代码<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> threadMaster sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; ntasks;i++ &#123;</span><br><span class="line">	<span class="comment">//	一个 master 并发分配任务给 worker </span></span><br><span class="line">	threadMaster.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(inputFile <span class="type">string</span>, TaskNumber <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">//	registerChan 相当于一个 worker 队列, worker 出队完成 map 或者 reduce 任务之后入队</span></span><br><span class="line">			rpcAdr := &lt;- registerChan</span><br><span class="line">			ok := call(rpcAdr, <span class="string">&quot;Worker.DoTask&quot;</span>, DoTaskArgs&#123;</span><br><span class="line">				JobName: jobName,</span><br><span class="line">				File:	inputFile,</span><br><span class="line">				Phase: phase,</span><br><span class="line">				TaskNumber: TaskNumber,</span><br><span class="line">				NumOtherPhase: n_other,</span><br><span class="line">			&#125;, <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> ok &#123;</span><br><span class="line">				<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">					<span class="comment">//	完成了就通知当前 worker 可用</span></span><br><span class="line">					registerChan &lt;- rpcAdr</span><br><span class="line">				&#125;()</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		threadMaster.Done()</span><br><span class="line">	&#125;(mapFiles[i], i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Schedule: %v done\n&quot;</span>, phase)</span><br><span class="line">threadMaster.Wait()</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>最后可以完整的测试一遍，终端运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test</span><br></pre></td></tr></table></figure>
<p>成功的话会出现下面的结果(太多只截取部分内容)</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">/var/tmp/824-1001/mr31752-worker2: given reducePhase task #9 on file 824-mrinput-9.txt (nios: 20)</span><br><span class="line">/var/tmp/824-1001/mr31752-worker3: reducePhase task #8 done</span><br><span class="line">/var/tmp/824-1001/mr31752-worker2: reducePhase task #9 done</span><br><span class="line">Master: RPC /var/tmp/824-1001/mr31752-worker1 shutdown error</span><br><span class="line">Master: RPC /var/tmp/824-1001/mr31752-worker0 shutdown error</span><br><span class="line">Merge: read mrtmp.test-res-0</span><br><span class="line">Merge: read mrtmp.test-res-1</span><br><span class="line">Merge: read mrtmp.test-res-2</span><br><span class="line">Merge: read mrtmp.test-res-3</span><br><span class="line">Merge: read mrtmp.test-res-4</span><br><span class="line">Merge: read mrtmp.test-res-5</span><br><span class="line">Merge: read mrtmp.test-res-6</span><br><span class="line">Merge: read mrtmp.test-res-7</span><br><span class="line">Merge: read mrtmp.test-res-8</span><br><span class="line">Merge: read mrtmp.test-res-9</span><br><span class="line">/var/tmp/824-1001/mr31752-master: Map/Reduce task completed</span><br><span class="line">PASS</span><br><span class="line">ok      _/home/ribincao/Learn/6.824labs/src/mapreduce   11.113s</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>js| 实现一个简单的webrtc</title>
    <url>/2023/03/09/js-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84webrtc/</url>
    <content><![CDATA[<p>之前在一家公司工作了一段时间,主要负责音视频的开发,因为要用到webrtc就抽空学习了一下webrtc,写了一个简单的demo来帮助我理解大概的流程.<br>代码仓库：<a class="link"   href="https://github.com/ribincao/ribin-webrtc-demo" >https://github.com/ribincao/ribin-webrtc-demo<i class="fas fa-external-link-alt"></i></a></p>
<p>使用方法很简单,安装好nodejs后拉下仓库执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">node index.js</span><br></pre></td></tr></table></figure>

<p>然后在网页打开<a href="https://localhost:8081打开音视频权限就行了">https://localhost:8081打开音视频权限就行了</a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>webrtc</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes| 查看pod日志</title>
    <url>/2023/03/01/kubernetes-%E6%9F%A5%E7%9C%8Bpod%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前在线上出现一个奇怪的问题,容器总是莫名奇妙的崩溃找不到原因.为了排查问题需要去查询日志,loghub上的日志时序看着很奇怪,不太方便查看上下文去排查.所以就想着去开一个pod动态看日志直到pod崩溃就比较方便了.</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>本地动态查看pod日志需要先切到对应的vpc,先查看pod信息获取podid以及对应的容器id</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br><span class="line"></span><br><span class="line">kubectl logs &lt;pod_id&gt; -c &lt;container_id&gt;</span><br><span class="line">kubectl logs --follow &lt;pod_id&gt; -c &lt;container_id&gt;</span><br></pre></td></tr></table></figure>
<p>当然也可以加上<code>-n</code>命令去带上namespace</p>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes| fluent-bit日志采集系统配置</title>
    <url>/2023/02/28/kubernetes/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>排查问题的时候,loghub上的日志是混在一起的,我们希望日志能有一个标签去定位对应的pod,然后通过pod去检索出对应的日志方便我们查看上下文.<br>这个时候就要去集群管理页面上去修改对应的fluent-bit配置就行,我们这里的集群管理用的是rancher,登录rancher选择storage-&gt;ConfigMaps-&gt;fluent-bit-&gt;EditConfig.<br>修改配置如下:</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>custom_parsers.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[PARSER]</span><br><span class="line">    Name docker_no_time</span><br><span class="line">    Format json</span><br><span class="line">    Time_Keep Off</span><br><span class="line">    Time_Key time</span><br><span class="line">    Time_Format %Y-%m-%dT%H:%M:%S.%L</span><br><span class="line"></span><br><span class="line">[PARSER]</span><br><span class="line">    Name                container_firstline</span><br><span class="line">    Format              regex</span><br><span class="line">    Regex               (?&lt;log&gt;(?&lt;=&quot;log&quot;:&quot;)\S(?!\.).*?)(?&lt;!\\)&quot;.*(?&lt;stream&gt;(?&lt;=&quot;stream&quot;:&quot;).*?)&quot;.*(?&lt;time&gt;\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;T\d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;\.\w*).*(?=&#125;)</span><br><span class="line">    Time_Key            time</span><br><span class="line">    Time_Format         %Y-%m-%dT%H:%M:%S.%LZ</span><br></pre></td></tr></table></figure>

<p>fluent-bit.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[SERVICE]</span><br><span class="line">    Daemon Off</span><br><span class="line">    Flush 1</span><br><span class="line">    Log_Level info</span><br><span class="line">    Parsers_File parsers.conf</span><br><span class="line">    Parsers_File custom_parsers.conf</span><br><span class="line">    HTTP_Server On</span><br><span class="line">    HTTP_Listen 0.0.0.0</span><br><span class="line">    HTTP_Port 2020</span><br><span class="line">    Health_Check On</span><br><span class="line">    storage.path              /var/fluent-bit/state/flb-storage/</span><br><span class="line">    storage.sync              normal</span><br><span class="line">    storage.checksum          off</span><br><span class="line">    storage.backlog.mem_limit 10M</span><br><span class="line"></span><br><span class="line">[INPUT]</span><br><span class="line">    Name tail</span><br><span class="line">    Path xxxxxxxx.log  # 对应的日志文件</span><br><span class="line">    Tag kube.*</span><br><span class="line">    Docker_Mode         On</span><br><span class="line">    Docker_Mode_Flush   5</span><br><span class="line">    Docker_Mode_Parser  container_firstline</span><br><span class="line">    Parser              docker</span><br><span class="line">    DB                  /var/fluent-bit/state/flb_container.db</span><br><span class="line">    Mem_Buf_Limit       5MB</span><br><span class="line">    Skip_Long_Lines     On</span><br><span class="line">    Refresh_Interval    10</span><br><span class="line">    Rotate_Wait         30</span><br><span class="line">    storage.type        filesystem</span><br><span class="line"></span><br><span class="line">[FILTER]</span><br><span class="line">    Name             kubernetes</span><br><span class="line">    Match            kube.*   # 匹配模式改成kube.*</span><br><span class="line">    Kube_URL         https://kubernetes.default.svc:443</span><br><span class="line">    Kube_CA_File     /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">    Kube_Token_File  /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">    Labels false</span><br><span class="line">    Annotations false</span><br><span class="line"></span><br><span class="line">[Filter]</span><br><span class="line">    Name    nest</span><br><span class="line">    Match    kube.*</span><br><span class="line">    Operation    lift</span><br><span class="line">    Nested_under    kubernetes</span><br><span class="line">    Add_prefix    kubernetes_</span><br><span class="line"></span><br><span class="line">[Filter]</span><br><span class="line">    Name    modify</span><br><span class="line">    Match    kube.*</span><br><span class="line">    Remove    kubernetes_pod_id  # Remove可以移除掉你不关心的参数</span><br><span class="line">    Remove    kubernetes_namespace_name</span><br><span class="line">    Remove    kubernetes_container_hash</span><br><span class="line">    Remove    kubernetes_container_image</span><br><span class="line">    Remove    kubernetes_container_name</span><br><span class="line">    Remove    kubernetes_docker_id</span><br><span class="line"></span><br><span class="line">[OUTPUT]</span><br><span class="line">    Name kinesis_streams</span><br><span class="line">    Match             kube.*</span><br><span class="line">    Region us-west-1	    # aws区域</span><br><span class="line">    Stream LogHub-xxxxxxxx  # loghub配置流</span><br><span class="line">    Retry_Limit False</span><br><span class="line">    time_key time</span><br></pre></td></tr></table></figure>
<p>重启一下fluent-bit就行了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里调试的过程中发现的一些需要注意的问题:</p>
<ol>
<li>match 要给成 kube.*</li>
</ol>
]]></content>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>latex| 论文下方添加copyright</title>
    <url>/2023/03/02/latex-%E8%AE%BA%E6%96%87%E4%B8%8B%E6%96%B9%E6%B7%BB%E5%8A%A0copyright/</url>
    <content><![CDATA[<p>在\begin{document}上方添加如下代码</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\IEEEoverridecommandlockouts</span></span><br><span class="line"><span class="keyword">\IEEEpubid</span>&#123;<span class="keyword">\makebox</span>[<span class="keyword">\columnwidth</span>]&#123;978-1-4799-3083-8/14/<span class="keyword">\$</span>31.00~<span class="keyword">\copyright</span>~2014 IEEE <span class="keyword">\hfill</span>&#125; <span class="keyword">\hspace</span>&#123;<span class="keyword">\columnsep</span>&#125;<span class="keyword">\makebox</span>[<span class="keyword">\columnwidth</span>]&#123; &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>如图：<br><img  
                     lazyload
                     alt="image"
                     data-src="/images/latex_copyright.png"
                     
                ></p>
]]></content>
      <tags>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql| 添加新用户</title>
    <url>/2023/03/02/mysql-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--	1. 用户名为ribincao ，&#x27;%&#x27;表示所有 ip 都可访问，&#x27;123456&#x27;为密码</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;ribincao&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--	2. 授予用户权限, 否则操作会报 command denied  错误</span></span><br><span class="line"><span class="keyword">grant</span> usage <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;zc&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span>,<span class="keyword">create</span>,<span class="keyword">drop</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;ribincao&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql| 索引失效的几种情况</title>
    <url>/2023/03/07/mysql-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<ul>
<li>like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效</li>
<li>or语句前后没有同时使用索引</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引</li>
<li>在索引列上使用 IS NULL 或 IS NOT NULL操作</li>
<li>在索引字段上使用not，&lt;&gt;，!&#x3D;</li>
<li>对索引字段进行计算操作、字段上使用函数</li>
<li>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效</li>
<li>组合索引，不是使用第一列索引，索引失效</li>
</ul>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>python| LRU的实现</title>
    <url>/2023/03/02/python-LRU%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>前几天看到同事在写服务器框架的时候其中有一部分在用C#实现一个LRU算法，当时脑子一蒙忽然忘记LRU的具体实现原理，赶紧翻书回忆了一下LRU然后用python去实现了一个LRU来加深记忆。<br>LRU(Least Recently Used)指的是最近最少使用，核心就是当要淘汰数据的时候选择最久没有使用的数据。仔细想想，我这里准备用一个双向链表来存储数据的访问记录，链表的头节点是最近一次访问的数据，链表的尾节点是最远一次访问的数据，同时给节点设置一个节点数上限来限制数据的存储大小，当访问的数据大于上限的时候从淘汰尾结点的访问记录。为了快速确定访问数据存储的节点，我们需要一个hash表来记录数据的键与节点的映射。下面就开始来实现。</p>
<h2 id="一、设计思路"><a href="#一、设计思路" class="headerlink" title="一、设计思路"></a>一、设计思路</h2><p>  先实现一个Node类，类中存储了数据的信息(键&#x2F;值)以及两个分别指向前向和后向节点的指针</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">object</span></span>):</span><br><span class="line">        self.key: <span class="built_in">str</span> = key</span><br><span class="line">        self.value: <span class="built_in">object</span> = value</span><br><span class="line">        self.prev: <span class="type">Optional</span>[Node] = <span class="literal">None</span></span><br><span class="line">        self.post: <span class="type">Optional</span>[Node] = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>然后就是实现一个双向链表，链表的数据成员有头结点指针head和尾结点tail以及链表的长度，方法成员有三个，分别是头部增加节点、尾部移除节点以及移除指定的节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLink</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head: <span class="type">Optional</span>[Node] = <span class="literal">None</span></span><br><span class="line">        self.tail: <span class="type">Optional</span>[Node] = <span class="literal">None</span></span><br><span class="line">        self.length: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append_front</span>(<span class="params">self, node: Node</span>):</span><br><span class="line">        <span class="comment"># type: (Node) -&gt; <span class="literal">None</span></span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 链表头部添加一个节点 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, node: Node</span>):</span><br><span class="line">        <span class="comment"># type: (Node) -&gt; Node</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 从链表中移除指定的节点, 返回被移除的节点 &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_back</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># type: () -&gt; Node | <span class="literal">None</span></span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 从链表中弹出尾部的节点, 返回移除的节点(可能为空)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>实现LRU类，对于用户来说，LRU只有一个set接口负责把访问记录添加到链表中，另一个是get接口负责从链表中获取之前的访问记录。LRU类另外还有三个数据成员，分别是容量、节点的映射关系表以及刚才定义的双向链表实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lru</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity=<span class="number">1024</span></span>):</span><br><span class="line">        self.capacity: <span class="built_in">int</span> = capacity</span><br><span class="line">        self.keys: <span class="type">Dict</span>[<span class="built_in">str</span>, Node] = <span class="built_in">dict</span>()</span><br><span class="line">        self.link: DoubleLink = DoubleLink()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">object</span></span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="二、具体实现和测试结果"><a href="#二、具体实现和测试结果" class="headerlink" title="二、具体实现和测试结果"></a>二、具体实现和测试结果</h2><p>最后，开始实现每个函数的具体功能就OK了，最终的完整代码文件如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">object</span></span>):</span><br><span class="line">        self.key: <span class="built_in">str</span> = key</span><br><span class="line">        self.value: <span class="built_in">object</span> = value</span><br><span class="line">        self.prev: <span class="type">Optional</span>[Node] = <span class="literal">None</span></span><br><span class="line">        self.post: <span class="type">Optional</span>[Node] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLink</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head: <span class="type">Optional</span>[Node] = <span class="literal">None</span></span><br><span class="line">        self.tail: <span class="type">Optional</span>[Node] = <span class="literal">None</span></span><br><span class="line">        self.length: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append_front</span>(<span class="params">self, node: Node</span>):</span><br><span class="line">        <span class="comment"># type: (Node) -&gt; <span class="literal">None</span></span></span><br><span class="line">        <span class="keyword">if</span> self.length &lt;= <span class="number">0</span>:</span><br><span class="line">            node.prev = <span class="literal">None</span></span><br><span class="line">            node.post = <span class="literal">None</span></span><br><span class="line">            self.head = node</span><br><span class="line">            self.tail = node</span><br><span class="line">            self.length += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        old_head = self.head</span><br><span class="line">        node.prev = <span class="literal">None</span></span><br><span class="line">        node.post = old_head</span><br><span class="line">        <span class="keyword">if</span> old_head:</span><br><span class="line">            old_head.prev = node</span><br><span class="line">        self.head = node</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, node: Node</span>):</span><br><span class="line">        <span class="comment"># type: (Node) -&gt; Node</span></span><br><span class="line">        prev = node.prev</span><br><span class="line">        post = node.post</span><br><span class="line">        <span class="keyword">if</span> node == self.head:</span><br><span class="line">            self.head = post</span><br><span class="line">        <span class="keyword">if</span> node == self.tail:</span><br><span class="line">            self.tail = prev</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> prev:</span><br><span class="line">            prev.post = post</span><br><span class="line">        <span class="keyword">if</span> post:</span><br><span class="line">            post.prev = prev</span><br><span class="line">        </span><br><span class="line">        node.prev = <span class="literal">None</span></span><br><span class="line">        node.post = <span class="literal">None</span></span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop_back</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># type: () -&gt; Node | <span class="literal">None</span></span></span><br><span class="line">        tail = self.tail</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">            <span class="keyword">return</span> tail</span><br><span class="line">        prev_tail = tail.prev</span><br><span class="line">        self.tail = prev_tail</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> prev_tail:</span><br><span class="line">            prev_tail.post = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> tail</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.length &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        head = self.head</span><br><span class="line">        nodes = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            s = <span class="string">&quot;(%s: %s)&quot;</span> % (head.key, head.value)</span><br><span class="line">            nodes.append(s)</span><br><span class="line">            head = head.post</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; -&gt; &quot;</span>.join(nodes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lru</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity=<span class="number">1024</span></span>):</span><br><span class="line">        self.capacity: <span class="built_in">int</span> = capacity</span><br><span class="line">        self.keys: <span class="type">Dict</span>[<span class="built_in">str</span>, Node] = <span class="built_in">dict</span>()</span><br><span class="line">        self.link: DoubleLink = DoubleLink()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, key: <span class="built_in">str</span>, value: <span class="built_in">object</span></span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.keys:</span><br><span class="line">            node = self.keys[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            r_node = self.link.remove(node)</span><br><span class="line">            self.link.append_front(r_node)</span><br><span class="line">            <span class="built_in">print</span>(self.link.length, self.link)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.link.length &gt;= self.capacity:</span><br><span class="line">            p_node = self.link.pop_back()</span><br><span class="line">            <span class="keyword">if</span> p_node:</span><br><span class="line">                <span class="keyword">del</span> self.keys[p_node.key]</span><br><span class="line">                <span class="keyword">del</span> p_node</span><br><span class="line">        </span><br><span class="line">        node = Node(key, value)</span><br><span class="line">        self.keys[key] = node</span><br><span class="line">        self.link.append_front(node)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;length: &quot;</span>, self.link.length, <span class="string">&quot;, link:&quot;</span>, self.link)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.keys:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = self.keys[key]</span><br><span class="line">        r_node = self.link.remove(node)</span><br><span class="line">        self.link.append_front(r_node)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[GET] %s: %s&quot;</span> % (key, node.value))</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    lru = Lru(<span class="number">3</span>)</span><br><span class="line">    lru.<span class="built_in">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;ribincao&quot;</span>)</span><br><span class="line">    lru.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    lru.<span class="built_in">set</span>(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;27&quot;</span>)</span><br><span class="line">    lru.get(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    lru.<span class="built_in">set</span>(<span class="string">&quot;education&quot;</span>, <span class="string">&quot;master&quot;</span>)</span><br><span class="line">    lru.get(<span class="string">&quot;education&quot;</span>)</span><br><span class="line">    lru.<span class="built_in">set</span>(<span class="string">&quot;occupation&quot;</span>, <span class="string">&quot;全菜工程师&quot;</span>)</span><br><span class="line">    lru.<span class="built_in">set</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    lru.<span class="built_in">set</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">    lru.<span class="built_in">set</span>(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在这里分享了自己的设计思路和实现过程，代码如若发现bug欢迎随时提出改正，peace!!!</p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>python| fast-api实现web服务器demo</title>
    <url>/2023/03/13/python-fast-api%E5%AE%9E%E7%8E%B0web%E6%9C%8D%E5%8A%A1%E5%99%A8demo/</url>
    <content><![CDATA[<p>基于fast-api实现的web服务器</p>
<p>前期准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install fastapi uvicorn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个简单的demo</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uvicorn main:app --reload</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python| floyd算法计算最短路径</title>
    <url>/2023/03/02/python-floyd%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@author: 热心市民吴彦祖</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#定义一个比较大的值</span></span><br><span class="line">MAX = <span class="number">99999</span></span><br><span class="line"><span class="comment">#邻接矩阵</span></span><br><span class="line">graph = [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, MAX, MAX],</span><br><span class="line">          [MAX, <span class="number">0</span>, MAX, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">          [<span class="number">1</span>, MAX, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">          [MAX, MAX, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>],</span><br><span class="line">          [MAX, MAX, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]</span><br><span class="line"><span class="comment">#生成路径矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createPathMatrix</span>(<span class="params">SIZE</span>):</span><br><span class="line">    PathMatrix = []</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(SIZE):</span><br><span class="line">        P = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(SIZE):</span><br><span class="line">            P.append(<span class="built_in">list</span>(tmp))</span><br><span class="line">        PathMatrix.append(<span class="built_in">list</span>(P))</span><br><span class="line">    <span class="keyword">return</span> PathMatrix</span><br><span class="line"><span class="comment">#基于Floyd算法生成最短路径矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Floyd</span>(<span class="params">Matrix, PathMatrix</span>):</span><br><span class="line">    SIZE = <span class="built_in">len</span>(Matrix)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(SIZE):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(SIZE):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(SIZE):</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">or</span> (j == k) <span class="keyword">or</span> (i == k):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                s = Matrix[i][k] + Matrix[k][j]</span><br><span class="line">                <span class="keyword">if</span> s &lt; Matrix[i][j]:</span><br><span class="line">                    Matrix[i][j] = s</span><br><span class="line">                    PathMatrix[i][j].append(k)<span class="comment">#将经过的节点存入列表</span></span><br><span class="line">    <span class="keyword">return</span> Matrix, PathMatrix</span><br><span class="line"><span class="comment">#利用递归生成最短路径</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">searchPath</span>(<span class="params">start, target, pathMatrix</span>):</span><br><span class="line">    mid = pathMatrix[start][target]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mid) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> searchPath(start, mid[-<span class="number">1</span>], pathMatrix) + [mid[-<span class="number">1</span>]] + searchPath(mid[-<span class="number">1</span>], target, pathMatrix)</span><br><span class="line"></span><br><span class="line">pathMatrix = createPathMatrix(<span class="built_in">len</span>(graph))<span class="comment">#生成路径矩阵</span></span><br><span class="line">Matrix, pathMatrix = Floyd(graph, pathMatrix)<span class="comment">#计算最短路径并更新路径矩阵</span></span><br><span class="line">start = <span class="number">0</span><span class="comment">#出发节点</span></span><br><span class="line">target = <span class="number">4</span><span class="comment">#终点节点</span></span><br><span class="line">path = searchPath(start, target, pathMatrix)<span class="comment">#搜索中间路径</span></span><br><span class="line">output = [start] + path + [target]<span class="comment">#生成完整路径</span></span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>python| pip下载包太慢的问题</title>
    <url>/2023/02/28/python-pip%E6%9B%B4%E6%96%B0%E5%8C%85%E5%A4%AA%E6%85%A2/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>国内编写python项目需要通过pip去下载对应的依赖,有时候会很慢,可以通过pip配置来修改国内镜像源</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip3 config set install.trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python| 一个简单的区块链demo</title>
    <url>/2023/03/02/python-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BEdemo/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span>, <span class="type">Dict</span>, <span class="type">Union</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sender: <span class="built_in">str</span>, recipient: <span class="built_in">str</span>, amount: <span class="built_in">float</span></span>):</span><br><span class="line">        self.sender: <span class="built_in">str</span> = sender</span><br><span class="line">        self.recipient: <span class="built_in">str</span> = recipient</span><br><span class="line">        self.amount: <span class="built_in">float</span> = amount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__dict__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, index: <span class="built_in">int</span>, timestamp: <span class="built_in">float</span>, proof: <span class="built_in">int</span>, previous_hash: <span class="built_in">str</span>, transactions: <span class="type">List</span>[Transaction]</span>):</span><br><span class="line">        self.index: <span class="built_in">int</span> = index</span><br><span class="line">        self.timestamp: <span class="built_in">float</span> = timestamp</span><br><span class="line">        self.proof: <span class="built_in">int</span> = proof</span><br><span class="line">        self.previous_hash: <span class="built_in">str</span> = previous_hash</span><br><span class="line">        self.transactions: <span class="type">List</span>[Transaction] = transactions</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">object</span>]:</span><br><span class="line">        ret = <span class="built_in">dict</span>(self.__dict__)</span><br><span class="line">        _t = []</span><br><span class="line">        <span class="keyword">for</span> transaction <span class="keyword">in</span> self.transactions:</span><br><span class="line">            _t.append(transaction.to_dict())</span><br><span class="line">        ret[<span class="string">&quot;transactions&quot;</span>] = _t</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockChain</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, proof: <span class="built_in">int</span></span>):</span><br><span class="line">        self.chains: <span class="type">List</span>[Block] = <span class="built_in">list</span>()</span><br><span class="line">        self.current_transactions: <span class="type">List</span>[Transaction] = []</span><br><span class="line">        self.new_block(proof=proof, pre_hash=<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_block</span>(<span class="params">self, proof: <span class="built_in">int</span>, pre_hash: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>) -&gt; Block:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre_hash:</span><br><span class="line">            pre_hash = self.<span class="built_in">hash</span>(self.last_block)</span><br><span class="line">        block = Block(index=<span class="built_in">len</span>(self.chains) + <span class="number">1</span>,</span><br><span class="line">                      timestamp=time.time(),</span><br><span class="line">                      proof=proof,</span><br><span class="line">                      previous_hash=pre_hash,</span><br><span class="line">                      transactions=self.current_transactions)</span><br><span class="line">        self.current_transactions = []</span><br><span class="line">        self.chains.append(block)</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_transaction</span>(<span class="params">self, sender: <span class="built_in">str</span>, recipient: <span class="built_in">str</span>, amount: <span class="built_in">float</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        transaction = Transaction(sender, recipient, amount)</span><br><span class="line">        self.current_transactions.append(transaction)</span><br><span class="line">        <span class="keyword">return</span> self.last_block.index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">last_block</span>(<span class="params">self</span>) -&gt; Block:</span><br><span class="line">        <span class="keyword">return</span> self.chains[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash</span>(<span class="params">cls, block: Block</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        block_string = json.dumps(block.to_dict(), sort_keys=<span class="literal">True</span>).encode()</span><br><span class="line">        <span class="keyword">return</span> hashlib.sha256(block_string).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">proof_of_work</span>(<span class="params">self, last_proof: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        proof = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.valid_proof(last_proof, proof):</span><br><span class="line">            proof += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> proof</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">valid_proof</span>(<span class="params">cls, last_proof, proof</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        guess = <span class="string">f&quot;<span class="subst">&#123;last_proof&#125;</span><span class="subst">&#123;proof&#125;</span>&quot;</span>.encode()</span><br><span class="line">        guess_hash = hashlib.sha256(guess).hexdigest()</span><br><span class="line">        <span class="keyword">return</span> guess_hash[:<span class="number">4</span>] == <span class="string">&quot;0000&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">node_identifier = <span class="built_in">str</span>(uuid4()).replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">block_chain = BlockChain(proof=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/mine&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mine</span>():</span><br><span class="line">    last_block = block_chain.last_block</span><br><span class="line">    last_proof = last_block.proof</span><br><span class="line">    proof = block_chain.proof_of_work(last_proof)</span><br><span class="line"></span><br><span class="line">    block_chain.new_transaction(sender=<span class="string">&quot;0&quot;</span>, recipient=node_identifier, amount=<span class="number">1</span>)</span><br><span class="line">    pre_hash = block_chain.<span class="built_in">hash</span>(last_block)</span><br><span class="line">    block = block_chain.new_block(proof, pre_hash)</span><br><span class="line">    response = block.to_dict()</span><br><span class="line">    response[<span class="string">&quot;message&quot;</span>] = <span class="string">&quot;new block forged&quot;</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/transactions/new&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_transaction</span>():</span><br><span class="line">    req: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>] = request.get_json()</span><br><span class="line">    requires = [<span class="string">&quot;sender&quot;</span>, <span class="string">&quot;recipient&quot;</span>, <span class="string">&quot;amount&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(param <span class="keyword">in</span> requires <span class="keyword">for</span> param <span class="keyword">in</span> req):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;missing param&quot;</span>, <span class="number">400</span></span><br><span class="line">    index = block_chain.new_transaction(req[<span class="string">&quot;sender&quot;</span>], req[<span class="string">&quot;recipient&quot;</span>], <span class="built_in">float</span>(req[<span class="string">&quot;amount&quot;</span>]))</span><br><span class="line">    response = &#123;<span class="string">&quot;message&quot;</span>: <span class="string">f&quot;transaction will be add to block <span class="subst">&#123;index&#125;</span>&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/chain&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">full_chain</span>():</span><br><span class="line">    chains = []</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> block_chain.chains:</span><br><span class="line">        chains.append(block.to_dict())</span><br><span class="line">    response = &#123;</span><br><span class="line">        <span class="string">&quot;chain:&quot;</span>: chains,</span><br><span class="line">        <span class="string">&quot;length&quot;</span>: <span class="built_in">len</span>(chains)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jsonify(response), <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>python| 哲学家就餐问题</title>
    <url>/2023/03/02/python-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>哲学家就餐问题是一个很经典的问题，leetcode上的第1226题<code>https://leetcode-cn.com/problems/the-dining-philosophers/</code>有用例可以跑，针对这道题通过python用三种方法实现。</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>最简单暴力的方法，串行解决：设置一个锁确保每个时刻只有一个哲学家在就餐。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># call the functions directly to execute, for example, eat()</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wantsToEat</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                   philosopher: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">                   pickLeftFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   pickRightFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   eat: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   putLeftFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   putRightFork: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        self.lock.acquire()</span><br><span class="line">        <span class="comment">#  判断是否加锁成功</span></span><br><span class="line">        <span class="keyword">if</span> self.lock.locked():</span><br><span class="line">            pickLeftFork()</span><br><span class="line">            pickRightFork()</span><br><span class="line">            eat()</span><br><span class="line">            putLeftFork()</span><br><span class="line">            putRightFork()</span><br><span class="line">            <span class="keyword">while</span> self.lock.locked():</span><br><span class="line">                self.lock.release()</span><br></pre></td></tr></table></figure>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>每个哲学家都先拿左边的餐具再拿右边的餐具进行就餐，每个餐具都设置一个锁，加入就餐的哲学家编号为<code>i</code>，则他左边和右边的餐具编号设定为<code>i</code>和<code>(i + 1) % n</code>。为了避免出现死锁所以需要一个信号量去限定最多只有<code>n-1</code>个人去拿餐具就餐(本题中<code>n=5</code>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Semaphore</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.sem = Semaphore(<span class="number">4</span>)</span><br><span class="line">        self.locks = [Lock() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># call the functions directly to execute, for example, eat()</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wantsToEat</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                   philosopher: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">                   pickLeftFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   pickRightFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   eat: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   putLeftFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   putRightFork: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.sem.acquire()</span><br><span class="line">        left_fork, right_fork = philosopher, (philosopher + <span class="number">1</span>) % <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        self.locks[left_fork].acquire()</span><br><span class="line">        self.locks[right_fork].acquire()</span><br><span class="line"></span><br><span class="line">        pickLeftFork()</span><br><span class="line">        pickRightFork()</span><br><span class="line">        eat()</span><br><span class="line">        putLeftFork()</span><br><span class="line">        putRightFork()</span><br><span class="line"></span><br><span class="line">        self.locks[left_fork].release()</span><br><span class="line">        self.locks[right_fork].release()</span><br><span class="line">        self.sem.release()</span><br></pre></td></tr></table></figure>
<h3 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h3><p>和第二种方法类似，不过是让奇数号的哲学家先抢左边的餐具再抢右边的餐具，而偶数号的哲学家相反，先抢右边的餐具再抢左边的餐具，这样就可以不用限定准备就餐的人数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiningPhilosophers</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.locks = [Lock() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># call the functions directly to execute, for example, eat()</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wantsToEat</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                   philosopher: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">                   pickLeftFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   pickRightFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   eat: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   putLeftFork: <span class="string">&#x27;Callable[[], None]&#x27;</span>,</span></span><br><span class="line"><span class="params">                   putRightFork: <span class="string">&#x27;Callable[[], None]&#x27;</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        left_fork, right_fork = philosopher, (philosopher + <span class="number">1</span>) % <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> philosopher % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            self.locks[right_fork].acquire()</span><br><span class="line">            self.locks[left_fork].acquire()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.locks[left_fork].acquire()</span><br><span class="line">            self.locks[right_fork].acquire()</span><br><span class="line"></span><br><span class="line">        pickLeftFork()</span><br><span class="line">        pickRightFork()</span><br><span class="line">        eat()</span><br><span class="line">        putLeftFork()</span><br><span class="line">        putRightFork()</span><br><span class="line"></span><br><span class="line">        self.locks[left_fork].release()</span><br><span class="line">        self.locks[right_fork].release()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>python| 基于json的RPC实现</title>
    <url>/2023/03/02/python-%E5%9F%BA%E4%BA%8Ejson%E7%9A%84RPC%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="背景和实现原理"><a href="#背景和实现原理" class="headerlink" title="背景和实现原理"></a>背景和实现原理</h3><p>最近在看RPC相关的东西就想着实现一个RPC，看了一些别人写的并且特意去看了一下python标注库xmlrpc里的实现源码，就参考源码写了一个简单版的。简单说一下代码结构，代码主要有两个文件<code>client.py</code>和<code>server.py</code>两个文件：</p>
<ul>
<li>其中客户端是实现了一个<code>ServerProxy</code>类，这个类主要提供<code>_request</code>接口处理调用，同时这个类继承了一个专门负责网络连接的<code>TCPClient</code>类，该类提供了<code>connect</code>、<code>recv</code>、<code>send</code>和<code>close</code>接口管理网络连接。另外还提供了一个<code>_Method</code>类负责管理RPC的调用，相当于RPC stub，这种实现方式参考了xmlrpc。</li>
<li>服务端是实现了一个<code>Server</code>类，提供了<code>run</code>和<code>process</code>接口分别负责服务的启动和方法调用的处理，该类继承了两个类分别是<code>TCPServer</code>和<code>Dispatch</code>，其中<code>TCPServer</code>和<code>TCPClient</code>一样主要负责网络连接的处理，<code>Dispatch</code>类负责RPC方法的注册和调用，该类提供了<code>register_function</code>和<code>call_method</code>接口分别处理方法的注册和调用。</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/json_rpc.png"
                     
                >

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>客户端代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPClient</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    负责网络连接</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, host, port</span>):</span><br><span class="line">        self.sock.connect((host, port))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, length</span>):</span><br><span class="line">        <span class="keyword">return</span> self.sock.recv(length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.sock.send(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        self.sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Method</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    负责方法调用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, send, name</span>):</span><br><span class="line">        self.__send = send</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> _Method(self.__send, <span class="string">f&quot;<span class="subst">&#123;self.__name&#125;</span>.<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__send(self.__name, args, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerProxy</span>(TCPClient, _Method):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">1060</span></span>):</span><br><span class="line">        TCPClient.__init__(self)</span><br><span class="line">        self.connect(host, port)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> _Method(self._request, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_request</span>(<span class="params">self, method_name, args, kwargs</span>):</span><br><span class="line">        info = &#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: method_name,</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: args,</span><br><span class="line">            <span class="string">&#x27;kwargs&#x27;</span>: kwargs</span><br><span class="line">        &#125;</span><br><span class="line">        self.send(json.dumps(info).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        data = self.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">return</span> json.loads(data)[<span class="string">&#x27;result&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cli = ServerProxy(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">1061</span>)</span><br><span class="line"></span><br><span class="line">    ret = cli.ping()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;return of ping is: <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line">    ret = cli.add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;return of add(1, 2) is: <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line">    ret = cli.valid_method(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;return of valid_method is: <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(dir(cli))</span></span><br></pre></td></tr></table></figure>
<p>服务端代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPServer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    负责网络连接</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.conn = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">self, port</span>):</span><br><span class="line">        self.sock.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, port))</span><br><span class="line">        self.sock.listen(<span class="number">5</span>)</span><br><span class="line">        (conn, _) = self.sock.accept()</span><br><span class="line">        self.conn = conn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self</span>):</span><br><span class="line">        msg = self.conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.conn.sendall(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dispatch</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    负责方法注册和调用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.methods = &#123;&#125;</span><br><span class="line">        self.data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register_method</span>(<span class="params">self, method, name=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name:</span><br><span class="line">            name = method.__name__</span><br><span class="line">        self.methods[name] = method</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call_method</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = json.loads(data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        name = self.data[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        args = self.data[<span class="string">&#x27;args&#x27;</span>]</span><br><span class="line">        kwargs = self.data[<span class="string">&#x27;kwargs&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.methods:</span><br><span class="line">            data = &#123;</span><br><span class="line">                <span class="string">&quot;result&quot;</span>: <span class="string">f&quot;there is no support for <span class="subst">&#123;name&#125;</span>.&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret = self.methods[name](*args, **kwargs)</span><br><span class="line">            data = &#123;</span><br><span class="line">                <span class="string">&quot;result&quot;</span>: ret</span><br><span class="line">            &#125;</span><br><span class="line">        ret = json.dumps(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>(TCPServer, Dispatch):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        TCPServer.__init__(self)</span><br><span class="line">        Dispatch.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, port</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Server listen at <span class="subst">&#123;port&#125;</span>.&quot;</span>)</span><br><span class="line">        self.listen(port)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;get connection&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = self.recv()</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                ret = self.process(data)</span><br><span class="line">                self.send(ret)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.call_method(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  测试方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ping</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    srv = Server()</span><br><span class="line">    srv.register_method(ping)</span><br><span class="line">    srv.register_method(Test.add)</span><br><span class="line">    srv.run(<span class="number">1061</span>)</span><br></pre></td></tr></table></figure>
<h3 id="测试方法及结果"><a href="#测试方法及结果" class="headerlink" title="测试方法及结果"></a>测试方法及结果</h3><p>调试方法：</p>
<ol>
<li>终端运行<code>server.py</code>文件，文件中提供了两个测试方法：普通的ping方法和类的静态方法add。</li>
<li>再开一个终端运行<code>client.py</code>文件，文件中提供了三个测试调用：调用普通方法、类的静态方法和一个不存在的方法。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 server.py</span><br><span class="line">python3 client.py</span><br></pre></td></tr></table></figure>
测试结果如下：<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">return of ping is: pong</span><br><span class="line">return of add(1, 2) is: 3</span><br><span class="line">return of valid_method is: there is no support for valid_method.</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h3><p>目前的RPC调用是一个只能处理一个连接的极简版本，主要是为了帮助我理解和学习RPC用的，通过代码可以发现这里RPC客户端最主要的地方是通过<code>__getattr__</code>重载将需要调用的方法的名字设为属性，同时作为参数构造一个<code>_Method</code>，然后重载<code>_Method</code>的<code>__call__</code>实现方法的调用。方法的调用过程就是将方法名字和参数通过json序列化后传给服务端以及将服务端返回来的结果反序列化后展示。服务端实现的原理就是通过函数注册将函数和函数名字进行绑定存在一个字典里，当收到客户端发来的调用就去字典里查看函数名字是否有对应的实现，如果有就执行该方法并返回，如果没有就返回提示。<br>这个代码未来可能会进一步完善，可以在完善的过程中通过解决问题加深对RPC以及网络编程的理解，后续想解决的问题有：</p>
<ol>
<li>通过多路复用实现多个连接</li>
<li>通过名字去创建<code>ServerProxy</code>对象，名字和对应的(ip, port)用一个配置文件来管理</li>
<li>目前是通过<code>json</code>协议实现RPC，可以考虑使用<code>protobuf</code>试试<br>等等，peace。</li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>python| 如何调用dll库文件</title>
    <url>/2023/03/13/python-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8dll%E5%BA%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>最近在思考游戏服务器架构的时候想测试一下python调用dll来使用一些开源的网络库或者物理引擎,写几个demo测试一下效果.<br>python调用dll使用的是ctypes包,先写一个简单的调用求和函数的demo(目前使用的系统是ubuntu)</p>
<h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p>编写求和的C++代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mylib.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;add(&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译生成动态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-shared选项指示g++编译器生成共享库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fPIC选项指示编译器生成位置无关的代码，以便可以在任何位置加载库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-o选项指定生成的共享库文件的名称为libmylib.so</span></span><br><span class="line">g++ -shared -fPIC -o libmylib.so mylib.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后编写python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载共享库</span></span><br><span class="line">mylib = ctypes.CDLL(<span class="string">&#x27;./libmylib.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用共享库中的add函数</span></span><br><span class="line">result = mylib.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行脚本会生成<code>add(2, 3) 5</code></p>
<h2 id="调用网络库"><a href="#调用网络库" class="headerlink" title="调用网络库"></a>调用网络库</h2><p>写一个简单网络库测试一下,编写网络连接的cpp代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mylib.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (server_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create socket&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket选项</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &amp;opt, <span class="built_in">sizeof</span>(opt))) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to set socket options&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket到本地地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(<span class="number">12345</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to bind socket to address&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(server_fd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to listen on socket&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受连接并处理请求</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server is running on port 12345&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> client_fd = <span class="built_in">accept</span>(server_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to accept incoming connection&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> bytes_received = <span class="built_in">read</span>(client_fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_received &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to read from socket&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">close</span>(client_fd);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Received message: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *response = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">        <span class="type">int</span> bytes_sent = <span class="built_in">write</span>(client_fd, response, <span class="built_in">strlen</span>(response));</span><br><span class="line">        <span class="keyword">if</span> (bytes_sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to write to socket&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(client_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="built_in">close</span>(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -shared -fPIC -o libmylib.so mylib.cpp</span><br></pre></td></tr></table></figure>

<p>编写服务端的python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.py</span></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载共享库</span></span><br><span class="line">network = ctypes.cdll.LoadLibrary(<span class="string">&#x27;./libmylib.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用C++函数</span></span><br><span class="line">network.main()</span><br></pre></td></tr></table></figure>

<p>编写客户端python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">PORT = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到服务器</span></span><br><span class="line">client_socket.connect((HOST, PORT))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line">message = <span class="string">&#x27;Hello from Python&#x27;</span></span><br><span class="line">client_socket.send(message.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收回复消息并打印</span></span><br><span class="line">response = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(response.decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭socket</span></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure>

<p>分别开两个终端启动服务端和客户端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 server.py</span><br><span class="line">python3 client.py</span><br></pre></td></tr></table></figure>

<p>服务端会打印<code>Hello from python</code><br>客户端会打印<code>Hello from C++</code></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python| 实现Facade装饰模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0Facade%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: ribincao</span></span><br><span class="line"><span class="string">desc FacadeModel Demo</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># System</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Circle, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Draw Circle.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__int__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Rectangle, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Draw Rectangle.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Facade</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFacade</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.circle = Circle()</span><br><span class="line">        self.rectangle = Rectangle()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_circle</span>(<span class="params">self</span>):</span><br><span class="line">        self.circle.draw()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_rectangle</span>(<span class="params">self</span>):</span><br><span class="line">        self.rectangle.draw()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sf = ShapeFacade()</span><br><span class="line">    sf.draw_circle()</span><br><span class="line">    sf.draw_rectangle()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现Mediator中介者模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0Mediator%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: ribincao</span></span><br><span class="line"><span class="string">desc: MediatorModel Demo</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, string</span>):</span><br><span class="line">        ChatRoomMediator.say(self, string)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoomMediator</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">user: User, msg: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;user.name&#125;</span>: <span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ribin = User(<span class="string">&quot;RibinCao&quot;</span>)</span><br><span class="line">    tommy = User(<span class="string">&quot;TommyLiu&quot;</span>)</span><br><span class="line">    ribin.say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    tommy.say(<span class="string">&quot;hi&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现Mix-in模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0Mix-in%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> eat&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> sleep&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalMixin</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Mixin 类应该表示某种单一的功能且不依赖子类的实现, 子类没有 mixin 累也可已正常工作, 比如:</span></span><br><span class="line"><span class="string">        交通工具(基类) + 天上飞Mixin + 地上跑Mixin + 海里漂Mixin</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Animal Mixin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_tools</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> make tools&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(Animal, AnimalMixin):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    AnimalMixin 的构造函数不会被调用</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        方法顺序解释(MRO): Person -&gt; Animal -&gt; AnimalMixin</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(Person, self).__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Person, self).make_tools()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Person(<span class="string">&quot;ribincao&quot;</span>)</span><br><span class="line">    p.eat()</span><br><span class="line">    p.sleep()</span><br><span class="line">    p.power()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现代理模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: ribincao</span></span><br><span class="line"><span class="string">desc: ProxyModel Demo</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImp</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">PersonImp</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">super</span>(Person, self).__init__()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> say hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonProxy</span>(<span class="title class_ inherited__">PersonImp</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(PersonProxy, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        self._person = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._person:</span><br><span class="line">            self._person = Person(self.name)</span><br><span class="line">        self._person.hello()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pp = PersonProxy(<span class="string">&quot;ribincao&quot;</span>)</span><br><span class="line">    pp.hello()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现单例模式的两种方式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>第一种是通过类的方式，修改<code>__new__</code>实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(cls._instance, cls):</span><br><span class="line">            cls._instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span>(<span class="title class_ inherited__">Singleton</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(S, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">s</span>):</span><br><span class="line">    obj = S(s)</span><br><span class="line">    <span class="built_in">print</span>(obj.name, <span class="built_in">id</span>(obj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Thread(target=task, args=(<span class="built_in">str</span>(i), )).start()</span><br></pre></td></tr></table></figure>
<p>第二种是通过装饰器的方式实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    _instance = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance</span>(<span class="params">*arg, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls(*arg, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    obj = Test()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(obj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        Thread(target=task).start()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现发布-订阅模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: ribincao</span></span><br><span class="line"><span class="string">desc: SimpleEventDispatcherDemo</span></span><br><span class="line"><span class="string">Date: 2021/6/30</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span>, <span class="type">Type</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginEvent</span>(<span class="title class_ inherited__">Event</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LoginEvent, self).__init__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventDispatcher</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._listen = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_event</span>(<span class="params">self, event: <span class="built_in">type</span>, handler: <span class="type">Callable</span>[[Event], <span class="literal">None</span>]</span>):</span><br><span class="line">        <span class="comment"># print(&quot;add_event: &quot;, event.__name__)</span></span><br><span class="line">        event_name = event.__name__</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._has_listener(event_name, handler):</span><br><span class="line">            handlers = self._listen.get(event_name, [])</span><br><span class="line">            handlers.append(handler)</span><br><span class="line">            self._listen[event_name] = handlers</span><br><span class="line">            <span class="comment"># print(&quot;add listener success&quot;)</span></span><br><span class="line">            <span class="comment"># print(len(self._listen[event_name]))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_has_listener</span>(<span class="params">self, event_name: <span class="built_in">str</span>, handler: <span class="type">Callable</span>[[Event], <span class="literal">None</span>]</span>):</span><br><span class="line">        <span class="comment"># print(&quot;check handler: &quot;, event_name)</span></span><br><span class="line">        <span class="keyword">if</span> event_name <span class="keyword">in</span> self._listen:</span><br><span class="line">            <span class="keyword">return</span> handler <span class="keyword">in</span> self._listen[event_name]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch_event</span>(<span class="params">self, event: Event</span>):</span><br><span class="line">        <span class="comment"># print(&quot;dispatch_event: &quot;, event.__class__.__name__)</span></span><br><span class="line">        event_name = event.__class__.__name__</span><br><span class="line">        <span class="keyword">if</span> event_name <span class="keyword">in</span> self._listen:</span><br><span class="line">            handlers = self._listen[event_name]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">for</span> handler <span class="keyword">in</span> handlers:</span><br><span class="line">                    handler()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">                <span class="built_in">print</span>(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppMediator</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, event_dispatcher: EventDispatcher</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.event_dispatcher = event_dispatcher</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_event_listen</span>(<span class="params">self, event_clazz: <span class="type">Type</span>[Event], handler: <span class="type">Callable</span></span>):</span><br><span class="line">        self.event_dispatcher.add_event(event_clazz, handler)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch_event</span>(<span class="params">self, event: Event</span>):</span><br><span class="line">        self.event_dispatcher.dispatch_event(event)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span>(<span class="title class_ inherited__">AppMediator</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, event_dispatcher: EventDispatcher</span>):</span><br><span class="line">        <span class="built_in">super</span>(Entity, self).__init__(name, event_dispatcher)</span><br><span class="line">        self.add_event_listen(LoginEvent, self.hello)  <span class="comment"># 添加事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> say hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self, event: Event</span>):</span><br><span class="line">        self.dispatch_event(event)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    eventDispatcher = EventDispatcher()</span><br><span class="line"></span><br><span class="line">    entity1 = Entity(<span class="string">&quot;ribincao&quot;</span>, eventDispatcher)</span><br><span class="line">    entity2 = Entity(<span class="string">&quot;tommyliu&quot;</span>, eventDispatcher)</span><br><span class="line">    entity3 = Entity(<span class="string">&quot;allyli&quot;</span>, eventDispatcher)</span><br><span class="line"></span><br><span class="line">    entity1.do_something(LoginEvent())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现命令模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: ribincao</span></span><br><span class="line"><span class="string">desc: CommandModel Demo</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&quot;ribincao&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span> buy something.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> sell something.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyCommand</span>(<span class="title class_ inherited__">Command</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(BuyCommand, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        self.buy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellCommand</span>(<span class="title class_ inherited__">Command</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(SellCommand, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        self.sell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandMaker</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.commands: <span class="type">List</span>[Command] = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_command</span>(<span class="params">self, command: Command</span>):</span><br><span class="line">        self.commands.append(command)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.commands:</span><br><span class="line">            <span class="keyword">for</span> command <span class="keyword">in</span> self.commands:</span><br><span class="line">                command.execute()</span><br><span class="line">        self.commands.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cm = CommandMaker()</span><br><span class="line">    cm.add_command(SellCommand())</span><br><span class="line">    cm.add_command(BuyCommand())</span><br><span class="line">    <span class="comment"># print(len(cm.commands))</span></span><br><span class="line">    cm.execute()</span><br><span class="line">    <span class="comment"># print(len(cm.commands))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现工厂模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> SimpleFactory <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product1Factory</span>(<span class="title class_ inherited__">Factory</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Product1Factory, self).__init__()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product</span>():</span><br><span class="line">        <span class="keyword">return</span> Product1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product2Factory</span>(<span class="title class_ inherited__">Factory</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Product2Factory, self).__init__()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product</span>():</span><br><span class="line">        <span class="keyword">return</span> Product2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pf = Product1Factory()</span><br><span class="line">    p = pf.create_product()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现简单工厂模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product1</span>(<span class="title class_ inherited__">Product</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Product1, self).__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Product1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product2</span>(<span class="title class_ inherited__">Product</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Product2, self).__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Product2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_product</span>(<span class="params">name: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[Product]:</span><br><span class="line">        <span class="keyword">if</span> name == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> Product1()</span><br><span class="line">        <span class="keyword">if</span> name == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> Product2()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sf = SimpleFactory()</span><br><span class="line">    p1 = sf.create_product(<span class="number">1</span>)</span><br><span class="line">    p2 = sf.create_product(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 实现观察者模式</title>
    <url>/2023/03/02/python-%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: ribincao</span></span><br><span class="line"><span class="string">desc: ObserverModel Demo</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.hp = <span class="number">100</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.observers = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_notification</span>(<span class="params">self, hp</span>):</span><br><span class="line">        <span class="keyword">if</span> self.observers:</span><br><span class="line">            <span class="keyword">for</span> observer <span class="keyword">in</span> self.observers:</span><br><span class="line">                observer.update(hp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, user</span>):</span><br><span class="line">        self.user = user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HPObserver</span>(<span class="title class_ inherited__">Observer</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, user</span>):</span><br><span class="line">        <span class="built_in">super</span>(HPObserver, self).__init__(user)</span><br><span class="line">        self.user = user</span><br><span class="line">        self.user.attach(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, hp</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self.user.name&#125;</span> be attacked, <span class="subst">&#123;hp&#125;</span> hp decreased.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>(<span class="title class_ inherited__">User</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>(Player, self).__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attach</span>(<span class="params">self, observer</span>):</span><br><span class="line">        self.observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">be_attack</span>(<span class="params">self, hp</span>):</span><br><span class="line">        self.hp -= hp</span><br><span class="line">        self.send_notification(hp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ribin = Player(<span class="string">&#x27;ribincao&#x27;</span>)</span><br><span class="line">    hpOb = HPObserver(ribin)</span><br><span class="line">    ribin.be_attack(<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>python| 装饰器的使用</title>
    <url>/2023/03/07/python-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>之前做的一些关于python装饰器的笔记</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ribin</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*arg</span>):</span><br><span class="line">        func(arg)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment"># 在被装饰的函数定义之后立即运行装饰器</span></span><br><span class="line"><span class="keyword">import</span> funtools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器叠加</span></span><br><span class="line"><span class="meta">@funtools.lru_cache()   </span><span class="comment">#  缓存起来避免重复计算</span></span><br><span class="line"><span class="meta">@ribin</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 策略模式 &quot;&quot;&quot;</span></span><br><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">promotion</span>(<span class="params">promo_func</span>):</span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">return</span> order * <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">return</span> order * <span class="number">0.75</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">c</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">return</span> order * <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">best_promo</span>(<span class="params">order</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(func(order) <span class="keyword">for</span> func <span class="keyword">in</span> promos)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 闭包 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    series = []<span class="comment"># 自由变量(free variable), 未在本地作用域绑定的变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">arg</span>):</span><br><span class="line">        series.append(arg)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(series) / <span class="built_in">len</span>(series)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> average</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line"><span class="built_in">print</span>(avg.__code__.co_varnames)</span><br><span class="line"><span class="built_in">print</span>(avg.__code__.co_freevars)</span><br><span class="line"><span class="built_in">print</span>(avg.__closure__[<span class="number">0</span>].cell_contents)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager2</span>():</span><br><span class="line">    </span><br><span class="line">    count, total = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_val</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_val</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数装饰器</span></span><br><span class="line">registry = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">active=<span class="literal">True</span></span>):  <span class="comment"># 参数化装饰器工厂函数, 返回真正的装饰器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;running register(active=%s) -&gt; decorate(5s)&#x27; %(active, func))</span></span><br><span class="line"><span class="string">        if active:</span></span><br><span class="line"><span class="string">            registry.append(func)</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            registry.discard(func)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        return func</span></span><br><span class="line"><span class="string">    return decorate</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">@register(active=False)</span></span><br><span class="line"><span class="string">def f1():</span></span><br><span class="line"><span class="string">    print(&quot;</span>running f1()<span class="string">&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="string">    func()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python| 调用百度地图api查询经纬度</title>
    <url>/2023/03/02/python-%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEapi%E6%9F%A5%E8%AF%A2%E7%BB%8F%E7%BA%AC%E5%BA%A6/</url>
    <content><![CDATA[<p>最近在看《python网络编程》，里面的代码使用的案例是通过调用谷歌地图来查询经纬度，但是网络一直连不上，就用百度地图的api来实现书中的案例。<br>这里提到的查询经纬度按照调用层次可以有三种办法：第一种是构造url请求使用内置的request库去查询，实例代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 url 获取查询响应</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">geocode</span>(<span class="params">address</span>):</span><br><span class="line">    paramters = &#123;<span class="string">&#x27;address&#x27;</span>: address, <span class="string">&#x27;output&#x27;</span>: <span class="string">&#x27;json&#x27;</span>&#125;</span><br><span class="line">    base = <span class="string">&#x27;http://api.map.baidu.com/geocoder&#x27;</span></span><br><span class="line">    response = requests.get(base, params=paramters)</span><br><span class="line">    answer = response.json()</span><br><span class="line">    <span class="built_in">print</span>(answer[<span class="string">&#x27;result&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    geocode(<span class="string">&#x27;景德镇市浮梁&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种办法是使用更底层的内置http库在协议层面构造请求，实例代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote_plus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base = <span class="string">&#x27;/geocoder&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用 http 协议</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">geocode</span>(<span class="params">address</span>):</span><br><span class="line">    path = <span class="string">f&#x27;<span class="subst">&#123;base&#125;</span>?address=<span class="subst">&#123;quote_plus(address)&#125;</span>&amp;output=json&#x27;</span></span><br><span class="line">    connection = http.client.HTTPConnection(<span class="string">&#x27;api.map.baidu.com&#x27;</span>)</span><br><span class="line">    connection.request(<span class="string">&#x27;GET&#x27;</span>, path)</span><br><span class="line">    rawreply = connection.getresponse().read()</span><br><span class="line">    reply = json.loads(rawreply.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(reply[<span class="string">&#x27;result&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    geocode(<span class="string">&#x27;景德镇市浮梁&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三种办法是使用更加底层的socket库在传输层去创建会话获取经纬度，实例代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote_plus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">request_txt = <span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">GET /geocoder?address=&#123;&#125;&amp;output=json HTTP/1.1\r\n\</span></span><br><span class="line"><span class="string">Host: api.map.baidu.com:80\r\n\</span></span><br><span class="line"><span class="string">User-Agent: search4.py (Foundations of Python Network Programming)\r\n\</span></span><br><span class="line"><span class="string">Connection: close\r\n\</span></span><br><span class="line"><span class="string">\r\n</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立会话</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">geocode</span>(<span class="params">address</span>):</span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.connect((<span class="string">&#x27;api.map.baidu.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">    request = request_txt.<span class="built_in">format</span>(quote_plus(address))</span><br><span class="line">    sock.sendall(request.encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    raw_reply = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        more = sock.recv(<span class="number">4096</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> more:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        raw_reply += more</span><br><span class="line">    <span class="built_in">print</span>(raw_reply.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    geocode(<span class="string">&#x27;景德镇市浮梁&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这边测试代码运行成功，最后一个代码返回的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/javascript;charset=utf-8</span><br><span class="line">Date: Sat, 03 Jul 2021 07:22:49 GMT</span><br><span class="line">Http_x_bd_logid: xxx</span><br><span class="line">Http_x_bd_logid64: xx</span><br><span class="line">Http_x_bd_product: map</span><br><span class="line">Http_x_bd_subsys: apimap</span><br><span class="line">P3p: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;</span><br><span class="line">Server: apache</span><br><span class="line">Content-Length: 210</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;:&quot;OK&quot;,</span><br><span class="line">    &quot;result&quot;:&#123;</span><br><span class="line">        &quot;location&quot;:&#123;</span><br><span class="line">            &quot;lng&quot;:117.221466,</span><br><span class="line">            &quot;lat&quot;:29.357788</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;precise&quot;:0,</span><br><span class="line">        &quot;confidence&quot;:20,</span><br><span class="line">        &quot;level&quot;:&quot;\u533a\u53bf&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>python| 实现脚本获取地区天气</title>
    <url>/2023/03/08/python%E5%AE%9E%E7%8E%B0%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%8C%BA%E5%A4%A9%E6%B0%94/</url>
    <content><![CDATA[<p>用python写了一个脚本去获取指定城市的最近天气, 脚本运行成功会在本地生成一个csv文件, 代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weather</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, code: <span class="built_in">str</span>, name: <span class="built_in">str</span></span>):</span><br><span class="line">        self._url = <span class="string">&#x27;http://www.weather.com.cn/weather/&#x27;</span> + code + <span class="string">&#x27;.shtml&#x27;</span></span><br><span class="line">        self._text = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.data_all = []</span><br><span class="line">        self.city_name = name</span><br><span class="line">        self.data_cur = <span class="literal">None</span></span><br><span class="line">        self.data_7 = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.get_html_text()</span><br><span class="line">        self.get_content()</span><br><span class="line">        self.write_to_csv(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_html_text</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;请求获得网页内容&quot;&quot;&quot;</span></span><br><span class="line">        resp = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = requests.get(self._url, timeout=<span class="number">30</span>)</span><br><span class="line">            resp.raise_for_status()</span><br><span class="line">            resp.encoding = resp.apparent_encoding</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.city_name&#125;</span> Success&quot;</span>)</span><br><span class="line">            self._text = resp.text</span><br><span class="line">        <span class="keyword">except</span> requests.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;status_code <span class="subst">&#123;resp.status_code&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> oe:</span><br><span class="line">            <span class="built_in">print</span>(oe)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理得到有用信息保存数据文件&quot;&quot;&quot;</span></span><br><span class="line">        final = []  							      <span class="comment"># 初始化一个列表保存数据</span></span><br><span class="line">        bs = BeautifulSoup(self._text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 创建BeautifulSoup对象</span></span><br><span class="line">        body = bs.body</span><br><span class="line">        data = body.find(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;7d&#x27;</span>&#125;)         <span class="comment"># 找到div标签且id = 7d</span></span><br><span class="line">        <span class="comment"># 下面爬取当天的数据</span></span><br><span class="line">        data2 = body.find_all(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;left-div&#x27;</span>&#125;)</span><br><span class="line">        text = data2[<span class="number">2</span>].find(<span class="string">&#x27;script&#x27;</span>).string</span><br><span class="line">        text = text[text.index(<span class="string">&#x27;=&#x27;</span>) + <span class="number">1</span>:-<span class="number">2</span>]		 <span class="comment"># 移除改var data=将其变为json数据</span></span><br><span class="line">        jd = json.loads(text)</span><br><span class="line">        day_one = jd[<span class="string">&#x27;od&#x27;</span>][<span class="string">&#x27;od2&#x27;</span>]				 <span class="comment"># 找到当天的数据</span></span><br><span class="line">        final_day = []						     <span class="comment"># 存放当天的数据</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> day_one:</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">23</span>:</span><br><span class="line">                temp.append(i[<span class="string">&#x27;od21&#x27;</span>])				 <span class="comment"># 添加时间</span></span><br><span class="line">                temp.append(self.city_name + <span class="string">&#x27;市&#x27;</span>)	 <span class="comment"># 添加城市</span></span><br><span class="line">                temp.append(i[<span class="string">&#x27;od22&#x27;</span>])				 <span class="comment"># 添加当前时刻温度</span></span><br><span class="line">                temp.append(i[<span class="string">&#x27;od24&#x27;</span>])				 <span class="comment"># 添加当前时刻风力方向</span></span><br><span class="line">                temp.append(i[<span class="string">&#x27;od25&#x27;</span>])				 <span class="comment"># 添加当前时刻风级</span></span><br><span class="line">                temp.append(i[<span class="string">&#x27;od26&#x27;</span>])				 <span class="comment"># 添加当前时刻降水量</span></span><br><span class="line">                temp.append(i[<span class="string">&#x27;od27&#x27;</span>])				 <span class="comment"># 添加当前时刻相对湿度</span></span><br><span class="line">                temp.append(i[<span class="string">&#x27;od28&#x27;</span>])				 <span class="comment"># 添加当前时刻控制质量</span></span><br><span class="line">                final_day.append(temp)</span><br><span class="line">                self.data_all.append(temp)</span><br><span class="line">            count = count + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 爬取 24h 的数据</span></span><br><span class="line">        ul = data.find(<span class="string">&#x27;ul&#x27;</span>)                     <span class="comment"># 找到所有的 ul 标签</span></span><br><span class="line">        li = ul.find_all(<span class="string">&#x27;li&#x27;</span>)                   <span class="comment"># 找到左右的 li 标签</span></span><br><span class="line">        i = <span class="number">0</span>                                    <span class="comment"># 控制爬取的天数</span></span><br><span class="line">        <span class="keyword">for</span> day <span class="keyword">in</span> li:                           <span class="comment"># 遍历找到的每一个 li</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">7</span> &gt; i &gt; <span class="number">0</span>:</span><br><span class="line">                temp = []                        <span class="comment"># 临时存放每天的数据</span></span><br><span class="line">                date = day.find(<span class="string">&#x27;h1&#x27;</span>).string     <span class="comment"># 得到日期</span></span><br><span class="line">                date = date[<span class="number">0</span>:date.index(<span class="string">&#x27;日&#x27;</span>)]  <span class="comment"># 取出日期号</span></span><br><span class="line">                temp.append(date)</span><br><span class="line">                inf = day.find_all(<span class="string">&#x27;p&#x27;</span>)          <span class="comment"># 找出 li 下面的 p 标签,提取第一个p标签的值, 即天气</span></span><br><span class="line">                temp.append(inf[<span class="number">0</span>].string)</span><br><span class="line"></span><br><span class="line">                tem_low = inf[<span class="number">1</span>].find(<span class="string">&#x27;i&#x27;</span>).string  	<span class="comment"># 找到最低气温</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> inf[<span class="number">1</span>].find(<span class="string">&#x27;span&#x27;</span>) <span class="keyword">is</span> <span class="literal">None</span>:  	<span class="comment"># 天气预报可能没有最高气温</span></span><br><span class="line">                    tem_high = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tem_high = inf[<span class="number">1</span>].find(<span class="string">&#x27;span&#x27;</span>).string  <span class="comment"># 找到最高气温</span></span><br><span class="line">                temp.append(tem_low[:-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> tem_high[-<span class="number">1</span>] == <span class="string">&#x27;℃&#x27;</span>:</span><br><span class="line">                    temp.append(tem_high[:-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.append(tem_high)</span><br><span class="line"></span><br><span class="line">                wind = inf[<span class="number">2</span>].find_all(<span class="string">&#x27;span&#x27;</span>)		<span class="comment"># 找到风向</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> wind:</span><br><span class="line">                    temp.append(j[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line"></span><br><span class="line">                wind_scale = inf[<span class="number">2</span>].find(<span class="string">&#x27;i&#x27;</span>).string <span class="comment"># 找到风级</span></span><br><span class="line">                index1 = wind_scale.index(<span class="string">&#x27;级&#x27;</span>)</span><br><span class="line">                temp.append(<span class="built_in">int</span>(wind_scale[index1-<span class="number">1</span>:index1]))</span><br><span class="line">                final.append(temp)</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        self.data_cur = final_day</span><br><span class="line">        self.data_7 = final</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_to_csv</span>(<span class="params">self, day</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;保存为csv文件&quot;&quot;&quot;</span></span><br><span class="line">        file_name = self.city_name + <span class="string">&quot;.csv&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">if</span> day == <span class="number">14</span>:</span><br><span class="line">                header = [<span class="string">&#x27;日期&#x27;</span>, <span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;天气&#x27;</span>, <span class="string">&#x27;最低气温&#x27;</span>, <span class="string">&#x27;最高气温&#x27;</span>, <span class="string">&#x27;风向1&#x27;</span>, <span class="string">&#x27;风向2&#x27;</span>, <span class="string">&#x27;风级&#x27;</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                header = [<span class="string">&#x27;小时&#x27;</span>, <span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;温度&#x27;</span>, <span class="string">&#x27;风力方向&#x27;</span>, <span class="string">&#x27;风级&#x27;</span>, <span class="string">&#x27;降水量&#x27;</span>, <span class="string">&#x27;相对湿度&#x27;</span>, <span class="string">&#x27;空气质量&#x27;</span>]</span><br><span class="line">            f_csv = csv.writer(f)</span><br><span class="line">            f_csv.writerow(header)</span><br><span class="line">            f_csv.writerows(self.data_all)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    city_dict = &#123;<span class="string">&quot;南昌&quot;</span>: <span class="string">&quot;101240101&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;九江&quot;</span>: <span class="string">&quot;101240201&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;上饶&quot;</span>: <span class="string">&quot;101240301&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;抚州&quot;</span>: <span class="string">&quot;101240401&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;宜春&quot;</span>: <span class="string">&quot;101240501&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;吉安&quot;</span>: <span class="string">&quot;101240601&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;赣州&quot;</span>: <span class="string">&quot;101240701&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;景德镇&quot;</span>: <span class="string">&quot;101240801&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;萍乡&quot;</span>: <span class="string">&quot;101240901&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;新余&quot;</span>: <span class="string">&quot;101241001&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;鹰潭&quot;</span>: <span class="string">&quot;101241101&quot;</span>, &#125;</span><br><span class="line">    <span class="keyword">for</span> city_name, city_code <span class="keyword">in</span> city_dict.items():</span><br><span class="line">        <span class="keyword">if</span> city_name == <span class="string">&quot;景德镇&quot;</span>:</span><br><span class="line">            w = Weather(city_code, city_name)</span><br><span class="line">            w.run()</span><br></pre></td></tr></table></figure>

<p>生成的csv如图<br><img  
                     lazyload
                     alt="image"
                     data-src="/images/weather.png"
                     
                ></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐终端一些好用的命令行工具</title>
    <url>/2023/03/03/shell-%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>常年在macOS上开发已经习惯了用命令行了,所以有时间也会去倒腾一些有意思的命令替代工具,最近就发现了一些不错的替代命令,可以去github上搜一搜很多有意思的轮子</p>
<ul>
<li>替代ls的命令exa</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/exa.png"
                     
                >

<ul>
<li>替代du的命令dust</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/du.png"
                     
                >

<ul>
<li>替代df的命令duf</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/df.png"
                     
                >

<ul>
<li>替代grep的命令rg</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/cmdrg.png"
                     
                >

<ul>
<li>替代cat的命令bat</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/bat.png"
                     
                >
]]></content>
      <categories>
        <category>一些好用的工具</category>
      </categories>
  </entry>
  <entry>
    <title>发现一个很不错的vscode插件工具plantUML</title>
    <url>/2023/03/01/tool-umlPlant/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前每次写技术文档需要画图的时候都是通过飞书文档自带的工具或者processon去实现,实现的效果虽然勉强能看但是还是没有达到自己想要的效果,无意中在知乎上看到别人推荐,才是孤陋寡闻,在vscode里有对应的可视化插件plantUML和GraphvizPreview画出来的图是我想要的效果,需要用到对应的语言,准备这几天花点时间去琢磨一下.</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>简单基本使用了一下,可以用下面的代码看看效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Client -&gt; Server: EnterRoom</span><br><span class="line">Server -&gt; DB: GetRoomInfo</span><br><span class="line">DB -&gt; Server: RoomInfo</span><br><span class="line">Server -&gt; Client: success</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>琢磨中…</p>
]]></content>
      <categories>
        <category>一些好用的工具</category>
      </categories>
  </entry>
  <entry>
    <title>火焰图的使用</title>
    <url>/2023/03/02/tool-%E7%81%AB%E7%84%B0%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>参考链接: <a class="link"   href="https://www.ruanyifeng.com/blog/2017/09/flame-graph.html" >https://www.ruanyifeng.com/blog/2017/09/flame-graph.html<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>perf(performance)命令返回CPU正在执行的函数名及调用栈, 通常它的频率是99Hz(每秒统计99次)  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">record表示记录，-F 99表示每秒99次，-p 13204是进程号，-g表示记录调用栈，<span class="built_in">sleep</span> 30则是持续30秒</span></span><br><span class="line">sudo perf record -F 99 -p 13204 -g -- sleep 30</span><br></pre></td></tr></table></figure></li>
<li>火焰图是基于 perf 结果产生的 SVG 图片，用来展示 CPU 的调用栈<ul>
<li>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数</li>
<li>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的</li>
<li>火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”（plateaus），就表示该函数可能存在性能问题</li>
<li>调用栈: 底层函数调用上层函数, 也就是说真正在执行的是上层函数, 顶部函数宽度越宽说明抽样调查的时候大部分都在执行它, 也就是说执行时间长一些</li>
<li>局限情况<ul>
<li>调用栈不完整: 当调用栈过深时，某些系统只返回前面的一部分（比如前10层）</li>
<li>函数名缺失: 有些函数没有名字，编译器只用内存地址来表示（比如匿名函数）</li>
</ul>
</li>
</ul>
</li>
<li>火焰图生成工具: <a class="link"   href="https://github.com/brendangregg/FlameGraph" >https://github.com/brendangregg/FlameGraph<i class="fas fa-external-link-alt"></i></a>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install perf.x86_64</span><br><span class="line">git clone https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">export PATH=xxx/FlameGraph:$PATH</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或<span class="built_in">cp</span> -r xxx/FlameGraph/* ~/bin/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">both user and kernel</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">perf record -F 99 -a -g -- <span class="built_in">sleep</span> 60</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">only pid = 12345</span></span><br><span class="line">sudo perf record -F 99 -p 12345 -g -- sleep 60</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">perf script &gt; out.perf</span></span><br><span class="line"></span><br><span class="line">perf script -i perf.data &amp;&gt; perf.unfold</span><br><span class="line">./stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</span><br><span class="line">./flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></table></figure>
<ul>
<li>下载FlameGraph工具并添加环境变量 -&gt; perf record 生成记录 -&gt; perf script生成 unfold 文件 -&gt; stackcollapse-perf.pl生成 fold文件 -&gt; flamegraph.pl -&gt; 生成svg文件 -&gt; 浏览器打开perf.svg文件</li>
</ul>
</li>
</ul>
<p>一次测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/brendangregg/FlameGraph.git</span><br><span class="line">cd FlameGraph</span><br><span class="line"></span><br><span class="line">sudo perf record -F 99 -p 12345 -g -- sleep 60</span><br><span class="line">perf script -i perf.data &amp;&gt; perf.unfold</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里一定要注意是 stackcollapse-perf.pl , 不是其他的</span></span><br><span class="line">./stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</span><br><span class="line">./flamegraph.pl perf.folded &gt; perf.svg</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>一些好用的工具</category>
      </categories>
      <tags>
        <tag>性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>unity| 实现物体的转动组合</title>
    <url>/2023/03/08/unity-rotate/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>策划需要实现一个道具旋转的功能,这个功能如果单纯在unity去实现本身并不是很难,比如有DOTween就可以,但是项目技术架构调整之后,物体的位置数据需要在服务端进行计算,然而服务端还有很多unity相关的基建没有提供支持,比如物理碰撞之类的.<br>所以为了实现需要的效果就需要自己去实现很多位置变化,这里策划的需求主要需要满足以下几点:</p>
<ol>
<li>物体的旋转轴支持配置,目前有三种分别是xyz三个轴</li>
<li>物体旋转到指定的角度后需要停止等待指定的时间</li>
<li>物体在旋转到停止的时候需要抖动一下模拟物理效果</li>
<li>效果参考超级马里奥</li>
</ol>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/rotate_img.png"
                     
                >

<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>整个房子转动主要可以分为两部分，</p>
<ol>
<li>一部分是房子的转动部分，需要支持的配置为房子的转动轴(x|y|z)、转动速度<br>物体绕三个轴的转动目前在逻辑层的实现可以通过调用Transform的Rotate方法去实现<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">entity.transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>), angel, Space.World); <span class="comment">// 绕x轴旋转</span></span><br><span class="line">entity.transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), angel, Space.World); <span class="comment">// 绕y轴旋转</span></span><br><span class="line">entity.transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), angel, Space.World); <span class="comment">// 绕z轴旋转</span></span><br></pre></td></tr></table></figure>
旋转速度speed可以通过配置的方式平均到每个tick去计算旋转角angel</li>
<li>另一部分是房子转动状态的切换，房子的转动都是以90度为一个单元进行状态的切换<br>物体的旋转一般都是一个循环，旋转状态可以有三种：正转90度、停止、反转90度，然后按照需求去组合，最终会是一个循环链表，可以在地图重建的时候把这个循环链表一次性构建好用一个list去存储，之后就是按照链表循环去调用不同状态对应的旋转动作。</li>
<li>需要注意的是，每一次旋转停顿会有一个来回的扰动，这个扰动也可以单独抽出来做成一个函数用在每个状态结尾的时候执行，这个扰动可以通过让物体快速的来回旋转1度实现，通过调整度数和速度理论上可以达到效果<br>大概的状态流转如下，具体需要根据需求进行组合调整<img  
                     lazyload
                     alt="image"
                     data-src="/images/rotate_uml.png"
                     
                ></li>
</ol>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>因为在家里的电脑unity跑起来比较费劲,就用python实现了一个伪代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line">DELTA_TIME = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">const = &#123;</span><br><span class="line">    <span class="string">&quot;house&quot;</span>: &#123;<span class="string">&quot;stop_time&quot;</span>: <span class="number">2</span>, <span class="string">&quot;shake_angel&quot;</span>: <span class="number">1</span>, <span class="string">&quot;angel&quot;</span>: <span class="number">90</span>, <span class="string">&quot;cycle_states&quot;</span>: [<span class="number">1</span>, <span class="number">0</span>]&#125;,</span><br><span class="line">    <span class="string">&quot;red&quot;</span>: &#123;<span class="string">&quot;stop_time&quot;</span>: <span class="number">4</span>, <span class="string">&quot;shake_angel&quot;</span>: <span class="number">0</span>, <span class="string">&quot;angel&quot;</span>: <span class="number">180</span>, <span class="string">&quot;cycle_states&quot;</span>: [<span class="number">1</span>, <span class="number">0</span>]&#125;,</span><br><span class="line">    <span class="string">&quot;blue&quot;</span>: &#123;<span class="string">&quot;stop_time&quot;</span>: <span class="number">4</span>, <span class="string">&quot;shake_angel&quot;</span>: <span class="number">0</span>, <span class="string">&quot;angel&quot;</span>: <span class="number">180</span>, <span class="string">&quot;cycle_states&quot;</span>: [<span class="number">0</span>, <span class="number">1</span>]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, item_id: <span class="built_in">str</span>, speed: <span class="built_in">int</span>, axis: <span class="built_in">int</span></span>):</span><br><span class="line">        self.item_id: <span class="built_in">str</span> = item_id</span><br><span class="line">        self.speed: <span class="built_in">int</span> = speed</span><br><span class="line">        self.axis: <span class="built_in">int</span> = axis</span><br><span class="line"></span><br><span class="line">        self.cur_rotate: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.angel: <span class="built_in">int</span> = <span class="number">90</span></span><br><span class="line">        self.stop_time: <span class="built_in">int</span> = <span class="number">2</span>  <span class="comment"># second</span></span><br><span class="line">        self.cycle_states: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line">        self.cur_state_index: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.cur_stop_time: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.shake_angel: <span class="built_in">int</span> = <span class="number">1</span>  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rebuild</span>(<span class="params">self</span>):</span><br><span class="line">        config = const.get(self.item_id)</span><br><span class="line">        self.angel: <span class="built_in">int</span> = config.get(<span class="string">&quot;angel&quot;</span>, <span class="number">90</span>)</span><br><span class="line">        self.stop_time: <span class="built_in">int</span> = config.get(<span class="string">&quot;stop_time&quot;</span>, <span class="number">2</span>)</span><br><span class="line">        self.shake_angel: <span class="built_in">int</span> = config.get(<span class="string">&quot;shake_angel&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        self.cycle_states: <span class="type">List</span>[<span class="built_in">int</span>] = config.get(<span class="string">&quot;cycle_states&quot;</span>, [])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">positive_rotate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 正向旋转</span></span><br><span class="line">        tick_angel = (self.angel * DELTA_TIME / self.speed)</span><br><span class="line">        self.cur_rotate += tick_angel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.cur_rotate % self.angel == <span class="number">0</span>:</span><br><span class="line">            self.cur_state_index = (self.cur_state_index + <span class="number">1</span>) % <span class="built_in">len</span>(self.cycle_states)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;positive rotate <span class="subst">&#123;self.item_id&#125;</span> <span class="subst">&#123;self.cur_rotate&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">negative_rotate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 反向旋转</span></span><br><span class="line">        tick_angel = (self.angel * DELTA_TIME / self.speed)</span><br><span class="line">        self.cur_rotate -= tick_angel</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.cur_rotate % self.angel == <span class="number">0</span>:</span><br><span class="line">            self.cur_state_index = (self.cur_state_index + <span class="number">1</span>) % <span class="built_in">len</span>(self.cycle_states)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;negative rotate <span class="subst">&#123;self.item_id&#125;</span> <span class="subst">&#123;self.cur_rotate&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 停止</span></span><br><span class="line">        self.cur_stop_time += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.cur_stop_time == self.stop_time:</span><br><span class="line">            self.cur_state_index = (self.cur_state_index + <span class="number">1</span>) % <span class="built_in">len</span>(self.cycle_states)</span><br><span class="line">            self.cur_stop_time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;stop <span class="subst">&#123;self.item_id&#125;</span> <span class="subst">&#123;self.cur_rotate&#125;</span> <span class="subst">&#123;self.cur_stop_time&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shake</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 扰动</span></span><br><span class="line">        <span class="keyword">if</span> self.shake_angel == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        state = self.cycle_states[self.cur_state_index]</span><br><span class="line"></span><br><span class="line">        self.shake()</span><br><span class="line">        <span class="keyword">if</span> state == <span class="number">1</span>:</span><br><span class="line">            self.positive_rotate()</span><br><span class="line">        <span class="keyword">elif</span> state == -<span class="number">1</span>:</span><br><span class="line">            self.negative_rotate()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stop()</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_test2</span>():</span><br><span class="line">    r = Item(<span class="string">&quot;red&quot;</span>, <span class="number">4</span>, <span class="number">0</span>) <span class="comment"># 红色地板</span></span><br><span class="line">    r.rebuild() <span class="comment"># 场景重建</span></span><br><span class="line">    </span><br><span class="line">    b = Item(<span class="string">&quot;blue&quot;</span>, <span class="number">4</span>, <span class="number">0</span>) <span class="comment"># 蓝色地板</span></span><br><span class="line">    b.rebuild()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r.update()</span><br><span class="line">        b.update()</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        time.sleep(DELTA_TIME) <span class="comment"># 帧率</span></span><br></pre></td></tr></table></figure>

<h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C#实现"></a>C#实现</h2><p>在公司里基于项目的ECS架构测试了一下,大概的测试代码如下,从表现来看达到了想要的效果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">float</span> DELTA = (<span class="number">1000</span> / NetworkDefine.UPDATE_DELTATIME);  <span class="comment">// 1s中多少帧</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">float</span> ANGEL = <span class="number">180f</span>;       <span class="comment">//  每次停止前需要旋转的角度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">float</span> SPEED = <span class="number">2</span>;          <span class="comment">// 旋转速度 2秒转完 ANGEL</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> STOP_TIME_TICK = <span class="number">1</span> * (<span class="built_in">int</span>)DELTA;  <span class="comment">// 停下的时候等待时间为 1s</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> AXIS = <span class="number">2</span>;     <span class="comment">// 绕轴 0-x,1-y,2-z</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> curStopTick = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> curAngel = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="built_in">int</span>&gt; states = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">999</span>, <span class="number">0</span>, <span class="number">999</span> &#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> curStateIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> MAX_SHAKE_TIMES = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> curShakeIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> shakeAngel = <span class="number">1.33f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetAxis</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (AXIS == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AXIS == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Shake</span>(<span class="params">GameLogicEntity entity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> angel = (ANGEL / (SPEED * DELTA * <span class="number">5</span>));  <span class="comment">// 5是调整系数</span></span><br><span class="line">    <span class="keyword">if</span> (curShakeIndex % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        entity.transform.Rotate(GetAxis(), angel, Space.World);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        entity.transform.Rotate(GetAxis(), -angel, Space.World);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curShakeIndex++;</span><br><span class="line">    <span class="keyword">if</span> (curShakeIndex &gt;= MAX_SHAKE_TIMES)</span><br><span class="line">    &#123;</span><br><span class="line">        curShakeIndex = <span class="number">0</span>;</span><br><span class="line">        curStateIndex = (curStateIndex + <span class="number">1</span>) % states.Count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Positive</span>(<span class="params">GameLogicEntity entity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> angel = (ANGEL / (SPEED * DELTA));</span><br><span class="line">    curAngel += angel;</span><br><span class="line">    entity.transform.Rotate(GetAxis(), angel, Space.World);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">int</span>)curAngel % ANGEL &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        curStateIndex = (curStateIndex + <span class="number">1</span>) % states.Count;</span><br><span class="line">        curAngel %= ANGEL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Negative</span>(<span class="params">GameLogicEntity entity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> angel = (ANGEL / (SPEED * DELTA));</span><br><span class="line">    curAngel += angel;</span><br><span class="line">    entity.transform.Rotate(GetAxis(), -angel, Space.World);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">int</span>)curAngel % ANGEL &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        curStateIndex = (curStateIndex + <span class="number">1</span>) % states.Count;</span><br><span class="line">        curAngel %= ANGEL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>(<span class="params">GameLogicEntity entity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    curStopTick++;</span><br><span class="line">    <span class="keyword">if</span> (curStopTick == STOP_TIME_TICK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> nextIndex = (curStateIndex + <span class="number">1</span>) % states.Count;</span><br><span class="line">        curStateIndex = nextIndex;</span><br><span class="line">        curStopTick = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> entity <span class="keyword">in</span> <span class="keyword">this</span>.slidePipeGroup)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (entity.slidePipeLogic.mState == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> state = states[curStateIndex];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Positive(entity);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Negative(entity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Stop(entity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Shake(entity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>公司的项目技术架构是基于ECS开发的,这段代码如果要放到unity里去运行还是需要转换一下的,但是整体思路就是把物体的旋转变化用状态机去实现</li>
<li>物体的扰动通过来回旋转一个小角度可以实现</li>
<li>很多时候封装好的组件可以实现我们想要的效果,好处是足够专业,不太方便的是不够灵活,工作中有时间的话,尤其是没有轮子用的时候还是要去了解一些组件的实现用原理尝试着去造一下,也许效果没有那么专业,但至少在造的过程中知道可能出现的问题以及相对应的解决办法,对自己也是一种提升.</li>
</ol>
]]></content>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity| 实现物体的滚动效果</title>
    <url>/2023/03/08/unity-%E5%AE%9E%E7%8E%B0%E7%89%A9%E4%BD%93%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>最近接到一个需求需要实现一个给圆柱体推力让它滚动的效果,目前遇到的问题是运动逻辑是在服务器实现,而服务器的引擎方面的基建还差很多,没办法像unity那样实现比较逼真.<br>所以我就用unity去实现一个简单滚动效果的demo,unity开启一个3D的新工程,创建一个圆柱体,然后把旋转角的Z轴设置为90度让它躺下,position坐标设置为原点(0, 0, 0),给圆柱体添加刚体rigibody组件,然后绑定如下脚本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestRotate</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">float</span> force;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        force = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MovePosition</span>(<span class="params">Transform transform, Vector3 delta</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> pos = <span class="keyword">new</span> Vector3(transform.position.x + delta.x, transform.position.y + delta.y, transform.position.z + delta.z);</span><br><span class="line">        transform.position = pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveRotate</span>(<span class="params">Transform transform, Vector3 axis, <span class="built_in">float</span> angel</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Rotate(axis, angel, Space.Self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateDemo</span>(<span class="params">Transform transform, <span class="built_in">int</span> type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) <span class="comment">// 前滚</span></span><br><span class="line">        &#123;</span><br><span class="line">            MoveRotate(transform, <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), -force / <span class="number">1000</span>);</span><br><span class="line">            MovePosition(transform, <span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, force / <span class="number">10000</span>));</span><br><span class="line">            force -= <span class="number">1f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 后滚</span></span><br><span class="line">        &#123;</span><br><span class="line">            MoveRotate(transform, <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), -force / <span class="number">1000</span>);</span><br><span class="line">            MovePosition(transform, <span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, force / <span class="number">10000</span>));</span><br><span class="line">            force += <span class="number">1f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ListenKey</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.O))</span><br><span class="line">        &#123;</span><br><span class="line">            force = <span class="number">-1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.P))</span><br><span class="line">        &#123;</span><br><span class="line">            force = <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListenKey();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (force == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (force &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RotateDemo(transform, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RotateDemo(transform, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按下P键和O键可以给物体一个正向&#x2F;反向的推力让它滚动,如果需要滚动效果更真实一点的话需要计算好滚动的角度和位置移动偏差的关系.</p>
<p>如果在读武器需要沿着地面进行滚动的话,要么需要服务器支持给物体添加刚体效果,或者手动给物体持续施加一个向下的拉力达到重力效果.</p>
]]></content>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>vim| nvimdots的使用和配置</title>
    <url>/2023/03/08/vim-nvimdots%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>nvimdots的github仓库地址：<a class="link"   href="https://github.com/ayamir/nvimdots" >https://github.com/ayamir/nvimdots<i class="fas fa-external-link-alt"></i></a></p>
<p>按照说明的命令安装,因为我是macos,所以执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if command -v curl &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">    bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ayamir/nvimdots/HEAD/scripts/install.sh)&quot;</span><br><span class="line">else</span><br><span class="line">    bash -c &quot;$(wget -O- https://raw.githubusercontent.com/ayamir/nvimdots/HEAD/scripts/install.sh)&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>安装成功后，我想修改终端的颜色配置，找了半天发现在~&#x2F;.config&#x2F;nvim&#x2F;lua&#x2F;core&#x2F;settings.lua文件里进行修改,我按照自己喜欢的风格暂时修改了colorscheme为edge风格,background为light,后面有时间再重新配置一下颜色</p>
<p>我发现它默认是设置里相对行号的,我不太习惯这种风格找了一下配置，只要在~&#x2F;.config&#x2F;nvim&#x2F;lua&#x2F;core&#x2F;option.lua里修改relativenumber为false就行了,其他的基本配置也在这里面,摸索一下</p>
<p>简单的配置之后效果如图</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/nvimdots.png"
                     
                >

<p>在使用的过程中不知道快捷键怎么用可以在命令模式用Ctrl+p弹出help,比如我想看文件树,就在里面搜索file</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/nvimdotsfile1.png"
                     
                >

<p>图片里显示C-N(Ctrl+N)可以显示或者关闭文件树，试一下显示效果如图</p>
<img  
                     lazyload
                     alt="image"
                     data-src="/images/nvimdotsfile2.png"
                     
                >


<p>PS: 搭配wezterm终端或者kitty终端食用效果更佳</p>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim| vim基本配置</title>
    <url>/2023/02/28/vim-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>工作中无论是终端还是IDE都是习惯用vim进行代码编辑, 每次到新公司或者换电脑都得去配置一下, 虽然我基本不用插件,但是一些基本的配置改好之后界面会看着舒服很多.<br>为了怕自己忘记一些基本的配置,这边存一下vim的基本配置, 方便切换电脑的时候能快速把编辑环境配置好.</p>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; Set shift width to 4 spaces.</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Set tab width to 4 columns.</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Use space characters instead of tabs.</span></span><br><span class="line"><span class="keyword">set</span> expandtab</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Do not save backup files.</span></span><br><span class="line"><span class="keyword">set</span> nobackup</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Do not let cursor scroll below or above N number of lines when scrolling.</span></span><br><span class="line"><span class="keyword">set</span> scrolloff=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Do not wrap lines. Allow long lines to extend as far as the line goes.</span></span><br><span class="line"><span class="keyword">set</span> nowrap</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; While searching though a file incrementally highlight matching characters as you type.</span></span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Ignore capital letters during search.</span></span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Override the ignorecase option if searching for capital letters.</span></span><br><span class="line"><span class="comment">&quot; This will allow you to search specifically for capital letters.</span></span><br><span class="line"><span class="keyword">set</span> smartcase</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Show partial command you type in the last line of the screen.</span></span><br><span class="line"><span class="keyword">set</span> showcmd</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Show the mode you are on the last line.</span></span><br><span class="line"><span class="keyword">set</span> showmode</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Show matching words during a search.</span></span><br><span class="line"><span class="keyword">set</span> showmatch</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Use highlighting when doing a search.</span></span><br><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Set the commands to save in history default number is 20.</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">history</span>=<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Enable auto completion menu after pressing TAB.</span></span><br><span class="line"><span class="keyword">set</span> wildmenu</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Make wildmenu behave like similar to Bash completion.</span></span><br><span class="line"><span class="keyword">set</span> wildmode=lis<span class="variable">t:longest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; There are certain files that we would never want to edit with Vim.</span></span><br><span class="line"><span class="comment">&quot; Wildmenu will ignore files with these extensions.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> wildignore=*.docx,*.jpg,*.png,*.gif,*.pdf,*.pyc,*.<span class="keyword">exe</span>,*.flv,*.img,*.xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>                        <span class="comment">&quot; setting line       </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 光标定位到上次编辑位置</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&quot;autocmd&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">autocmd</span> BufReadPost *</span><br><span class="line">    \ <span class="keyword">if</span> <span class="built_in">line</span>(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">line</span>(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &lt;= <span class="built_in">line</span>(<span class="string">&quot;$&quot;</span>) |</span><br><span class="line">    \   <span class="keyword">exe</span> <span class="string">&quot;normal g`\&quot;&quot;</span> |</span><br><span class="line">    \ <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记| 数据密集型系统设计</title>
    <url>/2023/03/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 单台机器 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<ol>
<li>可靠性:<ul>
<li>硬件故障</li>
<li>软件错误</li>
<li>人为失误</li>
</ul>
</li>
<li>可扩展性<ul>
<li>描述负载 tweet例子 扇出数 读写负载</li>
<li>描述性能 负载增加系统资源不变会如何?负载增加维持性能需要多少资源?<ul>
<li>批处理系统(hadoop): 关注吞吐量</li>
<li>在线系统: 关注服务的响应时间 延迟是指请求花费在处理上的时间 响应时间是客户端看到的</li>
</ul>
</li>
<li>如何应对负载增加: 垂直扩展和水平扩展</li>
</ul>
</li>
<li>可维护性<ul>
<li>软件系统三个设计原则: 可运维性\简单性\可演化性(易于改变)</li>
</ul>
</li>
</ol>
<p>数据模型与查询语言<br>大多数应用程序是通过一层一层叠加数据模型来构建的,每一层面临的关键问题是如何将其用下一层来表示<br>    - 无模式(读时模式):数据的结构是隐式的,只有在读取时才解释,了类似于动态类型检查<br>    - 写时模式:数据的结构是显式,数据库确保写入时都必须遵循,类似于静态类型检查</p>
<ol>
<li>关系模型</li>
<li>文档模型</li>
<li>网络模型</li>
<li>层次模型</li>
<li>图数据模型</li>
</ol>
<p>数据查询语言:</p>
<ul>
<li>命令式:指定了特定的执行顺序</li>
<li>声明式:对并行更友好</li>
<li>MapReduce查询</li>
</ul>
<p>日志<br>索引: 增加写的复杂度,降低读的效率,平衡</p>
<ul>
<li>哈希索引: 文件格式 | 删除记录(墓碑) | 崩溃恢复(快照) | 部分写入的记录 | 并发控制(一个线程写,多个线程读)</li>
<li>LSM-Tree</li>
<li>B-Tree</li>
</ul>
<p>内存数据库可以更快的原因:避免使用写磁盘的格式对内存数据结构编码的开销</p>
<p>存储引擎两大类:</p>
<ol>
<li>OLTP在线事务处理: 通常使用索引中的某些键查找少量记录,根据用户的输入插入或更新记录(比如博客的评论)<ul>
<li>日志结构流派: 只允许追加式更新文件和删除过时文件, 随机写入转为顺序写入</li>
<li>原地更新流派: 将磁盘视为可以覆盖的一组固定大小的页,比如B-Tree</li>
</ul>
</li>
<li>OLAP在线分析处理: 查询需要扫描大量记录,每个记录只读取少数几列并计算汇总统计信息(比如计数\求和或平均值)</li>
</ol>
<p>数据编码: json xml csv<br>二进制编码: protobuf thrift avro<br>考虑兼容性问题:兼容性是执行编码的一个进程和执行解码的另一个进程之间的关系<br>进程间数据流动:</p>
<ul>
<li>通过数据库:归档存储</li>
<li>通过服务调用:  RPC  |  WEB(REST|SOAP)</li>
<li>通过异步消息传递: 消息队列  异步  削峰|异步|解耦</li>
</ul>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 分布式系统 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>目的: 扩展性(单台机器处理上限) 容错和高可用性(机器冗余) 延迟考虑(就近部署数据中心)<br>架构: </p>
<ul>
<li>垂直扩展: 共享内存架构(有限的容错能力)  共享磁盘架构(多适用于数据仓库,通常由于资源竞争以及锁的开销限制进一步的扩展能力)</li>
<li>水平扩展: 无共享结构.<br>数据分布机制:</li>
<li>复制</li>
<li>分区</li>
</ul>
<p>数据复制:</p>
<ul>
<li>主从复制<ul>
<li>复制机制: 同步复制(一致,可能会阻塞) 异步复制(吞吐量高,可能不一致,复制滞后问题) 半同步(保证至少有几个节点拥有最新的副本)</li>
<li>增加新的从节点: 主节点生成快照发给从节点,从节点追赶</li>
<li>处理节点失效: 从节点失效-追赶式恢复, 主节点失效-节点切换(心跳确认是否失效|选举|新主节点生效|脑裂)</li>
<li>复制实现:<ul>
<li>基于语句的复制</li>
<li>基于预写日志(WAL)传输</li>
<li>基于行的逻辑日志复制</li>
<li>基于触发器的复制</li>
</ul>
</li>
<li>复制滞后问题: 最终一致性(如果停止写数据库,经过一段时间滞后,从节点最终会赶上并与主节点保持一致)<ul>
<li>读自己的写:用户发起写请求然后在滞后的副本上读数据(比如评论),需要写后读一致性<ul>
<li>如果用户访问可能会被修改的内容,从主节点读取,否则在从节点读取.比如总是从主节点读取用户自己的首页配置文件,在从节点读取其他用户的配置文件</li>
<li>跟踪最近更新时间,比如更新后一分钟之内在主节点读取</li>
<li>客户端可以记住最近更新的时间戳并附带在读请求中</li>
<li>如果副本分布在多数据中心,必须先把请求路由到主节点所在的数据中心</li>
</ul>
</li>
<li>单调读:用户读到了最新内容之后又读到了过期的内容,好像时间被回拨,需要单调读一致性<ul>
<li>确保用户总是从固定的同一副本执行读取,可以通过用户ID的哈希方法去路由</li>
</ul>
</li>
<li>前缀一致读:分区数据经过多副本复制后出现了不同程度的滞后,导致观察者先看到果后看到因<ul>
<li>确保任何具有因果顺序关系的写入都交给一个分区来完成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多主节点复制</li>
<li>无主节点复制</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器| 服务器的那些错误码</title>
    <url>/2023/03/07/%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E9%94%99%E8%AF%AF%E7%A0%81/</url>
    <content><![CDATA[<p>服务器错误码的一些情况:</p>
<ol>
<li><p>Nginx错误码499</p>
<ul>
<li>499是 nginx扩展的 4xx 错误,目的只是用于记录,并没有实际的响应</li>
<li>源码: <code>#define NGX_HTTP_CLIENT_CLOSED_REQUEST     499</code>表示客户端请求还未返回时,客户端主动断开连接</li>
<li>原因: 超时时间设置短了;性能太差处理请求太慢了</li>
<li>解决: 设置<code>proxy_ignore_client_abort on;</code>在客户端主动关闭连接后,nginx与分发服务器的连接保持连接</li>
</ul>
</li>
<li><p>状态码5xx</p>
<ul>
<li>是否提醒用户重试 -&gt; 是 503 service unavailable</li>
<li>是否因为其他服务器导致 -&gt; 是 -&gt; 其他服务器是否有响应 -&gt; 是 502 BadGateway | 否 504 GateWayTimeout</li>
<li>是否需要向终端显示错误 -&gt; 是 501 NotImplemented</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式基本原则</title>
    <url>/2023/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="DesignPatternByPython"><a href="#DesignPatternByPython" class="headerlink" title="DesignPatternByPython"></a>DesignPatternByPython</h1><h2 id="设计问题"><a href="#设计问题" class="headerlink" title="设计问题"></a>设计问题</h2><ol>
<li>僵化性：很难对系统进行改动，因为每个改动都会迫使许多对系统其他部分的改动</li>
<li>脆弱性：对系统的改动会导致系统中和改动的地方在概念无关的许多地方出现问题</li>
<li>牢固性：使之成为一些可在其他系统中重用的组件</li>
<li>粘滞性：做正确的事情比做错误的事情要困难</li>
<li>不必要的复杂性：设计中包含不具有任何好处的基础结构</li>
<li>不必要的重复：设计中包含有重复结构，而该重复结构本可以使用单一的抽象进行统一</li>
<li>晦涩性：很难阅读、理解，没有很好的表现出意图</li>
</ol>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li><p>单一职责原则<code>SRP</code>：就一个类而言，应该仅有一个引起它变化的原因</p>
<ul>
<li>职责指的是“变化的原因”</li>
</ul>
</li>
<li><p>开放封闭原则<code>OCP</code>：软件实体（类、模块、函数等）应该是可以扩展的，但是不可修改的。</p>
<ul>
<li><p><strong>封闭是建立在抽象和多态的基础之上的</strong></p>
</li>
<li><p>对扩展开发，对接口关闭</p>
</li>
<li><p>无论模块多么封闭，都会存在一些无法对之封闭的变化</p>
</li>
<li><p>在我们认为可能发生变化的地方hook</p>
</li>
</ul>
</li>
<li><p><code>Liskov</code>替换原则<code>LSP</code>：子类型必须能够替换他们的基类型</p>
<ul>
<li>派生类的is-a关系是基于行为判断的</li>
</ul>
</li>
<li><p>依赖倒置原则<code>DIP</code>：上层模块 -&gt; 抽象 -&gt; 下层模块</p>
<ul>
<li>上层模块不应该依赖底层模块，它们都应该依赖于抽象</li>
<li>抽象不应该依赖于细节，细节应该依赖于抽象</li>
<li>原则<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用</li>
<li>任何类都不应该从具体类派生</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现了的方法</li>
</ul>
</li>
</ul>
</li>
<li><p>接口隔离原则<code>ISP</code>：不应该强迫客户依赖于它们不用的方法</p>
<ul>
<li>使用多个专门的接口比使用单个接口要好很多</li>
</ul>
</li>
<li><p>迪米特法则(最少知识原则)：一个类对于其他类知道的越少越好</p>
</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><ul>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问，在直接访问对象时带来的问题</li>
<li>外观模式：隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口</li>
</ul>
<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><ul>
<li>中介者模式：降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信</li>
<li>观察者模式：对象间存在一对多关系时，当一个对象被修改时会自动通知依赖它的对象</li>
<li>命令模式：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化</li>
</ul>
<h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><ul>
<li>单例模式：类负责创建自己的对象，同时确保只有单个对象被创建</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
</search>
