<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="RibinCao">
    
    <title>
        
            C++| 基础学习之网络编程 |
        
        Ribin
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"toc":{"enable":false,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/logo.png","favicon":"/images/logo.png","avatar":"/images/avatar.png","font_size":null,"font_family":"STKaiti","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":true}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":false,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":true,"min2read":true},"img_align":"center","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.png">
                </a>
            
            <a class="logo-title" href="/">
               Ribin
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                系列
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                个人简历
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">系列</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">个人简历</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">C++| 基础学习之网络编程</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">RibinCao</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-03-07 14:39:33</span>
        <span class="mobile">2023-03-07 14:39</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-03-07 15:04:44</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/C/">C++</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="C-网络编程"><a href="#C-网络编程" class="headerlink" title="C++网络编程"></a>C++网络编程</h1><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p>OSI七层模型</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/TCP_IP.png"
                     
                >

<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>方法</p>
<ul>
<li>GET — 获取资源</li>
<li>HEAD — 获取报文首部。和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。</li>
<li>POST — 传输实体主体。POST 主要用来传输数据，而 GET 主要用来获取资源</li>
<li>PUT — 上传文件。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</li>
<li>PATCH — 对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改</li>
<li>DELETE — 删除文件。与 PUT 功能相反，并且同样不带验证机制</li>
<li>OPTIONS — 查询支持的方法<br>查询指定的 URL 能够支持的方法</li>
<li>CONNECT — 要求在与代理服务器通信时建立隧道。使用 SSL(Secure Sockets Layer，安全套接层)和 TLS(Transport Layer Security，传输层安全)协议把通信内容加密后经网络隧道传输</li>
<li>TRACE — 追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪</li>
</ul>
<p>返回码</p>
<ul>
<li>1XX 信息<ul>
<li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
</li>
<li>2XX 成功<ul>
<li>200 OK</li>
<li>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
</li>
<li>3XX 重定向<ul>
<li>301 Moved Permanently ：永久性重定向</li>
<li>302 Found ：临时性重定向</li>
<li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。<br>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
</li>
<li>4XX 客户端错误<ul>
<li>400 Bad Request ：请求报文中存在语法错误。</li>
<li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Forbidden ：请求被拒绝。</li>
<li>404 Not Found</li>
</ul>
</li>
<li>5XX 服务器错误<ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>
</li>
</ul>
<p>###TCP&#x2F;IP</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/TCPheader.png"
                      width="400"
                >

<img  
                     lazyload
                     alt="image"
                     data-src="./img/UDPheader.png"
                      width="400"
                >

<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><img  
                     lazyload
                     alt="image"
                     data-src="./img/TCP.svg"
                      width="600"
                >

<h3 id="服务端编程"><a href="#服务端编程" class="headerlink" title="服务端编程"></a>服务端编程</h3><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>为了执行网络I&#x2F;O, 一个进程必须做的第一件事情就是调用socket函数, 指定一个期望的通信协议类型来创建一个套接字描述符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - family(协议族)</span></span><br><span class="line"><span class="comment">            - AF_INET   : IPv4协议</span></span><br><span class="line"><span class="comment">            - AF_INET6  : IPv6协议</span></span><br><span class="line"><span class="comment">            - AF_LOCAL  : Unix域协议</span></span><br><span class="line"><span class="comment">            - AF_ROUTE  : 路由套接口</span></span><br><span class="line"><span class="comment">            - AF_KEY    : 密钥套接口</span></span><br><span class="line"><span class="comment">        - type(类型)</span></span><br><span class="line"><span class="comment">            - SOCK_STREAM   : 字节流套接口</span></span><br><span class="line"><span class="comment">            - SOCK_DGRAM    : 数据报套接口</span></span><br><span class="line"><span class="comment">            - SOCK_RAW      : 原始套接口</span></span><br><span class="line"><span class="comment">        - protocol: 除原始套接口外一般设置为 0 </span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - sockfd : 非负 int</span></span><br><span class="line"><span class="comment">        - -1 : 创建套接字失败</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里socket函数通过指定协议族、类型创建了一个int类型的套接字描述符相当于你告诉别人准备用哪国的语言和别人聊天。<br>在这一阶段有一种出错的可能就是创建套接字失败，这个时候socket函数会返回-1.</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>当你约定好了用哪种语言和方式进行聊天的时候，但是别人不知道上哪写信给你，所以你还需要告诉别人你在哪个小区(IP)的哪个房间编号(端口)，完成这一步动作需要分两步去做</p>
<ol>
<li>将你的具体地址写在一张纸上并翻译成邮寄员能看懂的形式</li>
<li>将翻译后的地址和你准备聊天的语言和方式绑定在一起交给邮寄员，写信给你的人只要把信寄到邮政局，邮寄员就可以根据你的地址把信交给你</li>
</ol>
<p>先说第一步，我们需要在纸上(sockaddr_in)写下自己的地址，然后通过字节排序函数(htons)把地址翻译一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>	servaddr;</span><br><span class="line">servaddr.sin_family      = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">servaddr.sin_port        = <span class="built_in">htons</span>(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  字节排序函数: 主机字节序 -&gt; 网络字节序</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span></span>;<span class="comment">//  Host to Network Short</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> host16bitvalue)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> host32bitvalue)</span></span>;</span><br></pre></td></tr></table></figure>

<p>为什么要对地址进行字节排序呢？因为网络里传输的字节是按照大端模式进行排序的，而主机里通常是按照小端模式排序的，所以需要对地址和端口进行字节排序才不会被邮寄员搞错地址。</p>
<p>在这一步可能会有一个疑问，如果地址不填会怎么样呢？</p>
<ol>
<li>如果不指定IP的话，可以选择INADDR_ANY参数，调用bind函数的时候服务器内核会把客户所发SYN分组里的目的IP作为服务器的IP(真是有够聪明)</li>
<li>同样，如果不想指定某个端口，可以将端口设置为0，调用bind函数的时候内核会选择一个临时端口</li>
</ol>
<p>然后是第二步，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *servaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - sockfd:   需要绑定的套接字描述符</span></span><br><span class="line"><span class="comment">        - servaddr: 指向特定协议地址结构的指针</span></span><br><span class="line"><span class="comment">        - addrlen:  该地址结构的长度</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 0 : 成功</span></span><br><span class="line"><span class="comment">        - -1: 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在这一步有几种出错的可能:</p>
<ul>
<li>EADDRINUSE: Address already in use</li>
<li>SO_REUSEADDR</li>
<li>SO_REUSEPORT</li>
</ul>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>等把地址和协议都绑定好了，就在家里等着别人给你写信了，这一步需要调用listen函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - sockfd:   需要监听的套接字</span></span><br><span class="line"><span class="comment">        - backlog:  已连接和同步接收套接字个数的最大值, 不要定义为0, 一般设为 LISTENQ</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 0 : 成功</span></span><br><span class="line"><span class="comment">        - -1: 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这一步的成功标志着: 服务端进入了<strong>LISTEN</strong>状态, </p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><p>经过上一步的listen函数成功调用后，我们就在家里等着收信，服务端需要调用accept函数时刻观察着有没有请求到来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *cliaddr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - sockfd: 之前创建的监听套接字</span></span><br><span class="line"><span class="comment">        - cliaddr: 指向客户端套结构地址的指针</span></span><br><span class="line"><span class="comment">        - addrlen: 指向客户端套结构地址长度的指针</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 非负描述字: 一个已连接的套接字描述符 connfd</span></span><br><span class="line"><span class="comment">        - -1 : 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这个时候会出现以下几种情况:</p>
<ol>
<li>没有请求。accept调用阻塞等待客户端的请求，服务端还是处于<strong>LISTEN</strong>状态</li>
<li>收到客户端SYN请求分组。服务端返回给客户端ACK分组同时带上自己的SYN数据等待客户端返回的ACK分组，然后进入<strong>SYN_RCVD</strong>状态</li>
<li>服务端收到客户端返回的ACK分组。accept返回一个连接套接字，服务端进入<strong>ESTABLISHED</strong>.这个时候服务端处理请求(比如read)的函数会阻塞等待客户端的数据</li>
<li>服务端一直没有收到返回的ACK分组?</li>
<li>服务端收到了客户端其他的回复,比如RST，服务端会返回ECONNABORTED错误然后忽略它再次调用accept</li>
</ol>
<p>####close</p>
<p>服务端的关闭虽然只有一个close函数，但是过程还是比较复杂的。<br>首先客户端发送FIN分组给服务端请求关闭，服务端收到FIN分组，处理函数(比如read)返回，服务端被动关闭返回ACK分组给客户端进入<strong>CLOSE_WAIT</strong>状态；<br>然后服务端调用close函数向客户端发送FIN分组给客户端等待客户端的回复，服务端进入<strong>LAST_ACK</strong>状态；<br>最后服务端收到客户端的ACK分组后进入<strong>CLOSED</strong>状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params: sockfd -- 需要关闭的套接字描述符</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 0 -- 完成</span></span><br><span class="line"><span class="comment">        - -1 -- 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在服务端的关闭过程中可能会出现的情况有:</p>
<ol>
<li>服务端没有收到客户端的FIN分组</li>
<li>客户端一直没有收到服务端返回的ACK(服务端关机、崩溃等)</li>
<li>客户端一直没有收到服务端的FIN分组(服务端关机、崩溃等)</li>
<li>服务端一直没有收到客户端返回的ACK分组</li>
</ol>
<h3 id="客户端编程"><a href="#客户端编程" class="headerlink" title="客户端编程"></a>客户端编程</h3><h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h4><p>和服务端一样, 为了执行网络I&#x2F;O一个进程必须做的第一件事情就是调用socket函数, 指定一个期望的通信协议类型来创建一个套接字描述符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - family(协议族)</span></span><br><span class="line"><span class="comment">            - AF_INET   : IPv4协议</span></span><br><span class="line"><span class="comment">            - AF_INET6  : IPv6协议</span></span><br><span class="line"><span class="comment">            - AF_LOCAL  : Unix域协议</span></span><br><span class="line"><span class="comment">            - AF_ROUTE  : 路由套接口</span></span><br><span class="line"><span class="comment">            - AF_KEY    : 密钥套接口</span></span><br><span class="line"><span class="comment">        - type(类型)</span></span><br><span class="line"><span class="comment">            - SOCK_STREAM   : 字节流套接口</span></span><br><span class="line"><span class="comment">            - SOCK_DGRAM    : 数据报套接口</span></span><br><span class="line"><span class="comment">            - SOCK_RAW      : 原始套接口</span></span><br><span class="line"><span class="comment">        - protocol: 除原始套接口外一般设置为 0 </span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - sockfd : 非负 int</span></span><br><span class="line"><span class="comment">        - -1 : 创建套接字失败</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>和服务端不同的是，客户端不需要明确的去bind和listen，而是直接通过connect函数向指定的服务端发送连接请求。这里的sockaddr结构体类型和之前TCP服务端博客里bind函数使用的sockaddr一样，调用的时候都需要使用(SA *)进行转型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *servaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">        - sockfd: 之前socket函数调用创建的套接字描述符</span></span><br><span class="line"><span class="comment">        - servaddr: 指向特定协议地址结构的指针</span></span><br><span class="line"><span class="comment">        - addrlen: 该地址结构的长度</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">    		- 成功：0</span></span><br><span class="line"><span class="comment">    		- 错误： -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>当客户端调用connect函数后会发送SYN分组给目标服务端然后进入<strong>SYN_SENT</strong>状态等待服务端的ACK确认分组。这个时候会出现几种情况:</p>
<ol>
<li>客户端一直没有收到ACK回复。客户端会6s、24s后重复再发一次，总共等75s后还是没有响应就会返回错误码ETIMEDOUT</li>
<li>客户端收到服务端的ACK分组回复后进入<strong>EXTABLISHED</strong>状态</li>
</ol>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p>客户端的close函数和服务端一样，但是通常都是客户端先调用close函数主动关闭然后发送FIN分组非服务端，同时进入<strong>FIN_WAIT_1</strong>状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params: sockfd -- 需要关闭的套接字描述符</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 0 -- 完成</span></span><br><span class="line"><span class="comment">        - -1 -- 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>在客户端的关闭过程中可能会出现的情况有:</p>
<ol>
<li>客户端调用close函数进入<strong>FIN_WAIT_1</strong>状态，客户端一直没有收到服务端的ACK分组响应。</li>
<li>客户端收到ACK响应后进入<strong>FIN_WAIT_2</strong>状态，但是迟迟没有收到服务端发来的FIN分组。</li>
<li>客户端收到服务端的FIN分组。返回ACK进行响应然后进入<strong>TIME_WAIT</strong>状态</li>
</ol>
<p>客户端之所以要有以一个<strong>TIME_WAIT</strong>状态有两个原因:</p>
<ol>
<li>让之前迷路的分组在网络中消失。假如某个套接字对断开连接后因为新的请求再次连接，服务端在这个时候如果收到了上一个连接中在网络中迷失就不知道怎么处理了，设置<strong>TIME_WAIT</strong>状态就是让这些可能因为路由故障而迷路的分组在网络中消失</li>
<li>实现TCP全双工连接的可靠终止。客户端收到服务端的FIN分组并响应ACK分组，如果这个时候因为某种原因服务端没有收到这个ACK分组则会再次发送FIN分组，客户端就可以在<strong>TIME_WAIT</strong>状态下处理这个FIN分组</li>
</ol>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>相对于TCP套接字，UDP套接字要简单一些。UDP是一种不可靠的传输协议，不像TCP需要靠ACK机制来确认对方有没有收到自己传来的数据</p>
<h4 id="socket和bind"><a href="#socket和bind" class="headerlink" title="socket和bind"></a>socket和bind</h4><p>对于UDP客户端来说，它只要调用socket函数创建一个套接字就可以向服务端发送数据。<br>而对于服务端来说也只是在socket调用的基础上再调用bind函数绑定地址和端口，这两个函数和TCP套接字没有差别</p>
<h4 id="sendto和recvfrom"><a href="#sendto和recvfrom" class="headerlink" title="sendto和recvfrom"></a>sendto和recvfrom</h4><p>当客户端创建好套接字后就可以通过sendto调用去发送请求，同时调用recvfrom去处理服务端的响应。<br>同样，UDP的服务端通过recvfeom去接收客户端的请求然后通过sendto函数去响应客户端，一气呵成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>recvfrom和sendto类似于标准的write和read函数，只不过它有三个附加参数</p>
<ol>
<li>flags: 一般设为0</li>
<li>to&#x2F;from: 含有数据将发生的协议地址的套接口地址</li>
<li>最后一个参数: recvfrom传的是指针，sendto传的是数值</li>
</ol>
<h4 id="close-1"><a href="#close-1" class="headerlink" title="close"></a>close</h4><p>通常客户端完成任务之后会主动调用close函数直接关闭，不需要像TCP那样使用四次挥手和TIME_WAIT机制</p>
<h2 id="TCP和UDP比较"><a href="#TCP和UDP比较" class="headerlink" title="TCP和UDP比较"></a>TCP和UDP比较</h2><h3 id="TCP到底可靠在哪"><a href="#TCP到底可靠在哪" class="headerlink" title="TCP到底可靠在哪"></a>TCP到底可靠在哪</h3><h4 id="ACK机制"><a href="#ACK机制" class="headerlink" title="ACK机制"></a>ACK机制</h4><p>由于通信过程的不可靠性，传输的数据不可避免的会出现丢失、延迟、错误、重复等各种状况，TCP协议为解决这些问题设计了一系列机制。<br>这个机制的核心，就是发送方向接收方发送数据后，接收方要向发送方发送ACK（回执）。<br>如果发送方没接收到正确的ACK，就会重新发送数据直到接收到ACK为止。比如：发送方发送的数据序号是seq，那么接收方会发送seq + 1作为ACK，这样发送方就知道接下来要发送序号为seq + 1的数据给接收方了。</p>
<p>这个机制在面对几种出错的情况会有对应的处理:</p>
<ol>
<li>数据丢失或延迟。发送方发送数据seq时会起一个定时器，如果在指定时间内没有接收到ACK seq + 1，就把数据seq再发一次。</li>
<li>数据乱序。接收方上一个收到的正确数据是seq + 4，它返回seq + 5作为ACK。这时候它收到了seq + 7，因为顺序错了，所以接收方会再次返回seq + 5给发送方。</li>
<li>数据错误。每一个TCP数据都会带着数据的校验和。接收方收到数据seq + 3以后会先对校验和进行验证。如果结果不对，则发送ACK seq + 3，让发送方重新发送数据。</li>
<li>数据重复。接收方直接丢弃重复的数据即可。</li>
</ol>
<p>按照ACK机制，只要整个数据传输顺利结束，接收方就能收到完整有序的数据了。<br>但是，如果我们针对每一个数据包都发送ACK，就会有大量的网络资源消耗在ACK的发送上，这不太划算的。于是，TCP设计了延迟ACK的机制<br>这个机制其实很简单。客户端一次给服务器发送多个数据包，当服务器收到客户端的数据包时，不马上发送ACK，而是稍微等一小段时间。在这个过程中服务器可能能收到后续几个数据包，服务器就可以直接按照最后一个正确的数据发送ACK，减少发送ACK的总数。<br>当发送错误的时候，会发生：</p>
<ol>
<li>超时重传机制<br>发送方发送的报文中含有序列号，每当发送一个报文后，就启动一个计时器（RTO），该计时器的时间一般是有当前网络来决定的，一个RTT指的是当一个报文从发送到接收到对应的ACK标志的时间，RTO的决定一般是发送方尝试发送几个报文，然后取平均RTT时间来决定计时器的值。 当发送一个报文以后，发送方在计时范围以内，如果没有接收到相应的ACK确认报文，那么发送方就会重传该报文。</li>
<li>快速重传机制<br>该机制指的是，发送方一直发送报文，不会每发一次报文就都要等待到这个报文的ACK标志才发送下个报文。 当接收方发现接受的序列号不对的时候，发送连续的3个ACK标志，告诉发送方，这个报文在传输过程中出现了丢包。发送方如果接收到某个相同序列号的三个ACK报文，那么此时立马重发该报文，不用等待计时器的时间结束。</li>
</ol>
<h4 id="流量控制-滑动窗口"><a href="#流量控制-滑动窗口" class="headerlink" title="流量控制(滑动窗口)"></a>流量控制(滑动窗口)</h4><p>流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。<br>发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。此时发送方的报文分为四类， 第一类是已经发送并且得到接收方确认的报文，第二类是已经发送但是没有接收到确认的报文，第三类是发送方还没发送，但是滑动窗口还足够巨大，允许被发送的报文， 第四类是还没发送并且窗口已经被占满，不允许发送的报文。 一般来说，滑动窗口的最左端都是介于第一类跟第二类报文的分界线，最右端是第三类跟第四类报文的分界线。</p>
<p>滑动窗口的流量控制可以包括那么几个协议：</p>
<ol>
<li>停等协议。 滑动窗口的大小为1， 每个发送报文都要等到被确认以后，发送方才继续发送下一个报文。</li>
<li>后退n步协议。 该协议下，滑动窗口大于1，发送方可以一直发送报文，但是当接收到接收方发送的三个连续的同一序列号的ACK报文时，说明该序列号的报文是已经丢失的，那么此时重发该丢失报文以及该报文以后的报文（包括那些已经发送的）。</li>
<li>选择重传。在后退n步协议当中，如果某个报文丢失，那么将要重新发送这个丢失报文及以后的所有报文（包括已经发送的），选择重传协议不用做此要求，只要重新发送丢失的报文即可。</li>
</ol>
<p>滑动窗口协议有:</p>
<ol>
<li>停等协议，发送窗口&#x3D;1，接受窗口&#x3D;1；</li>
<li>退后N帧协议，发送&gt;1,接收&#x3D;1;</li>
<li>选择重传协议，发送&gt;1,接收&gt;1;</li>
</ol>
<p>设主机A向主机B发送数据。双方确定的窗口值是400.再设每一个报文段为100字节长，序号的初始值为seq&#x3D;1,图中的箭头上面大写ACK，表示首部中的却认为为ACK，小写ack表示确认字段的值。<br>接收方的主机B进行了三次流量控制。第一次把窗口设置为rwind&#x3D;300，第二次减小到rwnd&#x3D;100最后减到rwind&#x3D;0，即不允许发送方再发送过数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。<br>假如，B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd&#x3D;400的报文段，然而这个报文段在传送中丢失 了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。这样就死锁了。为了解决这种死锁状态，TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若计时器的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>首先要明白拥塞控制与流量控制有什么不同，流量控制考虑的是单纯的发送方与接收方，这两个在全部网络过程中的两个端点。而拥塞控制考虑的是整个网络，防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。可以想象一下，在流量控制当中，接收方跟发送方考虑的只是自己的报文有没有发送并且被接收的问题，假设现在网络阻塞，在超时重传机制当中，发送方没有发送后在计时器时间内没有接收到确认报文，就立马重新发送报文，这时候对已经拥塞的网络来说，无异于雪上加霜。同样实在拥塞的网络情况下，考虑下快速重传机制，同样是这个道理。所以，针对以上问题，TCP应该要有一个拥塞控制机制，不然，后果不堪设想。<br>在拥塞控制机制中，发送方维持一个叫做拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就增大一些，以便把更多的分组发送出去。但是只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络的分组数。</p>
<p>下面说明下几个符号说明：</p>
<ul>
<li>cwnd：拥塞窗口大小</li>
<li>ssthreshold: 拥塞阈值 （该阈值是对网络状况的一个预估，决定在拥塞窗口多大的时候采取怎样的策略，它的初始化一般是一个估计，一般都会给出）<br>现在可以看下这个拥塞控制机制包括哪几个策略</li>
</ul>
<ol>
<li>慢启动:此时一般是（记住是一般情况）cwnd&lt;ssthreshold，此时cwnd呈指数形式增长，1、2、4、8、16、32…这种增长趋势</li>
<li>拥塞避免:此时一般cwnd&gt;ssthreshold，此时cwnd呈线性增长，32、33、34、35…这种增长趋势</li>
<li>拥塞解决:此时一般是遇到了网络拥塞的状况，解决方法是拥塞阈值乘性减即ssthreshold&#x3D;cwnd&#x2F;2，cwnd&#x3D;1，或者ssthreshold&#x3D;cwnd&#x2F;2，cwnd&#x3D;ssthreshold，这两种情况在后面说明</li>
<li>快速恢复:一般是启用拥塞解决策略之后，根据不同的情况，进入慢启动或者拥塞避免阶段。</li>
</ol>
<p>假设ssthreshold&#x3D;8，首先肯定是慢启动阶段，cwnd增长，1、2、4、8，到8的时候，cwnd达到了ssthreshold的值，于是进入拥塞避免阶段，cwnd继续增长8、9、10，假设到10的时候，发生了网络拥塞，这时候拥塞分为两种情况：</p>
<ol>
<li>发送方接收到同一序列号的报文的连续三个ACK确认报文，说明出现了丢包，但是接收到接收方发送的丢包信号，说明网络情况还是相对较好的，于是此时发送方做出反应，将ssthreshold&#x3D;cwnd&#x2F;2&#x3D;5，cwnd&#x3D;ssthreshold&#x3D;5，然后进入拥塞避免阶段，cwnd继续以5、6、7…这种情况增长。</li>
<li>发送方接收到同一序列号的报文连续两个ACK确认报文，这时候，就说明网络拥塞情况就比较严重了，连接收方发送的丢包信号都不完整了，这个时候得采取更加严厉的措施了，于是ssthreshold&#x3D;cwnd&#x2F;2，cwnd&#x3D;1，然后重新进入慢启动过程。</li>
</ol>
<p>###TCP和UDP的区别</p>
<ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP提供可靠的服务，也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
</ol>
<h3 id="如何实现可靠UDP"><a href="#如何实现可靠UDP" class="headerlink" title="如何实现可靠UDP"></a>如何实现可靠UDP</h3><p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。<br>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。<br>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ol>
<li>添加seq&#x2F;ack机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要用于用户超时重传。</li>
<li>添加超时重传机制。</li>
</ol>
<p>详细说明：送端发送数据时，生成一个随机seq&#x3D;x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack&#x3D;x+1的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。如果超过一定时间还没收到ack，那么重传数据。<br>目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。</p>
<h2 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><h3 id="同步和异步-阻塞和非阻塞"><a href="#同步和异步-阻塞和非阻塞" class="headerlink" title="同步和异步?阻塞和非阻塞?"></a>同步和异步?阻塞和非阻塞?</h3><p>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：<br>    1）等待数据准备 (Waiting for the data to be ready)<br>    2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</p>
<p>同步和异步是相对于被调用方来说的。<br>阻塞和非阻塞是相对于调用方来说的。</p>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO指的是阻塞式IO, 以UDP套接字为例, 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。<br>对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。<br>而在用户进程这边，整个进程会被阻塞。<br>当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。<br>所以，阻塞式IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。<br><img  
                     lazyload
                     alt="image"
                     data-src="./img/BIO.svg"
                      width="400"
                ></p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO指的是非阻塞式IO, 进程把一个套接字设置成非阻塞是在通知内核: 当所请求的IO操作非得把本进程置于休眠状态才能完成时, 不要把本进程置于休眠状态而是返回一个错误.<br>通俗的说就是进程系统调用获取数据时, 内核无论有没有数据都马上返回个东西给 进程<br>这种模式通过调用read、write的时候指定 O_NONBLOCK 参数。和“同步阻塞”模式的区别在于系统调用的时候它是以非阻塞的方式执行，无论是否有数据都会立即返回。<br>以read为例，如果成功读取到数据它返回读取到的字节数；如果此时没有数据则返回-1，同时设置errno为EAGAIN（或者EWOULDBLOCK，二者相同）。所以这种模式下我们一般会用一个“循环”不停的尝试读取数据，处理数据。<br>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<br>所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。使用如下的函数可以将某句柄fd设为非阻塞状态<br><img  
                     lazyload
                     alt="image"
                     data-src="./img/NIO.svg"
                      width="400"
                ><br>上图这种循环调用recvfrom的方式称为轮询(polling)</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>I&#x2F;O复用可以阻塞在这两个系统调用中的某一个, 而不是阻塞在真正的IO系统调用上</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>我们阻塞于select调用等待数据报套接字变为可读。<br>当select返回套接字可读这一条件时，我们调用recvfrom把所读数据报复制到应用进程缓冲区。<br>由于使用select需要两个而不是单个系统调用使得IO复用稍有劣势</p>
<img class="..&#x2F;imgs&#x2F;svg&#x2F;IOMultiplexing.svg IO复用 IO复用模型 50">
<p>select每次要轮询，数据的到来阻塞和从内核到进程阻塞，每次都要将描述符集合在进程和内核空间之间切换，1024限制</p>
<p>select函数允许进程指示内核等待多个事件中的任何一个发生, 并在只有一个或多个事件发生或经历一段时间后才唤醒它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    params:</span></span><br><span class="line"><span class="comment">    return:</span></span><br><span class="line"><span class="comment">        - 若有就绪描述符则为其数目</span></span><br><span class="line"><span class="comment">        - 超时返回 0</span></span><br><span class="line"><span class="comment">        - 出错返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>			maxfdp1, stdineof;</span><br><span class="line">	fd_set		rset;</span><br><span class="line">	<span class="type">char</span>		buf[MAXLINE];</span><br><span class="line">	<span class="type">int</span>		n;</span><br><span class="line"></span><br><span class="line">	stdineof = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">FD_ZERO</span>(&amp;rset);</span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		<span class="keyword">if</span> (stdineof == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">FD_SET</span>(<span class="built_in">fileno</span>(fp), &amp;rset);</span><br><span class="line">		<span class="built_in">FD_SET</span>(sockfd, &amp;rset);</span><br><span class="line">		maxfdp1 = <span class="built_in">max</span>(<span class="built_in">fileno</span>(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">Select</span>(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;rset)) &#123;	<span class="comment">/* socket is readable */</span></span><br><span class="line">			<span class="keyword">if</span> ( (n = <span class="built_in">Read</span>(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (stdineof == <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">return</span>;		<span class="comment">/* normal termination */</span></span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">err_quit</span>(<span class="string">&quot;str_cli: server terminated prematurely&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">Write</span>(<span class="built_in">fileno</span>(stdout), buf, n);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(<span class="built_in">fileno</span>(fp), &amp;rset)) &#123;  <span class="comment">/* input is readable */</span></span><br><span class="line">			<span class="keyword">if</span> ( (n = <span class="built_in">Read</span>(<span class="built_in">fileno</span>(fp), buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">				stdineof = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">Shutdown</span>(sockfd, SHUT_WR);	<span class="comment">/* send FIN */</span></span><br><span class="line">				<span class="built_in">FD_CLR</span>(<span class="built_in">fileno</span>(fp), &amp;rset);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">Writen</span>(sockfd, buf, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include fig01 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>					i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">	<span class="type">int</span>					nready, client[FD_SETSIZE];</span><br><span class="line">	<span class="type">ssize_t</span>				n;</span><br><span class="line">	fd_set				rset, allset;</span><br><span class="line">	<span class="type">char</span>				buf[MAXLINE];</span><br><span class="line">	<span class="type">socklen_t</span>			clilen;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>	cliaddr, servaddr;</span><br><span class="line"></span><br><span class="line">	listenfd = <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family      = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port        = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Bind</span>(listenfd, (SA *) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Listen</span>(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">	maxfd = listenfd;			<span class="comment">/* initialize */</span></span><br><span class="line">	maxi = <span class="number">-1</span>;					<span class="comment">/* index into client[] array */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">		client[i] = <span class="number">-1</span>;			<span class="comment">/* -1 indicates available entry */</span></span><br><span class="line">	<span class="built_in">FD_ZERO</span>(&amp;allset);</span><br><span class="line">	<span class="built_in">FD_SET</span>(listenfd, &amp;allset);</span><br><span class="line"><span class="comment">/* end fig01 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* include fig02 */</span></span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		rset = allset;		<span class="comment">/* structure assignment */</span></span><br><span class="line">		nready = <span class="built_in">Select</span>(maxfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(listenfd, &amp;rset)) &#123;	<span class="comment">/* new client connection */</span></span><br><span class="line">			clilen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">			connfd = <span class="built_in">Accept</span>(listenfd, (SA *) &amp;cliaddr, &amp;clilen);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NOTDEF</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;new client: %s, port %d\n&quot;</span>,</span><br><span class="line">					<span class="built_in">Inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr, <span class="number">4</span>, <span class="literal">NULL</span>),</span><br><span class="line">					<span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; i++)</span><br><span class="line">				<span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					client[i] = connfd;	<span class="comment">/* save descriptor */</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">				<span class="built_in">err_quit</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">FD_SET</span>(connfd, &amp;allset);	<span class="comment">/* add new descriptor to set */</span></span><br><span class="line">			<span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">				maxfd = connfd;			<span class="comment">/* for select */</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">				maxi = i;				<span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;	<span class="comment">/* check all clients for data */</span></span><br><span class="line">			<span class="keyword">if</span> ( (sockfd = client[i]) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(sockfd, &amp;rset)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( (n = <span class="built_in">Read</span>(sockfd, buf, MAXLINE)) == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">/*4connection closed by client */</span></span><br><span class="line">					<span class="built_in">Close</span>(sockfd);</span><br><span class="line">					<span class="built_in">FD_CLR</span>(sockfd, &amp;allset);</span><br><span class="line">					client[i] = <span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					<span class="built_in">Writen</span>(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end fig02 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll提供的功能和select一致，它没有select的最大描述符限制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fdarray, <span class="type">unsigned</span> <span class="type">long</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include fig01 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&quot;unp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>	<span class="string">&lt;limits.h&gt;</span>		<span class="comment">/* for OPEN_MAX */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>					i, maxi, listenfd, connfd, sockfd;</span><br><span class="line">	<span class="type">int</span>					nready;</span><br><span class="line">	<span class="type">ssize_t</span>				n;</span><br><span class="line">	<span class="type">char</span>				buf[MAXLINE];</span><br><span class="line">	<span class="type">socklen_t</span>			clilen;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">pollfd</span>		client[OPEN_MAX];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>	cliaddr, servaddr;</span><br><span class="line"></span><br><span class="line">	listenfd = <span class="built_in">Socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">bzero</span>(&amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family      = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port        = <span class="built_in">htons</span>(SERV_PORT);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Bind</span>(listenfd, (SA *) &amp;servaddr, <span class="built_in">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Listen</span>(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">	client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">	client[<span class="number">0</span>].events = POLLRDNORM;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">		client[i].fd = <span class="number">-1</span>;		<span class="comment">/* -1 indicates available entry */</span></span><br><span class="line">	maxi = <span class="number">0</span>;					<span class="comment">/* max index into client[] array */</span></span><br><span class="line"><span class="comment">/* end fig01 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* include fig02 */</span></span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		nready = <span class="built_in">Poll</span>(client, maxi+<span class="number">1</span>, INFTIM);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLRDNORM) &#123;	<span class="comment">/* new client connection */</span></span><br><span class="line">			clilen = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">			connfd = <span class="built_in">Accept</span>(listenfd, (SA *) &amp;cliaddr, &amp;clilen);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NOTDEF</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;new client: %s\n&quot;</span>, <span class="built_in">Sock_ntop</span>((SA *) &amp;cliaddr, clilen));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; OPEN_MAX; i++)</span><br><span class="line">				<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					client[i].fd = connfd;	<span class="comment">/* save descriptor */</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">				<span class="built_in">err_quit</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line"></span><br><span class="line">			client[i].events = POLLRDNORM;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">				maxi = i;				<span class="comment">/* max index in client[] array */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxi; i++) &#123;	<span class="comment">/* check all clients for data */</span></span><br><span class="line">			<span class="keyword">if</span> ( (sockfd = client[i].fd) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( (n = <span class="built_in">read</span>(sockfd, buf, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">							<span class="comment">/*4connection reset by client */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NOTDEF</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;client[%d] aborted connection\n&quot;</span>, i);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">						<span class="built_in">Close</span>(sockfd);</span><br><span class="line">						client[i].fd = <span class="number">-1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span></span><br><span class="line">						<span class="built_in">err_sys</span>(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">/*4connection closed by client */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	NOTDEF</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>, i);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">					<span class="built_in">Close</span>(sockfd);</span><br><span class="line">					client[i].fd = <span class="number">-1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					<span class="built_in">Writen</span>(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">break</span>;				<span class="comment">/* no more readable descriptors */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end fig02 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/longgeqiaojie304/article/details/100941837" >https://blog.csdn.net/longgeqiaojie304/article/details/100941837<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">eventpoll结构体如下所示：</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">eventpoll</span>&#123;</span><br><span class="line"> </span><br><span class="line">	……</span><br><span class="line">	<span class="comment">/* 红黑树根节点，这棵树中存储着所有添加到epoll中需要监控的事件 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rb_root</span> rbr;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line">	……</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在epoll中，每个事件都会建立一个epitem结构体，如下所示：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span>&#123;</span><br><span class="line">	<span class="comment">// 红黑树节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rb_node</span> rbn;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 双向链表节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 事件句柄信息</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_filefd</span> ffd;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 指向其所属的eventpoll对象</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 期待发生的事件类型</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>三个描述符集合：读、写、异常。数据的到来阻塞和从内核到进程阻塞</p>
<ul>
<li>水平触发(LT)：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>边缘触发(ET)：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个epoll的句柄，size用来告诉内核需要监听的数目一共有多大。当创建好epoll句柄后，</span></span><br><span class="line"><span class="comment">它就是会占用一个fd值，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*epoll的事件注册函数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待事件的到来，如果检测到事件，就将所有就绪的事件从内核事件表中复制到它的第二个参数events指向的数组*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POLL_CTL_ADD    <span class="comment">//注册新的fd到epfd中；</span></span><br><span class="line">EPOLL_CTL_MOD    <span class="comment">//修改已经注册的fd的监听事件；</span></span><br><span class="line">EPOLL_CTL_DEL    <span class="comment">//从epfd中删除一个fd；</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;</span><br><span class="line">    <span class="type">__uint32_t</span>   u32;</span><br><span class="line">    <span class="type">__uint64_t</span>   u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN     <span class="comment">//表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span></span><br><span class="line">EPOLLOUT    <span class="comment">//表示对应的文件描述符可以写；</span></span><br><span class="line">EPOLLPRI    <span class="comment">//表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span></span><br><span class="line">EPOLLERR    <span class="comment">//表示对应的文件描述符发生错误；</span></span><br><span class="line">EPOLLHUP    <span class="comment">//表示对应的文件描述符被挂断；</span></span><br><span class="line">EPOLLET     <span class="comment">//将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span></span><br><span class="line">EPOLLONESHOT<span class="comment">//只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTENQ 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFTIM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> opts;</span><br><span class="line">    opts=<span class="built_in">fcntl</span>(sock,F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(opts&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(sock,GETFL)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = opts|O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fcntl</span>(sock,F_SETFL,opts)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(sock,SETFL,opts)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, maxi, listenfd, connfd, sockfd,epfd,nfds, portnumber;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="type">char</span> line[MAXLINE];</span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">2</span> == argc )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (portnumber = <span class="built_in">atoi</span>(argv[<span class="number">1</span>])) &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Usage:%s portnumber/a/n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;Usage:%s portnumber/a/n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev,events[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//生成用于处理accept的epoll专用的文件描述符</span></span><br><span class="line"></span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//把socket设置为非阻塞方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//setnonblocking(listenfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置与要处理的事件相关的文件描述符</span></span><br><span class="line"></span><br><span class="line">    ev.data.fd=listenfd;</span><br><span class="line">    <span class="comment">//设置要处理的事件类型</span></span><br><span class="line"></span><br><span class="line">    ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">    <span class="comment">//ev.events=EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册epoll事件</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="type">char</span> *local_addr=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="built_in">inet_aton</span>(local_addr,&amp;(serveraddr.sin_addr));<span class="comment">//htons(portnumber);</span></span><br><span class="line"></span><br><span class="line">    serveraddr.sin_port=<span class="built_in">htons</span>(portnumber);</span><br><span class="line">    <span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line">    <span class="built_in">listen</span>(listenfd, LISTENQ);</span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">//等待epoll事件的发生</span></span><br><span class="line"></span><br><span class="line">        nfds=<span class="built_in">epoll_wait</span>(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//处理所发生的所有事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd)<span class="comment">//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                connfd = <span class="built_in">accept</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;clilen);</span><br><span class="line">                <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;connfd&lt;0&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//setnonblocking(connfd);</span></span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> *str = <span class="built_in">inet_ntoa</span>(clientaddr.sin_addr);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;accapt a connection from\n &quot;</span>);</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=connfd;</span><br><span class="line">                <span class="comment">//设置用于注测的读操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//ev.events=EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//注册ev</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLIN)<span class="comment">//如果是已经连接的用户，并且收到数据，那么进行读入。</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;EPOLLIN\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> ( (sockfd = events[i].data.fd) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (n = <span class="built_in">read</span>(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        <span class="built_in">close</span>(sockfd);</span><br><span class="line">                        events[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;readline error\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">close</span>(sockfd);</span><br><span class="line">                    events[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(n&lt;MAXLINE<span class="number">-2</span>)</span><br><span class="line">                    line[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置用于写操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                <span class="comment">//设置用于注测的写操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">                <span class="comment">//修改sockfd上要处理的事件为EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">// 如果有数据发送</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                sockfd = events[i].data.fd;</span><br><span class="line">                <span class="built_in">write</span>(sockfd, line, n);</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                <span class="comment">//设置用于注测的读操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//修改sockfd上要处理的事件为EPOLIN</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	Server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENT_NUMBER 1024  <span class="comment">//event的最大数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 10      <span class="comment">//缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENABLE_ET  1       <span class="comment">//是否启用ET模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将文件描述符设置为非拥塞的  */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SetNonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	<span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将文件描述符fd上的EPOLLIN注册到epoll_fd指示的epoll内核事件表中，参数enable_et指定是否对fd启用et模式 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> epoll_fd, <span class="type">int</span> fd, <span class="type">bool</span> enable_et)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN; <span class="comment">//注册该fd是可读的</span></span><br><span class="line">	<span class="keyword">if</span>(enable_et)</span><br><span class="line">	&#123;</span><br><span class="line">	    event.events |= EPOLLET;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);  <span class="comment">//向epoll内核事件表注册该fd</span></span><br><span class="line">	<span class="built_in">SetNonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  LT工作模式特点：稳健但效率低 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lt_process</span><span class="params">(<span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epoll_fd, <span class="type">int</span> listen_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; number; i++) <span class="comment">//number: 就绪的事件数目</span></span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">		<span class="keyword">if</span>(sockfd == listen_fd)  <span class="comment">//如果是listen的文件描述符，表明有新的客户连接到来</span></span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">			<span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">			<span class="type">int</span> connfd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">			<span class="built_in">AddFd</span>(epoll_fd, connfd, <span class="literal">false</span>);  <span class="comment">//将新的客户连接fd注册到epoll事件表,使用lt模式</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)	<span class="comment">//有客户端数据可读</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 只要缓冲区的数据还没读完，这段代码就会被触发。这就是LT模式的特点：反复通知，直至处理完成</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;lt mode: event trigger once!\n&quot;</span>);</span><br><span class="line">			<span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">			<span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)  <span class="comment">//读完数据了，记得关闭fd</span></span><br><span class="line">			&#123;</span><br><span class="line">			    <span class="built_in">close</span>(sockfd);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;something unexpected happened!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ET工作模式特点：高效但潜在危险 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">et_process</span><span class="params">(<span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> number, <span class="type">int</span> epoll_fd, <span class="type">int</span> listen_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line">	    <span class="keyword">if</span>(sockfd == listen_fd)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">			<span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">			<span class="type">int</span> connfd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">			<span class="built_in">AddFd</span>(epoll_fd, connfd, <span class="literal">true</span>);  <span class="comment">//使用et模式</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 这段代码不会被重复触发，所以我么循环读取数据，以确保把socket读缓存的所有数据读出。这就是我们消除ET模式潜在危险的手段 */</span></span><br><span class="line">			</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;et mode: event trigger once!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">				<span class="type">int</span> ret = <span class="built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">/* 对于非拥塞的IO，下面的条件成立表示数据已经全部读取完毕，此后epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作 */</span></span><br><span class="line">					</span><br><span class="line">				    <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">					&#123;</span><br><span class="line">					    <span class="built_in">printf</span>(<span class="string">&quot;read later!\n&quot;</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="built_in">close</span>(sockfd);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">				    <span class="built_in">close</span>(sockfd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="comment">//没读完，继续循环读取</span></span><br><span class="line">				&#123;</span><br><span class="line">				    <span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;something unexpected happened!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:  ip_address + port_number\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">	<span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> listen_fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(listen_fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail to create socket!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	ret = <span class="built_in">bind</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail to bind socket!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret = <span class="built_in">listen</span>(listen_fd, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail to listen socket!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENT_NUMBER];</span><br><span class="line">	<span class="type">int</span> epoll_fd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);  <span class="comment">//事件表大小为5</span></span><br><span class="line">	<span class="keyword">if</span>(epoll_fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fail to create epoll!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">AddFd</span>(epoll_fd, listen_fd, <span class="literal">true</span>); <span class="comment">//使用ET模式epoll,将listen文件描述符加入事件表</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(ENABLE_ET)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">et_process</span>(events, ret, epoll_fd, listen_fd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">lt_process</span>(events, ret, epoll_fd, listen_fd);  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">close</span>(listen_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> client_sockfd; </span><br><span class="line">    <span class="type">int</span> len; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;<span class="comment">//服务器端网络地址结构体 </span></span><br><span class="line">     <span class="type">int</span> result; </span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;ABCDE&quot;</span>; </span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;ABCDEFGHIJK&quot;</span>; </span><br><span class="line">    client_sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立客户端socket </span></span><br><span class="line">    address.sin_family = AF_INET; </span><br><span class="line">    address.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>); </span><br><span class="line">    len = <span class="built_in">sizeof</span>(address); </span><br><span class="line">    result = <span class="built_in">connect</span>(client_sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, len); </span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>) </span><br><span class="line">    &#123; </span><br><span class="line">         <span class="built_in">perror</span>(<span class="string">&quot;oops: client2&quot;</span>); </span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//第一次读写</span></span><br><span class="line">    <span class="built_in">write</span>(client_sockfd, str1, <span class="built_in">sizeof</span>(str1)); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二次读写</span></span><br><span class="line">    <span class="built_in">write</span>(client_sockfd, str2, <span class="built_in">sizeof</span>(str2)); </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(client_sockfd); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h3><p>信号驱动式IO是让内核在描述符就绪时发送SIGIO信号通知我们</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/SIGIO.svg"
                      width="400"
                >

<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>异步IO的工作机制是: 告知内核启动某个操作, 让内核在整个操作(包括将数据从内核复制到我们自己的缓冲区)完成后通知我们。<br>异步IO与信号驱动IO的区别是: 后者是有内核通知我们何时可以启动一个I&#x2F;O操作, 而前者是由内核通知我们I&#x2F;O操作何时完成。</p>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/asyncIO.svg"
                      width="400"
                >

<h3 id="I-x2F-O模型对比"><a href="#I-x2F-O模型对比" class="headerlink" title="I&#x2F;O模型对比"></a>I&#x2F;O模型对比</h3><ul>
<li>同步IO: 导致请求进程阻塞, 直到IO操作完成</li>
<li>异步IO: 不导致请求进程阻塞</li>
</ul>
<img  
                     lazyload
                     alt="image"
                     data-src="./img/IO模型对比.svg"
                      width="400"
                >

            </div>

            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/C/">#C++</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023/03/07/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">C++| 基础学习之程序编译过程</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/03/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++| 基础学习之面向对象特性</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">RibinCao</a>
            
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
