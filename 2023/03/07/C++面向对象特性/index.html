<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="RibinCao">
    
    <title>
        
            C++| 基础学习之面向对象特性 |
        
        Ribin
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"toc":{"enable":false,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066cc","logo":"/images/logo.png","favicon":"/images/logo.png","avatar":"/images/avatar.png","font_size":null,"font_family":"STKaiti","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"header_transparent":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving.","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":true}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":false,"auto":false,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":false,"wordcount":true,"min2read":true},"img_align":"center","copyright_info":false},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.png">
                </a>
            
            <a class="logo-title" href="/">
               Ribin
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                系列
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                个人简历
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">系列</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">个人简历</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">C++| 基础学习之面向对象特性</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">RibinCao</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2023-03-07 14:39:33</span>
        <span class="mobile">2023-03-07 14:39</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2023-03-11 17:42:13</span>
    </span>
    
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/C/">C++</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="三-C-面向对象特性"><a href="#三-C-面向对象特性" class="headerlink" title="[三]C++面向对象特性"></a>[三]C++面向对象特性</h1><p>面向对象有几大特性：抽象、封装、继承和多态</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>C++可以通过类class将数据和函数封装起来实现面向对象，类和对象是两个不同概念，类相当于一个模具，对象则是实例化的类，二者在访问权限上会有一些区别。</p>
<p>当类被实例化的过程中会调用构造函数去初始化这个对象，而当对象被销毁后会自动调用析构函数，我们可以在析构函数上做一些处理去释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//  使用初始化列表形式</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(string s = <span class="string">&quot;ribincao&quot;</span>, <span class="type">int</span> n = <span class="number">26</span>) : <span class="built_in">name</span>(s), <span class="built_in">age</span>(n) &#123; &#125;</span><br><span class="line">        <span class="comment">//  使用有普通函数的形式</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(string s) &#123;</span><br><span class="line">            name = s;</span><br><span class="line">            age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  拷贝构造函数</span></span><br><span class="line">        <span class="built_in">BaseClass</span>(<span class="type">const</span> BaseClass &amp;v) &#123;</span><br><span class="line">            name = v.name;</span><br><span class="line">            age = v.age;</span><br><span class="line">        &#125;</span><br><span class="line">        string name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    构造函数总结:</span></span><br><span class="line"><span class="comment">      1.概念: 类对象被创建时，编译系统为对象分配内存空间，并自动调用该构造函数-&gt;由构造函数完成成员的初始化工作</span></span><br><span class="line"><span class="comment">      2.作用: 初始化对象的数据成员</span></span><br><span class="line"><span class="comment">      3.类型</span></span><br><span class="line"><span class="comment">        - 默认构造函数: 分为有用的和无用的，无用的默认构造函数就是一个空函数什么操作也不做, 有用的默认构造函数是可以初始化成员的函数</span></span><br><span class="line"><span class="comment">        - 拷贝构造函数: 参数是本类型的一个引用变量(指针), 可实现类型转换</span></span><br><span class="line"><span class="comment">      4.注意: 默认构造函数不要出现歧义, 不要让编译器出现不知道使用哪一个构造函数的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseClass v1;</span><br><span class="line">    <span class="function">BaseClass <span class="title">v2</span><span class="params">(<span class="string">&quot;jack&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    <span class="function">BaseClass <span class="title">v3</span><span class="params">(v1)</span></span>;</span><br><span class="line">    <span class="comment">// BaseClass v4(&quot;bob&quot;); 出现歧义, 编译器不知道使用哪一个构造函数去初始化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v1] name: &quot;</span> &lt;&lt; v1.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v1.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v2] name: &quot;</span> &lt;&lt; v2.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v2.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[v3] name: &quot;</span> &lt;&lt; v3.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; v3.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Person</span>(string* s, <span class="type">int</span> n) : <span class="built_in">name</span>(s), <span class="built_in">age</span>(n) &#123;&#125;</span><br><span class="line">        <span class="comment">//  name 是指向字符串的指针, 成员占用的内存被释放, 但是字符串占用的内存没有被销毁会导致内存泄漏, 可通过析构函数去释放这部分内存</span></span><br><span class="line">        ~<span class="built_in">Person</span>()&#123;</span><br><span class="line">            <span class="keyword">if</span>(name != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">free</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        string* name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    析构函数:</span></span><br><span class="line"><span class="comment">      1.时机: 当对象被销毁时去执行</span></span><br><span class="line"><span class="comment">      2.作用: 对象被销毁时，对象所占用的内存会被释放, 但不是与它相关联的所有内存都会销毁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;ribincao&quot;</span>;</span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(&amp;name, <span class="number">26</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的内部存在三种成员：public、protected、private</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="comment">//	公共成员</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Test</span>(<span class="type">int</span> a) : <span class="built_in">data</span>(a) &#123;&#125;	<span class="comment">//	初始化列表</span></span><br><span class="line">  	<span class="built_in">Test</span>(<span class="type">const</span> Test&amp; b)&#123;			<span class="comment">//	拷贝构造函数</span></span><br><span class="line">      a.data = b.data;</span><br><span class="line">    &#125;</span><br><span class="line">  	~<span class="built_in">Test</span>()&#123;									<span class="comment">//	析构函数</span></span><br><span class="line">      <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">GetData</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//	保护成员</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="type">char</span> s;</span><br><span class="line">  <span class="comment">//	私有成员</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  	<span class="type">int</span> data;</span><br><span class="line">  	<span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Test v1 = <span class="built_in">Test</span>(<span class="number">123</span>);</span><br><span class="line">  Test v2 = v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一篇博客在讲到类的内存大小的时候我们发现类的成员函数是不占用数据段内存的，而是在代码区存储的，那不同的对象调用成员函数的时候是通过一个叫做<code>this</code>指针的东西去调用的。？</p>
<h3 id="关于函数参数"><a href="#关于函数参数" class="headerlink" title="关于函数参数"></a>关于函数参数</h3><p>关于成员函数的参数传递，和普通函数一样有三种</p>
<ul>
<li><strong>值传递</strong>：参数的值将复制到相应函数参数的值中，函数不能修改原始参数。复制结构和类会导致显着的性能损失，尤其是在多次调用函数时</li>
<li><strong>地址传递</strong>：函数会更改参数的值，可用来实现一个函数返回多个值，但不能接受常量参数</li>
<li><strong>引用</strong><ul>
<li><p>常量引用：该函数不会改变参数，同时减少复制的开销</p>
</li>
<li><p>指针引用：可以让函数完全改变指针的地址</p>
</li>
<li><p>引用传递的优点：</p>
<ul>
<li>引用允许函数更改参数的值，这有时很有用。否则，const引用可用于保证函数不会更改参数。</li>
<li>因为没有创建参数的副本，所以即使与大型结构或类一起使用，也很快通过引用传递。</li>
<li>引用可用于从函数返回多个值（通过out参数）。</li>
<li>必须初始化引用，因此不必担心空值。</li>
</ul>
<p>引用传递的缺点：</p>
<ul>
<li>由于非const引用无法使用const l值或r值（例如文字或表达式）进行初始化，因此引用参数的参数必须是常规变量。</li>
<li>很难判断非const引用传递的参数是输入，输出还是两者。明智地使用const和out变量的命名后缀可以提供帮助。</li>
<li>从函数调用中判断参数是否可能改变是不可能的。通过值传递并通过引用传递的参数看起来是相同的。我们只能通过查看函数声明来判断参数是通过值还是引用传递的。这可能导致程序员没有意识到函数会改变参数值的情况。</li>
</ul>
<p>何时使用引用传递：</p>
<ul>
<li>传递结构或类时（如果只读，则使用const）</li>
<li>当您需要该函数来修改参数时</li>
<li>当您需要访问固定数组的类型信息时</li>
</ul>
<p>何时不使用引用传递：</p>
<ul>
<li>传递不需要修改的基本类型时（使用按值传递）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>同样，参数的返回也是有三种：</p>
<ul>
<li><p><strong>按值返回</strong>：按值返回是最简单，最安全的返回类型。当按值返回值时，该值的副本将返回给调用者。按值返回的另一个优点是，您可以返回涉及在函数内声明的局部变量的变量（或表达式），而不必担心范围问题。缺点是结构和大类的返回值很慢。</p>
<ul>
<li>何时使用按值返回：<ul>
<li>返回在函数内声明的变量时</li>
<li>返回按值传递的函数参数时</li>
</ul>
</li>
<li>何时不使用按值返回：<ul>
<li>返回内置数组或指针时（使用地址返回）</li>
<li>返回大型结构或类时（使用引用返回）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>按地址返回</strong>：按地址返回只能返回变量的地址，而不是文字或表达式（没有地址）。因为按地址返回只是将函数的地址复制到调用者，所以按地址返回的速度很快。但是，按地址返回还有一个额外的缺点，即如果您尝试将函数的本地地址返回给函数，则程序将显示未定义的行为。</p>
<ul>
<li><p>何时使用地址返回：</p>
<ul>
<li>返回动态分配的内存时</li>
<li>返回由地址传递的函数参数时</li>
</ul>
</li>
<li><p>何时不使用地址返回：</p>
<ul>
<li>返回在函数内声明的变量时（使用return by value）</li>
<li>返回通过引用传递的大型结构或类时（使用按引用返回）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>按引用返回</strong>：通过引用返回通常用于将通过引用传递的参数返回给调用者。就像按地址返回一样，您不应该通过引用返回局部变量。</p>
<p>何时使用以引用方式返回：</p>
<ul>
<li>返回参考参数时</li>
<li>从传递给函数的数组返回元素时</li>
<li>返回在函数末尾不会被销毁的大型结构或类（例如传入的结构或类）</li>
</ul>
<p>何时不通过引用返回：</p>
<ul>
<li>返回在函数内声明的变量时（使用return by value）</li>
<li>返回内置数组或指针值时（使用地址返回）</li>
</ul>
</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>C++是一个多继承语言，在C++里有两种继承方式：普通继承和虚继承，继承的访问权限有两种：<code>public</code>和<code>protected</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BaseClass</span>() &#123; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in BaseClass called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">h</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function g() in BaseClass called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function h() in BaseClass\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1Level1</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> BaseClass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in DerivedLevel1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;Derived1Level1&quot;</span>);</span><br><span class="line">            <span class="built_in">h</span>(<span class="string">&quot;Derived1Level1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Function h() in Derived1Level1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2Level1</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> BaseClass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in Derived2Level1 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;Derived2Level1&quot;</span>);</span><br><span class="line">            <span class="comment">// h(); &#x27;h&#x27; is a private member of &#x27;BaseClass&#x27;, 继承是不能访问父类的 private 成员的</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedLevel2</span> : <span class="keyword">public</span> Derived1Level1, <span class="keyword">public</span> Derived2Level1 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *s = <span class="string">&quot;unknown&quot;</span>)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Function f() in DerivedLevel2 called from &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">g</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">            Derived1Level1::<span class="built_in">h</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">            BaseClass::<span class="built_in">f</span>(<span class="string">&quot;DerivedLevel2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    继承总结：</span></span><br><span class="line"><span class="comment">        1. 类和对象是有区别的, 比如类可以访问 protected 成员, 但是该类的对象是不能直接访问 protected 成员</span></span><br><span class="line"><span class="comment">        2. 继承权限</span></span><br><span class="line"><span class="comment">          - public 继承: 父类的 public 和 protected 在子类还是保持</span></span><br><span class="line"><span class="comment">          - protected 继承: 父类的 public 和 protected 在子类变成了 protected</span></span><br><span class="line"><span class="comment">        3. 继承方式</span></span><br><span class="line"><span class="comment">          - 普通继承: 多重继承可能会出现多个基类的副本, 导致二义性问题</span></span><br><span class="line"><span class="comment">          - 虚继承(virtual): 只生成一个基类的副本, 比如下面的继承关系会让 B 和 C 虚继承基类 A, 虚继承情况下，子类会生成一个虚基类指针_vbptr</span></span><br><span class="line"><span class="comment">                    A</span></span><br><span class="line"><span class="comment">                   / \</span></span><br><span class="line"><span class="comment">                  B   C</span></span><br><span class="line"><span class="comment">                   \ /</span></span><br><span class="line"><span class="comment">                    D</span></span><br><span class="line"><span class="comment">        关键词: 信息隐藏原则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BaseClass bc;</span><br><span class="line">    Derived1Level1 d1l1;</span><br><span class="line">    Derived2Level1 d2l1;</span><br><span class="line">    DerivedLevel2 dl2;</span><br><span class="line"></span><br><span class="line">    bc.<span class="built_in">f</span>(<span class="string">&quot;main(1)&quot;</span>);<span class="comment">//  类的 public 成员是可以被类对象访问的</span></span><br><span class="line">    <span class="comment">// bc.g(); 类的 protected 成员是不能被基类对象访问的</span></span><br><span class="line">    <span class="comment">// bc.h(); 类的 private 成员是不能被类对象访问的</span></span><br><span class="line"></span><br><span class="line">    d1l1.<span class="built_in">f</span>(<span class="string">&quot;main(2)&quot;</span>);<span class="comment">//  派生类在 public 继承下可以访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d1l1.g();  派生类对象不能访问父类的 protected 成员</span></span><br><span class="line">    d1l1.<span class="built_in">h</span>(<span class="string">&quot;main(3)&quot;</span>);<span class="comment">//  private 对象是不能被继承的, 派生类访问的是自己的 public 成员</span></span><br><span class="line"></span><br><span class="line">    d2l1.<span class="built_in">f</span>(<span class="string">&quot;main(4)&quot;</span>);<span class="comment">//  派生类在 public 继承下可以访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d2l1.g();  派生类对象不能访问父类的 protected 成员</span></span><br><span class="line">    <span class="comment">// d2l1.h();  private 对象是不能被继承的</span></span><br><span class="line"></span><br><span class="line">    dl2.<span class="built_in">f</span>(<span class="string">&quot;main(5)&quot;</span>);</span><br><span class="line">    <span class="comment">// dl2.g();  派生类对象不能访问父类的 protected 成员, 派生类可以</span></span><br><span class="line">    dl2.<span class="built_in">h</span>();<span class="comment">//  派生类对象可以访问父类的 public 成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C++中多态的实现有两种：静态多态和动态多态。其中静态多态通过函数重载来实现，函数重载依赖的是函数签名的机制，这也是C++区别于C的地方；动态多态则是通过虚函数来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// virtual void fun() = 0;</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Father say Hi&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Father say Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>: <span class="keyword">public</span> Father &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Son say Hi&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Son say Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHi</span><span class="params">(Father &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">Say</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">(Father &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    虚函数:</span></span><br><span class="line"><span class="comment">      1.实现: 存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针(_vfptr, 在构造函数里初始化);虚表是和类对应的，虚表指针是和对象对应的</span></span><br><span class="line"><span class="comment">      2.纯虚函数: 虚函数再加上 = 0, 存在纯虚函数的类为抽象类(接口类)，不能实例化, 子类必须重写纯虚函数</span></span><br><span class="line"><span class="comment">    多态:</span></span><br><span class="line"><span class="comment">      1.作用: 一个接口多种实现</span></span><br><span class="line"><span class="comment">      2.实现:</span></span><br><span class="line"><span class="comment">        - 虚函数-&gt;动态绑定-&gt;运行时多态。通过基类的指针或者引用，在运行时动态调用实际绑定对象函数的行为</span></span><br><span class="line"><span class="comment">        - 重载-&gt;编译时多态</span></span><br><span class="line"><span class="comment">      3.类型</span></span><br><span class="line"><span class="comment">        - 类的多态性</span></span><br><span class="line"><span class="comment">        - 函数的多态性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son son;</span><br><span class="line">    Father father;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SayHello</span>(son);</span><br><span class="line">    <span class="built_in">SayHello</span>(father);</span><br><span class="line">    <span class="comment">//  实现多态</span></span><br><span class="line">    <span class="built_in">SayHi</span>(son);</span><br><span class="line">    <span class="built_in">SayHi</span>(father);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数重载中有一种比较特殊的函数重载：运算法重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Base</span>(<span class="type">int</span> n = <span class="number">18</span>) : <span class="built_in">age</span>(n) &#123;&#125;</span><br><span class="line">        <span class="comment">//  运算符重载</span></span><br><span class="line">        Base <span class="keyword">operator</span>- () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Base</span>(-age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数重载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  按照C语言风格编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">float</span> <span class="title">sum</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    重载：</span></span><br><span class="line"><span class="comment">      1.类型</span></span><br><span class="line"><span class="comment">        - 函数重载: 函数名相同但是函数签名不同(形参个数、类型和顺序), 函数签名的实现方式不同是C语言不能实现重载的原因, 编译器编译.c文件只是对函数进行简单的重命名</span></span><br><span class="line"><span class="comment">        - 运算符重载: 本质上是函数重载</span></span><br><span class="line"><span class="comment">      2.作用: 实现静态多态</span></span><br><span class="line"><span class="comment">      3.重载和重写</span></span><br><span class="line"><span class="comment">        - 重载: 是相同的函数名字针对不同的输入进行不同的操作, 函数的签名是不同的</span></span><br><span class="line"><span class="comment">        - 重写: 子类对父类的成员函数进行重新编写来实现不同的表现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  系统会根据实参的类型来实现准确调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1.1</span>, <span class="number">2.2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重载运算符 -</span></span><br><span class="line">    <span class="function">Base <span class="title">v</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (-v).<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>C++类型转换主要分为两种：隐式类型转换、显式类型转换（强制类型转换）。隐式类型转换主要是通过operator（类型转换函数）来实现的；强制类型转换主要用到四个关键字，下面博客内容就按隐式→显式四个关键字 来展开。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><h4 id="基本数据类型间"><a href="#基本数据类型间" class="headerlink" title="基本数据类型间"></a>基本数据类型间</h4><p>基本数据类型之间进行隐式转换的几种情况：</p>
<p>1、算术转换(Arithmetic conversion) : 在混合类型的 算术表达式 中, 位数最宽的数据类型成为目标转换类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> j = <span class="number">3.1</span>;</span><br><span class="line">i+j;<span class="comment">//i会被转换成double类型，然后才做加法运算。</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>2、一种类型表达式赋值给另一种类型的对象：目标类型是被赋值对象的类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> inum = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uinum = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> dnum = <span class="number">2.3</span>;</span><br><span class="line">uinum = inum; <span class="comment">//4294967295</span></span><br><span class="line">inum = dnum;  <span class="comment">//2</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>这种情况的转换，窄类型转换为宽类型一般没有问题，宽类型转换为窄类型一般会截断转换，有符号类型转换为无符号类型会出现我们不想出现的情况。</p>
<p>3、将一个表达式作为实参传递给函数调用，此时形参和实参类型不一致：目标转换类型为形参的类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">sqrt</span><span class="params">( <span class="type">double</span> )</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; The square root of 2 is  &quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 2被提升为double类型：2.0</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>4、从一个函数返回一个表达式，表达式类型与返回类型不一致：目标转换类型为函数的返回类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">difference</span><span class="params">(<span class="type">int</span> ival1, <span class="type">int</span> ival2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ival1 - ival2;</span><br><span class="line">	<span class="comment">// 返回值被提升为double类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h4 id="用户自定义数据类型间"><a href="#用户自定义数据类型间" class="headerlink" title="用户自定义数据类型间"></a>用户自定义数据类型间</h4><p>使用子类对象代替父类对象是可以的，也是因为隐式类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;<span class="comment">//B是子类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(A&amp; a)</span></span>;</span><br><span class="line">B b;</span><br><span class="line"><span class="built_in">Fun</span>(b);<span class="comment">//使用子类对象代替父类对象是可以的，也是因为隐式类型转换。</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>如果想将当前类类型转换为其他类型的时候，该怎么做呢？C++ 提供了类型转换函数（Type conversion function）来解决这个问题，它只能以成员函数的形式出现，也就是只能出现在类中。类型转换函数的语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><code>operator</code> 是 C++ 关键字，<code>type</code> 是要转换的目标类型，<code>data</code> 是要返回的 type 类型的数据。</p>
<p>因为要转换的目标类型是 type，所以返回值 data 也必须是 type 类型。既然已经知道了要返回 type 类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</p>
<p>类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给 this 指针，这样在函数体内就可以操作当前对象了。</p>
<p>类型转换函数可以看成式转换构造函数的逆，因为转换构造函数能够将其它类型转换为当前类类型，而类型转换函数可以将当前类类型转换为其他类类型。下面看个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(): <span class="built_in">m_real</span>(<span class="number">0.0</span>), <span class="built_in">m_imag</span>(<span class="number">0.0</span>)&#123; &#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag): <span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag)&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> m_real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="type">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>里面<code>operator</code>那一行，就是类型转换函数，它可以将复数类型转换为double类型，有了它，下面的代码就可以成功运行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> f = c1;  <span class="comment">//相当于 double f = Complex::operator double(&amp;c1);</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>笔者认为C++是对C补充和更新，首先看C的强制转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(type-id)expression<span class="comment">//转换格式1</span></span><br><span class="line">type-<span class="built_in">id</span>(expression)<span class="comment">//转换格式2</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>c语言强制类型转换主要用于 基础的数据类型间的转换，c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：<code>static_cast、dynamic_cast、const_cast、reinterpret_cast</code>，主要运用于继承关系类间的强制转化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;new_type&gt;      (expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;     (expression) </span><br><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;       (expression) </span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt; (expression)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><code>new_type</code>为目标数据类型，<code>expression</code>为原始数据类型变量或者表达式。对其简单如下表所示：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static_cast</td>
<td>用于良性转换，一般不会导致意外发生，风险很低。</td>
</tr>
<tr>
<td>const_cast</td>
<td>用于 const 与非 const、volatile 与非 volatile 之间的转换。</td>
</tr>
<tr>
<td>reinterpret_cast</td>
<td>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。</td>
</tr>
<tr>
<td>dynamic_cast</td>
<td>借助 RTTI，用于类型安全的向下转型（Downcasting）。</td>
</tr>
</tbody></table>
<p>有的书中，将c语言强制类型转换称为旧式转型，c++强制类型转换称为新式转型。</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</p>
<p>static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：</p>
<ul>
<li>原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；</li>
<li>void 指针和具体类型指针之间的转换，例如<code>void *</code>转<code>int *</code>、<code>char *</code>转<code>void *</code>等；</li>
<li>有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。</li>
</ul>
<p>需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：</p>
<ul>
<li>两个具体类型指针之间的转换，例如<code>int *</code>转<code>double *</code>、<code>Student *</code>转<code>int *</code>等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。</li>
<li>int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。</li>
<li>static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 <code>const/volatile</code> 类型转换为非 <code>const/volatile</code> 类型。</li>
</ul>
<p>下面是一些用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是正确的用法</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">100</span>;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">12.5</span>, <span class="number">23.8</span>)</span></span>;</span><br><span class="line"><span class="type">long</span> n = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(m);  <span class="comment">//宽转换，没有信息丢失</span></span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(m);  <span class="comment">//窄转换，可能会丢失信息</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;( <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>)) );  <span class="comment">//将void指针转换为具体类型指针</span></span><br><span class="line"><span class="type">void</span> *p2 = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(p1);  <span class="comment">//将具体类型指针，转换为void指针</span></span><br><span class="line"><span class="type">double</span> real= <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(c);  <span class="comment">//调用类型转换函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的用法是错误的</span></span><br><span class="line"><span class="type">float</span> *p3 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(p1);  <span class="comment">//不能在两个具体类型的指针之间进行转换</span></span><br><span class="line">p3 = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>*&gt;(<span class="number">0X2DF9</span>);  <span class="comment">//不能将整数转换为指针类型</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const&#x2F;volatile 类型转换为非 const&#x2F;volatile 类型。看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;n);</span><br><span class="line">*p = <span class="number">234</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;n = &quot;</span>&lt;&lt;n&lt;&lt;endl;   <span class="comment">//  n = 100</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;*p = &quot;</span>&lt;&lt;*p&lt;&lt;endl; <span class="comment">//  *p = 234</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p><code>&amp;n</code>用来获取 n 的地址，它的类型为<code>const int *</code>，必须使用 const_cast 转换为<code>int *</code>类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。也就是说：p 和<code>&amp;n</code>指向的是相同的地址。</p>
<p>有读者可能会问，为什么通过 n 和 <code>*p</code> 输出的值不一样呢？这是因为 C++ 对常量的处理更像是编译时期的<code>#define</code>，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。换句话说，<code>cout&lt;&lt;&quot;n = &quot;&lt;&lt;n&lt;&lt;endl;</code>这行代码被修改成了<code>cout&lt;&lt;&quot;n = &quot;&lt;&lt;100&lt;&lt;endl;</code></p>
<p>这样以来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了。使用 const_cast 进行强制类型转换可以突破 C&#x2F;C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。</p>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。</p>
<p><code>reinterpret_cast</code> 可以认为是 <code>static_cast</code> 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。</p>
<p>下面的代码代码演示了 reinterpret_cast 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>): <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将 char* 转换为 float*</span></span><br><span class="line">    <span class="type">char</span> str[]=<span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br><span class="line">    <span class="type">float</span> *p1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>*&gt;(str);</span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;endl;  <span class="comment">//3.0262e+29</span></span><br><span class="line">    <span class="comment">//将 int 转换为 int*</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//将 A* 转换为 int*</span></span><br><span class="line">    p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">25</span>, <span class="number">96</span>));</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl; <span class="comment">//25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将<code>A*</code>转换为<code>int*</code>，使用指针直接访问 <code>private</code> 成员刺穿了一个类的封装性，更好的办法是让类提供 <code>get/set</code> 函数，间接地访问成员变量。</p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p><code>dynamic_cast</code> 与 <code>static_cast</code> 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</p>
<p>dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI （Run Time Type Identification,通过运行时类型识别）进行检测，所有只有一部分能成功。<br>dynamic_cast 的语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span> &lt;newType&gt; (expression)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>newType 和 expression 必须同时是指针类型或者引用类型。换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。</p>
<p>对于指针，如果转换失败将返回 <code>NULL</code>；对于引用，如果转换失败将抛出<code>std::bad_cast</code>异常。</p>
<h4 id="向上转型（Upcasting）"><a href="#向上转型（Upcasting）" class="headerlink" title="向上转型（Upcasting）"></a>向上转型（Upcasting）</h4><p>向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功。因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a = <span class="number">0</span>): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_a</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> m_a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>): <span class="built_in">Base</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_b</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    Derived *pd1 = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="number">35</span>, <span class="number">78</span>);</span><br><span class="line">    Base *pb1 = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(pd1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd1 = &quot;</span>&lt;&lt;pd1&lt;&lt;<span class="string">&quot;, pb1 = &quot;</span>&lt;&lt;pb1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb1-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;</span><br><span class="line">    pb1-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    Derived *pd2 = <span class="built_in">reinterpret_cast</span>&lt;Derived*&gt;(&amp;n);</span><br><span class="line">    Base *pb2 = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(pd2);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd2 = &quot;</span>&lt;&lt;pd2&lt;&lt;<span class="string">&quot;, pb2 = &quot;</span>&lt;&lt;pb2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb2-&gt;<span class="built_in">get_a</span>()&lt;&lt;endl;  <span class="comment">//输出一个垃圾值</span></span><br><span class="line">    pb2-&gt;<span class="built_in">func</span>();  <span class="comment">//内存错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839</span></span><br></pre></td></tr></table></figure>

<p>情况①是正确的，没有任何问题。对于情况②，pd 指向的是整型变量 n，并没有指向一个 Derived 类的对象，在使用 <code>dynamic_cast</code> 进行类型转换时也没有检查这一点，而是将 pd 的值直接赋给了 pb（这里并不需要调整偏移量），最终导致 pb 也指向了 n。因为 pb 指向的不是一个对象，所以get_a()得不到 m_a 的值（实际上得到的是一个垃圾值），pb2-&gt;func()也得不到 func() 函数的正确地址。</p>
<blockquote>
<p>pb2-&gt;func()得不到 func() 的正确地址的原因在于，pb2 指向的是一个假的“对象”，它没有虚函数表，也没有虚函数表指针，而 func() 是虚函数，必须到虚函数表中才能找到它的地址。</p>
</blockquote>
<h4 id="向下转型（Downcasting）"><a href="#向下转型（Downcasting）" class="headerlink" title="向下转型（Downcasting）"></a>向下转型（Downcasting）</h4><p>向下转型是有风险的，<code>dynamic_cast</code> 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败。那么，哪些向下转型是安全地呢，哪些又是不安全的呢？下面我们通过一个例子来演示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class A&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class B&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class C&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;Class D&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    B *pb;</span><br><span class="line">    C *pc;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况①</span></span><br><span class="line">    pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="built_in">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型失败</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//情况②</span></span><br><span class="line">    pa = <span class="keyword">new</span> <span class="built_in">D</span>();  <span class="comment">//向上转型都是允许的</span></span><br><span class="line">    pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pb == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to B*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pb -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pc = <span class="built_in">dynamic_cast</span>&lt;C*&gt;(pa);  <span class="comment">//向下转型成功</span></span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting failed: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Downcasting successfully: A* to C*&quot;</span>&lt;&lt;endl;</span><br><span class="line">        pc -&gt; <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273</span></span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Downcasting failed: A* to B*</span><br><span class="line">Downcasting failed: A* to C*</span><br><span class="line">-------------------------</span><br><span class="line">Downcasting successfully: A* to B*</span><br><span class="line">Class D</span><br><span class="line">Downcasting successfully: A* to C*</span><br><span class="line">Class D</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>这段代码中类的继承顺序为：A –&gt; B –&gt; C –&gt; D。pa 是<code>A*</code>类型的指针，当 pa 指向 A 类型的对象时，向下转型失败，pa 不能转换为<code>B*</code>或<code>C*</code>类型。当 pa 指向 D 类型的对象时，向下转型成功，pa 可以转换为<code>B*</code>或<code>C*</code>类型。同样都是向下转型，为什么 pa 指向的对象不同，转换的结果就大相径庭呢？</p>
<p>这是因为：每个类都会在内存中保存一份类型信息，编译器会将存在继承关系的类的类型信息使用指针“连接”起来，从而形成一个继承链（Inheritance Chain），也就是如下图所示的样子：<br><img  
                     lazyload
                     alt="image"
                     data-src="https://img-blog.csdnimg.cn/20210120195837787.png"
                      alt="在这里插入图片描述"
                ><br>当使用 <code>dynamic_cast</code> 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类）的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。</p>
<p>对于本例中的情况①，pa 指向 A 类对象，根据该对象找到的就是 A 的类型信息，当程序从这个节点开始向上遍历时，发现 A 的上方没有要转换的 B 类型或 C 类型（实际上 A 的上方没有任何类型了），所以就转换败了。对于情况②，pa 指向 D 类对象，根据该对象找到的就是 D 的类型信息，程序从这个节点向上遍历的过程中，发现了 C 类型和 B 类型，所以就转换成功了。</p>
<p>总的来说，dynamic_cast 会在程序运行过程中遍历继承链，如果途中遇到了要转换的目标类型，那么就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，那么就转换失败。对于同一个指针（例如 pa），它指向的对象不同，会导致遍历继承链的起点不一样，途中能够匹配到的类型也不一样，所以相同的类型转换产生了不同的结果。</p>
<p>从表面上看起来 dynamic_cast 确实能够向下转型，本例也很好地证明了这一点：B 和 C 都是 A 的派生类，我们成功地将 pa 从 A 类型指针转换成了 B 和 C 类型指针。但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它，这样做始终是安全的。本例中的情况②，pa 指向的对象是 D 类型的，pa、pb、pc 都是 D 的基类的指针，所以它们都可以指向 D 类型的对象，dynamic_cast 只是让不同的基类指针指向同一个派生类对象罢了。</p>

            </div>

            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/C/">#C++</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023/03/07/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">C++| 基础学习之程序编译过程</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/03/07/C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%BC%8F/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++| 基础学习之内存模式</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2020</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">RibinCao</a>
            
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
